{"version":3,"sources":["tests/acceptance/basic-editor-test.js","tests/acceptance/cursor-movement-test.js","tests/acceptance/cursor-position-test.js","tests/acceptance/editor-atoms-test.js","tests/acceptance/editor-cards-test.js","tests/acceptance/editor-copy-paste-test.js","tests/acceptance/editor-disable-editing-test.js","tests/acceptance/editor-drag-drop-test.js","tests/acceptance/editor-input-handlers-test.js","tests/acceptance/editor-key-commands-test.js","tests/acceptance/editor-list-test.js","tests/acceptance/editor-post-editor-test.js","tests/acceptance/editor-reparse-test.js","tests/acceptance/editor-sections-test.js","tests/acceptance/editor-selections-test.js","tests/acceptance/editor-undo-redo-test.js","tests/eslint/acceptance/basic-editor-test.lint-test.js","tests/eslint/acceptance/cursor-movement-test.lint-test.js","tests/eslint/acceptance/cursor-position-test.lint-test.js","tests/eslint/acceptance/editor-atoms-test.lint-test.js","tests/eslint/acceptance/editor-cards-test.lint-test.js","tests/eslint/acceptance/editor-copy-paste-test.lint-test.js","tests/eslint/acceptance/editor-disable-editing-test.lint-test.js","tests/eslint/acceptance/editor-drag-drop-test.lint-test.js","tests/eslint/acceptance/editor-input-handlers-test.lint-test.js","tests/eslint/acceptance/editor-key-commands-test.lint-test.js","tests/eslint/acceptance/editor-list-test.lint-test.js","tests/eslint/acceptance/editor-post-editor-test.lint-test.js","tests/eslint/acceptance/editor-reparse-test.lint-test.js","tests/eslint/acceptance/editor-sections-test.lint-test.js","tests/eslint/acceptance/editor-selections-test.lint-test.js","tests/eslint/acceptance/editor-undo-redo-test.lint-test.js","tests/eslint/fixtures/google-docs.lint-test.js","tests/eslint/helpers/assertions.lint-test.js","tests/eslint/helpers/browsers.lint-test.js","tests/eslint/helpers/dom.lint-test.js","tests/eslint/helpers/editor.lint-test.js","tests/eslint/helpers/mobiledoc.lint-test.js","tests/eslint/helpers/mock-editor.lint-test.js","tests/eslint/helpers/module-load-failure.lint-test.js","tests/eslint/helpers/post-abstract.lint-test.js","tests/eslint/helpers/post-editor-run.lint-test.js","tests/eslint/helpers/render-built-abstract.lint-test.js","tests/eslint/helpers/wait.lint-test.js","tests/eslint/js/cards/image.lint-test.js","tests/eslint/js/editor/edit-history.lint-test.js","tests/eslint/js/editor/edit-state.lint-test.js","tests/eslint/js/editor/editor.lint-test.js","tests/eslint/js/editor/event-manager.lint-test.js","tests/eslint/js/editor/key-commands.lint-test.js","tests/eslint/js/editor/mutation-handler.lint-test.js","tests/eslint/js/editor/post.lint-test.js","tests/eslint/js/editor/post/post-inserter.lint-test.js","tests/eslint/js/editor/selection-change-observer.lint-test.js","tests/eslint/js/editor/selection-manager.lint-test.js","tests/eslint/js/editor/text-input-handler.lint-test.js","tests/eslint/js/editor/text-input-handlers.lint-test.js","tests/eslint/js/editor/ui.lint-test.js","tests/eslint/js/index.lint-test.js","tests/eslint/js/models/_markerable.lint-test.js","tests/eslint/js/models/_section.lint-test.js","tests/eslint/js/models/atom-node.lint-test.js","tests/eslint/js/models/atom.lint-test.js","tests/eslint/js/models/card-node.lint-test.js","tests/eslint/js/models/card.lint-test.js","tests/eslint/js/models/image.lint-test.js","tests/eslint/js/models/lifecycle-callbacks.lint-test.js","tests/eslint/js/models/list-item.lint-test.js","tests/eslint/js/models/list-section.lint-test.js","tests/eslint/js/models/marker.lint-test.js","tests/eslint/js/models/markup-section.lint-test.js","tests/eslint/js/models/markup.lint-test.js","tests/eslint/js/models/post-node-builder.lint-test.js","tests/eslint/js/models/post.lint-test.js","tests/eslint/js/models/render-node.lint-test.js","tests/eslint/js/models/render-tree.lint-test.js","tests/eslint/js/models/types.lint-test.js","tests/eslint/js/parsers/dom.lint-test.js","tests/eslint/js/parsers/html.lint-test.js","tests/eslint/js/parsers/mobiledoc/0-2.lint-test.js","tests/eslint/js/parsers/mobiledoc/0-3-1.lint-test.js","tests/eslint/js/parsers/mobiledoc/0-3.lint-test.js","tests/eslint/js/parsers/mobiledoc/index.lint-test.js","tests/eslint/js/parsers/section.lint-test.js","tests/eslint/js/parsers/text.lint-test.js","tests/eslint/js/renderers/editor-dom.lint-test.js","tests/eslint/js/renderers/mobiledoc/0-2.lint-test.js","tests/eslint/js/renderers/mobiledoc/0-3-1.lint-test.js","tests/eslint/js/renderers/mobiledoc/0-3.lint-test.js","tests/eslint/js/renderers/mobiledoc/index.lint-test.js","tests/eslint/js/utils/array-utils.lint-test.js","tests/eslint/js/utils/assert.lint-test.js","tests/eslint/js/utils/browser.lint-test.js","tests/eslint/js/utils/characters.lint-test.js","tests/eslint/js/utils/compiler.lint-test.js","tests/eslint/js/utils/copy.lint-test.js","tests/eslint/js/utils/cursor.lint-test.js","tests/eslint/js/utils/cursor/position.lint-test.js","tests/eslint/js/utils/cursor/range.lint-test.js","tests/eslint/js/utils/deprecate.lint-test.js","tests/eslint/js/utils/dom-utils.lint-test.js","tests/eslint/js/utils/element-map.lint-test.js","tests/eslint/js/utils/element-utils.lint-test.js","tests/eslint/js/utils/environment.lint-test.js","tests/eslint/js/utils/fixed-queue.lint-test.js","tests/eslint/js/utils/key.lint-test.js","tests/eslint/js/utils/keycodes.lint-test.js","tests/eslint/js/utils/keys.lint-test.js","tests/eslint/js/utils/linked-item.lint-test.js","tests/eslint/js/utils/linked-list.lint-test.js","tests/eslint/js/utils/log-manager.lint-test.js","tests/eslint/js/utils/markuperable.lint-test.js","tests/eslint/js/utils/merge.lint-test.js","tests/eslint/js/utils/mixin.lint-test.js","tests/eslint/js/utils/mobiledoc-error.lint-test.js","tests/eslint/js/utils/parse-utils.lint-test.js","tests/eslint/js/utils/placeholder-image-src.lint-test.js","tests/eslint/js/utils/selection-utils.lint-test.js","tests/eslint/js/utils/set.lint-test.js","tests/eslint/js/utils/string-utils.lint-test.js","tests/eslint/js/utils/to-range.lint-test.js","tests/eslint/js/version.lint-test.js","tests/eslint/js/views/tooltip.lint-test.js","tests/eslint/js/views/view.lint-test.js","tests/eslint/test-helpers.lint-test.js","tests/eslint/unit/editor/atom-lifecycle-test.lint-test.js","tests/eslint/unit/editor/card-lifecycle-test.lint-test.js","tests/eslint/unit/editor/editor-events-test.lint-test.js","tests/eslint/unit/editor/editor-test.lint-test.js","tests/eslint/unit/editor/key-commands-test.lint-test.js","tests/eslint/unit/editor/post-delete-at-position-test.lint-test.js","tests/eslint/unit/editor/post-delete-range-test.lint-test.js","tests/eslint/unit/editor/post-test.lint-test.js","tests/eslint/unit/editor/post/insert-post-test.lint-test.js","tests/eslint/unit/editor/ui-test.lint-test.js","tests/eslint/unit/models/atom-test.lint-test.js","tests/eslint/unit/models/card-test.lint-test.js","tests/eslint/unit/models/lifecycle-callbacks-test.lint-test.js","tests/eslint/unit/models/list-section-test.lint-test.js","tests/eslint/unit/models/marker-test.lint-test.js","tests/eslint/unit/models/markup-section-test.lint-test.js","tests/eslint/unit/models/post-node-builder-test.lint-test.js","tests/eslint/unit/models/post-test.lint-test.js","tests/eslint/unit/parsers/dom-test.lint-test.js","tests/eslint/unit/parsers/html-google-docs-test.lint-test.js","tests/eslint/unit/parsers/html-google-sheets-test.lint-test.js","tests/eslint/unit/parsers/html-test.lint-test.js","tests/eslint/unit/parsers/mobiledoc-test.lint-test.js","tests/eslint/unit/parsers/mobiledoc/0-2-test.lint-test.js","tests/eslint/unit/parsers/mobiledoc/0-3-test.lint-test.js","tests/eslint/unit/parsers/section-test.lint-test.js","tests/eslint/unit/parsers/text-test.lint-test.js","tests/eslint/unit/renderers/editor-dom-test.lint-test.js","tests/eslint/unit/renderers/mobiledoc-test.lint-test.js","tests/eslint/unit/renderers/mobiledoc/0-2-test.lint-test.js","tests/eslint/unit/renderers/mobiledoc/0-3-test.lint-test.js","tests/eslint/unit/utils/array-utils-test.lint-test.js","tests/eslint/unit/utils/assert-test.lint-test.js","tests/eslint/unit/utils/copy-test.lint-test.js","tests/eslint/unit/utils/cursor-position-test.lint-test.js","tests/eslint/unit/utils/cursor-range-test.lint-test.js","tests/eslint/unit/utils/fixed-queue-test.lint-test.js","tests/eslint/unit/utils/key-test.lint-test.js","tests/eslint/unit/utils/linked-list-test.lint-test.js","tests/eslint/unit/utils/parse-utils-test.lint-test.js","tests/eslint/unit/utils/selection-utils-test.lint-test.js","tests/fixtures/google-docs.js","tests/helpers/assertions.js","tests/helpers/browsers.js","tests/helpers/dom.js","tests/helpers/editor.js","tests/helpers/mobiledoc.js","tests/helpers/mock-editor.js","tests/helpers/module-load-failure.js","tests/helpers/post-abstract.js","tests/helpers/post-editor-run.js","tests/helpers/render-built-abstract.js","tests/helpers/wait.js","tests/test-helpers.js","tests/unit/editor/atom-lifecycle-test.js","tests/unit/editor/card-lifecycle-test.js","tests/unit/editor/editor-events-test.js","tests/unit/editor/editor-test.js","tests/unit/editor/key-commands-test.js","tests/unit/editor/post-delete-at-position-test.js","tests/unit/editor/post-delete-range-test.js","tests/unit/editor/post-test.js","tests/unit/editor/post/insert-post-test.js","tests/unit/editor/ui-test.js","tests/unit/models/atom-test.js","tests/unit/models/card-test.js","tests/unit/models/lifecycle-callbacks-test.js","tests/unit/models/list-section-test.js","tests/unit/models/marker-test.js","tests/unit/models/markup-section-test.js","tests/unit/models/post-node-builder-test.js","tests/unit/models/post-test.js","tests/unit/parsers/dom-test.js","tests/unit/parsers/html-google-docs-test.js","tests/unit/parsers/html-google-sheets-test.js","tests/unit/parsers/html-test.js","tests/unit/parsers/mobiledoc-test.js","tests/unit/parsers/mobiledoc/0-2-test.js","tests/unit/parsers/mobiledoc/0-3-test.js","tests/unit/parsers/section-test.js","tests/unit/parsers/text-test.js","tests/unit/renderers/editor-dom-test.js","tests/unit/renderers/mobiledoc-test.js","tests/unit/renderers/mobiledoc/0-2-test.js","tests/unit/renderers/mobiledoc/0-3-test.js","tests/unit/utils/array-utils-test.js","tests/unit/utils/assert-test.js","tests/unit/utils/copy-test.js","tests/unit/utils/cursor-position-test.js","tests/unit/utils/cursor-range-test.js","tests/unit/utils/fixed-queue-test.js","tests/unit/utils/key-test.js","tests/unit/utils/linked-list-test.js","tests/unit/utils/parse-utils-test.js","tests/unit/utils/selection-utils-test.js"],"sourcesContent":["define('tests/acceptance/basic-editor-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/utils/characters'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitUtilsCharacters) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var cards = [{\n    name: 'my-card',\n    type: 'dom',\n    render: function render() {},\n    edit: function edit() {}\n  }];\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  _module('Acceptance: editor: basic', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('sets element as contenteditable', function (assert) {\n    editor = new _mobiledocKit.Editor();\n    editor.render(editorElement);\n\n    assert.equal(editorElement.getAttribute('contenteditable'), 'true', 'element is contenteditable');\n  });\n\n  test('clicking outside the editor does not raise an error', function (assert) {\n    var done = assert.async();\n    editor = new _mobiledocKit.Editor({ autofocus: false });\n    editor.render(editorElement);\n\n    var secondEditorElement = document.createElement('div');\n    document.body.appendChild(secondEditorElement);\n\n    var secondEditor = new _mobiledocKit.Editor(); // This editor will be focused\n    secondEditor.render(secondEditorElement);\n\n    _testHelpers['default'].dom.triggerEvent(editorElement, 'click');\n\n    _testHelpers['default'].wait(function () {\n      assert.ok(true, 'can click external item without error');\n      secondEditor.destroy();\n      document.body.removeChild(secondEditorElement);\n\n      done();\n    });\n  });\n\n  test('typing in empty post correctly adds a section to it', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      return post();\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor');\n    assert.hasNoElement('#editor p');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor p:contains(X)');\n    _testHelpers['default'].dom.insertText(editor, 'Y');\n    assert.hasElement('#editor p:contains(XY)', 'inserts text at correct spot');\n  });\n\n  test('typing when on the end of a card is blocked', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('[my-card]', { element: editorElement, cards: cards });\n\n    var endingZWNJ = $('#editor')[0].firstChild.lastChild;\n    _testHelpers['default'].dom.moveCursorTo(editor, endingZWNJ, 0);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasNoElement('#editor div:contains(X)');\n    _testHelpers['default'].dom.moveCursorTo(editor, endingZWNJ, 1);\n    _testHelpers['default'].dom.insertText(editor, 'Y');\n    assert.hasNoElement('#editor div:contains(Y)');\n  });\n\n  test('typing when on the start of a card is blocked', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('[my-card]', { element: editorElement, cards: cards });\n\n    var startingZWNJ = $('#editor')[0].firstChild.firstChild;\n    _testHelpers['default'].dom.moveCursorTo(editor, startingZWNJ, 0);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasNoElement('#editor div:contains(X)');\n    _testHelpers['default'].dom.moveCursorTo(editor, startingZWNJ, 1);\n    _testHelpers['default'].dom.insertText(editor, 'Y');\n    assert.hasNoElement('#editor div:contains(Y)');\n  });\n\n  test('typing tab enters a tab character', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('|', { element: editorElement });\n\n    _testHelpers['default'].dom.insertText(editor, _mobiledocKitUtilsCharacters.TAB);\n    _testHelpers['default'].dom.insertText(editor, 'Y');\n\n    var _Helpers$postAbstract$buildFromText = _testHelpers['default'].postAbstract.buildFromText(_mobiledocKitUtilsCharacters.TAB + 'Y');\n\n    var expected = _Helpers$postAbstract$buildFromText.post;\n\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/215\n  test('select-all and type text works ok', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('<abc>', { element: editorElement });\n\n    assert.selectedText('abc', 'precond - abc is selected');\n    assert.hasElement('#editor p:contains(abc)', 'precond - renders p');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasNoElement('#editor p:contains(abc)', 'replaces existing text');\n    assert.hasElement('#editor p:contains(X)', 'inserts text');\n  });\n\n  test('typing enter splits lines, sets cursor', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('hi|hey', { element: editorElement });\n\n    assert.hasElement('#editor p:contains(hihey)');\n\n    _testHelpers['default'].dom.insertText(editor, _mobiledocKitUtilsCharacters.ENTER);\n\n    var _Helpers$postAbstract$buildFromText2 = _testHelpers['default'].postAbstract.buildFromText(['hi', '|hey']);\n\n    var expected = _Helpers$postAbstract$buildFromText2.post;\n    var expectedRange = _Helpers$postAbstract$buildFromText2.range;\n\n    assert.postIsSimilar(editor.post, expected, 'correctly encoded');\n    assert.rangeIsEqual(editor.range, _testHelpers['default'].editor.retargetRange(expectedRange, editor.post));\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/306\n  test('adding/removing bold text between two bold markers works', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('*abc*123*def*', { element: editorElement });\n\n    // preconditions\n    assert.hasElement('#editor b:contains(abc)');\n    assert.hasElement('#editor b:contains(def)');\n    assert.hasNoElement('#editor b:contains(123)');\n\n    _testHelpers['default'].dom.selectText(editor, '123', editorElement);\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('b');\n    });\n\n    assert.hasElement('#editor b:contains(abc123def)', 'adds B to selection');\n\n    assert.equal(_testHelpers['default'].dom.getSelectedText(), '123', '123 still selected');\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('b');\n    });\n\n    assert.hasElement('#editor b:contains(abc)', 'removes B from middle, leaves abc');\n    assert.hasElement('#editor b:contains(def)', 'removes B from middle, leaves def');\n    assert.hasNoElement('#editor b:contains(123)', 'removes B from middle');\n  });\n\n  test('keypress events when the editor does not have selection are ignored', function (assert) {\n    var done = assert.async();\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      expected = post([markupSection('p', [marker('abc')])]);\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    _testHelpers['default'].dom.clearSelection();\n\n    _testHelpers['default'].wait(function () {\n      assert.ok(!editor.hasCursor(), 'precond - editor does not have cursor');\n      _testHelpers['default'].dom.insertText(editor, 'v');\n\n      assert.postIsSimilar(editor.post, expected, 'post is not changed');\n      done();\n    });\n  });\n\n  test('prevent handling newline', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('', { element: editorElement });\n\n    editor.willHandleNewline(function (event) {\n      assert.ok(true, 'willHandleNewline should be triggered');\n      event.preventDefault();\n    });\n\n    var _Helpers$postAbstract$buildFromText3 = _testHelpers['default'].postAbstract.buildFromText(['Line1']);\n\n    var expected = _Helpers$postAbstract$buildFromText3.post;\n\n    _testHelpers['default'].dom.insertText(editor, 'Line1');\n    _testHelpers['default'].dom.insertText(editor, _mobiledocKitUtilsCharacters.ENTER);\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  // These keys have meaning with the IME window so should be ignored.\n  var IGNORED_IME_KEYS = ['Enter', 'Tab', 'ArrowLeft', 'ArrowRight', ' ', 'Backspace'];\n\n  IGNORED_IME_KEYS.forEach(function (key) {\n    test('pressing \"' + key + '\" in Input Method Editor (IME) is ignored', function (assert) {\n      editor = _testHelpers['default'].editor.buildFromText('hi|hey', { element: editorElement });\n\n      assert.hasElement('#editor p:contains(hihey)');\n\n      _testHelpers['default'].dom.triggerImeKeyDown(editor, key);\n\n      var _Helpers$postAbstract$buildFromText4 = _testHelpers['default'].postAbstract.buildFromText(['hi|hey']);\n\n      var expected = _Helpers$postAbstract$buildFromText4.post;\n\n      assert.postIsSimilar(editor.post, expected, 'correctly encoded');\n    });\n  });\n});","define('tests/acceptance/cursor-movement-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/utils/key', '../helpers/browsers'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitUtilsKey, _helpersBrowsers) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var cards = [{\n    name: 'my-card',\n    type: 'dom',\n    render: function render() {},\n    edit: function edit() {}\n  }];\n\n  var atoms = [{\n    name: 'my-atom',\n    type: 'dom',\n    render: function render() {\n      return document.createTextNode('my-atom');\n    }\n  }];\n\n  var editor = undefined,\n      editorElement = undefined;\n  var editorOptions = { cards: cards, atoms: atoms };\n\n  _module('Acceptance: Cursor Movement', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('left arrow when at the end of a card moves the cursor across the card', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var cardSection = _ref.cardSection;\n\n      return post([cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n    var cardHead = editor.post.sections.head.headPosition();\n\n    // Before zwnj\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 0);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    var _editor = editor;\n    var range = _editor.range;\n\n    assert.positionIsEqual(range.head, cardHead);\n    assert.positionIsEqual(range.tail, cardHead);\n\n    // After zwnj\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 1);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, cardHead);\n    assert.positionIsEqual(range.tail, cardHead);\n\n    // On wrapper\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild, 2);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, cardHead);\n    assert.positionIsEqual(range.tail, cardHead);\n  });\n\n  test('left arrow when at the start of a card moves the cursor to the previous section', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var cardSection = _ref2.cardSection;\n\n      return post([markupSection('p'), cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n    var sectionTail = editor.post.sections.head.tailPosition();\n\n    // Before zwnj\n    var sectionElement = editor.post.sections.tail.renderNode.element;\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.firstChild, 0);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    var _editor2 = editor;\n    var range = _editor2.range;\n\n    assert.positionIsEqual(range.head, sectionTail);\n    assert.positionIsEqual(range.tail, sectionTail);\n\n    // After zwnj\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.firstChild, 1);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, sectionTail);\n    assert.positionIsEqual(range.tail, sectionTail);\n  });\n\n  test('left arrow when at the start of a card moves to previous list item', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref3) {\n      var post = _ref3.post;\n      var listSection = _ref3.listSection;\n      var listItem = _ref3.listItem;\n      var marker = _ref3.marker;\n      var cardSection = _ref3.cardSection;\n\n      return post([listSection('ul', [listItem([marker('abc')])]), cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n    var itemTail = editor.post.sections.head.items.head.tailPosition();\n\n    // Before zwnj\n    var sectionElement = editor.post.sections.tail.renderNode.element;\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.firstChild, 0);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    var _editor3 = editor;\n    var range = _editor3.range;\n\n    assert.positionIsEqual(range.head, itemTail);\n    assert.positionIsEqual(range.tail, itemTail);\n\n    // After zwnj\n    sectionElement = editor.post.sections.tail.renderNode.element;\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.firstChild, 1);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, itemTail);\n    assert.positionIsEqual(range.tail, itemTail);\n  });\n\n  test('right arrow at start of card moves the cursor across the card', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref4) {\n      var post = _ref4.post;\n      var cardSection = _ref4.cardSection;\n\n      return post([cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n    var cardTail = editor.post.sections.head.tailPosition();\n\n    // Before zwnj\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 0);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    var _editor4 = editor;\n    var range = _editor4.range;\n\n    assert.positionIsEqual(range.head, cardTail);\n    assert.positionIsEqual(range.tail, cardTail);\n\n    // After zwnj\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 1);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, cardTail);\n    assert.positionIsEqual(range.tail, cardTail);\n  });\n\n  test('right arrow at end of card moves cursor to next section', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var cardSection = _ref5.cardSection;\n\n      return post([cardSection('my-card'), markupSection('p')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n    var sectionHead = editor.post.sections.tail.headPosition();\n\n    // Before zwnj\n    var sectionElement = editor.post.sections.head.renderNode.element;\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.lastChild, 0);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    var _editor5 = editor;\n    var range = _editor5.range;\n\n    assert.positionIsEqual(range.head, sectionHead);\n    assert.positionIsEqual(range.tail, sectionHead);\n\n    // After zwnj\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.lastChild, 1);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    range = editor.range;\n\n    // On wrapper\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild, 2);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, sectionHead);\n    assert.positionIsEqual(range.tail, sectionHead);\n  });\n\n  test('right arrow at end of card moves cursor to next list item', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref6) {\n      var post = _ref6.post;\n      var listSection = _ref6.listSection;\n      var listItem = _ref6.listItem;\n      var marker = _ref6.marker;\n      var cardSection = _ref6.cardSection;\n\n      return post([cardSection('my-card'), listSection('ul', [listItem([marker('abc')])])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n    var itemHead = editor.post.sections.tail.items.head.headPosition();\n\n    // Before zwnj\n    var sectionElement = editor.post.sections.head.renderNode.element;\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.lastChild, 0);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    var _editor6 = editor;\n    var range = _editor6.range;\n\n    assert.positionIsEqual(range.head, itemHead);\n    assert.positionIsEqual(range.tail, itemHead);\n\n    // After zwnj\n    _testHelpers['default'].dom.moveCursorTo(editor, sectionElement.lastChild, 1);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, itemHead);\n    assert.positionIsEqual(range.tail, itemHead);\n  });\n\n  test('left arrow when at the head of an atom moves the cursor left off the atom', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n      var atom = _ref7.atom;\n\n      return post([markupSection('p', [marker('aa'), atom('my-atom'), marker('cc')])]);\n      // TODO just make 0.3.1 default\n    }, '0.3.1');\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: atoms });\n    editor.render(editorElement);\n\n    var atomWrapper = editor.post.sections.head.markers.objectAt(1).renderNode.element;\n\n    // Before zwnj, assert moving left\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.lastChild, 0);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    var range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 2, 'Cursor is positioned at offset 2');\n\n    // After zwnj, assert moving left\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.lastChild, 1);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 2, 'Cursor is positioned at offset 2');\n\n    // On wrapper, assert moving left\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper, 3);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 2, 'Cursor is positioned at offset 2');\n\n    // After wrapper, asseat moving left\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.nextSibling, 0);\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 2, 'Cursor is positioned at offset 2');\n  });\n\n  test('right arrow when at the head of an atom moves the cursor across the atom', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n      var atom = _ref8.atom;\n\n      return post([markupSection('p', [marker('aa'), atom('my-atom'), marker('cc')])]);\n      // TODO just make 0.3.1 default\n    }, '0.3.1');\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: atoms });\n    editor.render(editorElement);\n\n    var atomWrapper = editor.post.sections.head.markers.objectAt(1).renderNode.element;\n\n    // Before zwnj, assert moving right\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.firstChild, 0);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    var range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 3, 'Cursor is positioned at offset 3');\n\n    // After zwnj, assert moving right\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.firstChild, 1);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 3, 'Cursor is positioned at offset 3');\n\n    // On wrapper, assert moving right\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper, 1);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 3, 'Cursor is positioned at offset 3');\n\n    // After wrapper, assert moving right\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.previousSibling, 2);\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    range = editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 3, 'Cursor is positioned at offset 3');\n  });\n\n  test('left/right arrows moves cursor l-to-r and r-to-l across atom', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n      var atom = _ref9.atom;\n\n      return post([markupSection('p', [atom('my-atom', 'first')])]);\n    }, editorOptions);\n\n    editor.selectRange(editor.post.tailPosition());\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    assert.positionIsEqual(editor.range.head, editor.post.headPosition());\n    assert.positionIsEqual(editor.range.tail, editor.post.headPosition());\n\n    editor.selectRange(editor.post.headPosition());\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    assert.positionIsEqual(editor.range.head, editor.post.tailPosition());\n    assert.positionIsEqual(editor.range.tail, editor.post.tailPosition());\n  });\n\n  test('left arrow at start atom moves to end of prev section', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n      var atom = _ref10.atom;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [atom('my-atom', 'first')])]);\n    }, editorOptions);\n\n    editor.selectRange(editor.post.sections.tail.headPosition());\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n    assert.positionIsEqual(editor.range.head, editor.post.sections.head.tailPosition());\n  });\n\n  test('right arrow at end of end atom moves to start of next section', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n      var atom = _ref11.atom;\n\n      return post([markupSection('p', [atom('my-atom', 'first')]), markupSection('p', [marker('abc')])]);\n    }, editorOptions);\n\n    editor.selectRange(editor.post.sections.head.tailPosition());\n    _testHelpers['default'].dom.triggerRightArrowKey(editor);\n    assert.positionIsEqual(editor.range.head, editor.post.sections.tail.headPosition());\n  });\n\n  _module('Acceptance: Cursor Movement w/ shift', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  if ((0, _helpersBrowsers.supportsSelectionExtend)()) {\n    // FIXME: Older versions of IE do not support `extends` on selection\n    // objects, and thus cannot support highlighting left until we implement\n    // selections without native APIs.\n    test('left arrow when at the end of a card moves the selection across the card', function (assert) {\n      var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref12) {\n        var post = _ref12.post;\n        var cardSection = _ref12.cardSection;\n\n        return post([cardSection('my-card')]);\n      });\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n      editor.render(editorElement);\n\n      var cardHead = editor.post.sections.head.headPosition();\n      var cardTail = editor.post.sections.head.tailPosition();\n\n      // Before zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 0);\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      var _editor7 = editor;\n      var range = _editor7.range;\n\n      assert.positionIsEqual(range.head, cardHead);\n      assert.positionIsEqual(range.tail, cardTail);\n\n      // After zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 1);\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, cardHead);\n      assert.positionIsEqual(range.tail, cardTail);\n\n      // On wrapper\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild, 2);\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, cardHead);\n      assert.positionIsEqual(range.tail, cardTail);\n    });\n\n    test('left arrow at start of card moves selection to prev section', function (assert) {\n      var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref13) {\n        var post = _ref13.post;\n        var markupSection = _ref13.markupSection;\n        var marker = _ref13.marker;\n        var cardSection = _ref13.cardSection;\n\n        return post([markupSection('p', [marker('abc')]), cardSection('my-card')]);\n      });\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n      editor.render(editorElement);\n\n      var cardHead = editor.post.sections.tail.headPosition();\n      var sectionTail = editor.post.sections.head.tailPosition();\n\n      // Before zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.lastChild.firstChild, 0);\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      var _editor8 = editor;\n      var range = _editor8.range;\n\n      assert.positionIsEqual(range.head, sectionTail);\n      assert.positionIsEqual(range.tail, cardHead);\n\n      // After zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.lastChild.firstChild, 1);\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, sectionTail);\n      assert.positionIsEqual(range.tail, cardHead);\n    });\n\n    test('left arrow at start of card moves selection to prev list item', function (assert) {\n      var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref14) {\n        var post = _ref14.post;\n        var listSection = _ref14.listSection;\n        var listItem = _ref14.listItem;\n        var marker = _ref14.marker;\n        var cardSection = _ref14.cardSection;\n\n        return post([listSection('ul', [listItem([marker('abc')])]), cardSection('my-card')]);\n      });\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n      editor.render(editorElement);\n\n      var cardHead = editor.post.sections.tail.headPosition();\n      var sectionTail = editor.post.sections.head.items.head.tailPosition();\n\n      // Before zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.lastChild.firstChild, 0);\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      var _editor9 = editor;\n      var range = _editor9.range;\n\n      assert.positionIsEqual(range.head, sectionTail);\n      assert.positionIsEqual(range.tail, cardHead);\n\n      // After zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.lastChild.firstChild, 1);\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, sectionTail);\n      assert.positionIsEqual(range.tail, cardHead);\n    });\n\n    test('right arrow at start of card moves the cursor across the card', function (assert) {\n      var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref15) {\n        var post = _ref15.post;\n        var cardSection = _ref15.cardSection;\n\n        return post([cardSection('my-card')]);\n      });\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n      editor.render(editorElement);\n\n      var cardHead = editor.post.sections.head.headPosition();\n      var cardTail = editor.post.sections.head.tailPosition();\n\n      // Before zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 0);\n      _testHelpers['default'].dom.triggerRightArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      var _editor10 = editor;\n      var range = _editor10.range;\n\n      assert.positionIsEqual(range.head, cardHead);\n      assert.positionIsEqual(range.tail, cardTail);\n\n      // After zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 1);\n      _testHelpers['default'].dom.triggerRightArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, cardHead);\n      assert.positionIsEqual(range.tail, cardTail);\n    });\n\n    test('right arrow at end of card moves to next section', function (assert) {\n      var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref16) {\n        var post = _ref16.post;\n        var markupSection = _ref16.markupSection;\n        var marker = _ref16.marker;\n        var cardSection = _ref16.cardSection;\n\n        return post([cardSection('my-card'), markupSection('p', [marker('abc')])]);\n      });\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n      editor.render(editorElement);\n\n      var cardTail = editor.post.sections.head.tailPosition();\n      var sectionHead = editor.post.sections.tail.headPosition();\n\n      // Before zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 0);\n      _testHelpers['default'].dom.triggerRightArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      var _editor11 = editor;\n      var range = _editor11.range;\n\n      assert.positionIsEqual(range.head, cardTail);\n      assert.positionIsEqual(range.tail, sectionHead);\n\n      // After zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 1);\n      _testHelpers['default'].dom.triggerRightArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, cardTail);\n      assert.positionIsEqual(range.tail, sectionHead);\n    });\n\n    test('right arrow at end of card moves to next list item', function (assert) {\n      var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref17) {\n        var post = _ref17.post;\n        var listSection = _ref17.listSection;\n        var listItem = _ref17.listItem;\n        var marker = _ref17.marker;\n        var cardSection = _ref17.cardSection;\n\n        return post([cardSection('my-card'), listSection('ul', [listItem([marker('abc')])])]);\n      });\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n      editor.render(editorElement);\n\n      var cardTail = editor.post.sections.head.tailPosition();\n      var itemHead = editor.post.sections.tail.items.head.headPosition();\n\n      // Before zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 0);\n      _testHelpers['default'].dom.triggerRightArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      var _editor12 = editor;\n      var range = _editor12.range;\n\n      assert.positionIsEqual(range.head, cardTail);\n      assert.positionIsEqual(range.tail, itemHead);\n\n      // After zwnj\n      _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 1);\n      _testHelpers['default'].dom.triggerRightArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, cardTail);\n      assert.positionIsEqual(range.tail, itemHead);\n    });\n\n    test('left/right arrows move selection l-to-r and r-to-l across atom', function (assert) {\n      editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref18) {\n        var post = _ref18.post;\n        var markupSection = _ref18.markupSection;\n        var marker = _ref18.marker;\n        var atom = _ref18.atom;\n\n        return post([markupSection('p', [atom('my-atom', 'first')])]);\n      }, editorOptions);\n\n      editor.selectRange(editor.post.tailPosition());\n      _testHelpers['default'].dom.triggerLeftArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      assert.positionIsEqual(editor.range.head, editor.post.headPosition());\n      assert.positionIsEqual(editor.range.tail, editor.post.tailPosition());\n\n      editor.selectRange(editor.post.headPosition());\n      _testHelpers['default'].dom.triggerRightArrowKey(editor, _mobiledocKitUtilsKey.MODIFIERS.SHIFT);\n      assert.positionIsEqual(editor.range.head, editor.post.headPosition());\n      assert.positionIsEqual(editor.range.tail, editor.post.tailPosition());\n    });\n  }\n});","define('tests/acceptance/cursor-position-test', ['exports', 'mobiledoc-kit', '../test-helpers'], function (exports, _mobiledocKit, _testHelpers) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var cards = [{\n    name: 'my-card',\n    type: 'dom',\n    render: function render() {},\n    edit: function edit() {}\n  }];\n\n  var atoms = [{\n    name: 'my-atom',\n    type: 'dom',\n    render: function render() {\n      return document.createTextNode('my-atom');\n    }\n  }];\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  _module('Acceptance: Cursor Position', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('cursor in a markup section reports its position correctly', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 1);\n    var _editor = editor;\n    var range = _editor.range;\n\n    assert.ok(range.head.section === editor.post.sections.head, 'Cursor is positioned on first section');\n    assert.equal(range.head.offset, 1, 'Cursor is positioned at offset 1');\n  });\n\n  test('cursor blank section reports its position correctly', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n\n      return post([markupSection('p')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 0);\n    var _editor2 = editor;\n    var range = _editor2.range;\n\n    assert.positionIsEqual(range.head, editor.post.sections.head.headPosition());\n  });\n\n  test('cursor moved left from section after card is reported as on the card with offset 1', function (assert) {\n    // Cannot actually move a cursor, so just emulate what things looks like after\n    // the arrow key is pressed\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var cardSection = _ref3.cardSection;\n\n      return post([cardSection('my-card'), markupSection('p')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 1);\n    var _editor3 = editor;\n    var range = _editor3.range;\n\n    assert.positionIsEqual(range.head, editor.post.sections.head.toPosition(1));\n  });\n\n  test('cursor moved up from end of section after card is reported as on the card with offset 1', function (assert) {\n    // Cannot actually move a cursor, so just emulate what things looks like after\n    // the arrow key is pressed\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var cardSection = _ref4.cardSection;\n\n      return post([cardSection('my-card'), markupSection('p')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.lastChild, 0);\n    var _editor4 = editor;\n    var range = _editor4.range;\n\n    assert.positionIsEqual(range.head, editor.post.sections.head.tailPosition());\n  });\n\n  test('cursor moved right from end of section before card is reported as on the card with offset 0', function (assert) {\n    // Cannot actually move a cursor, so just emulate what things looks like after\n    // the arrow key is pressed\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var cardSection = _ref5.cardSection;\n\n      return post([markupSection('p'), cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.lastChild.firstChild, 0);\n    var _editor5 = editor;\n    var range = _editor5.range;\n\n    assert.positionIsEqual(range.head, editor.post.sections.tail.headPosition());\n  });\n\n  test('cursor moved right from end of section before card is reported as on the card with offset 0', function (assert) {\n    // Cannot actually move a cursor, so just emulate what things looks like after\n    // the arrow key is pressed\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var cardSection = _ref6.cardSection;\n\n      return post([markupSection('p'), cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.lastChild.firstChild, 1);\n    var _editor6 = editor;\n    var range = _editor6.range;\n\n    assert.positionIsEqual(range.head, editor.post.sections.tail.headPosition());\n  });\n\n  test('cursor focused on card wrapper with 2 offset', function (assert) {\n    // Cannot actually move a cursor, so just emulate what things looks like after\n    // the arrow key is pressed\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var cardSection = _ref7.cardSection;\n\n      return post([markupSection('p'), cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    // We need to create a selection starting from the markup section's node\n    // in order for the tail to end up focused on a div instead of a text node\n    // This only happens in Firefox\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 0, editorElement.lastChild, 2);\n\n    var _editor7 = editor;\n    var range = _editor7.range;\n\n    assert.positionIsEqual(range.tail, editor.post.sections.tail.tailPosition());\n  });\n\n  // This can happen when using arrow+shift keys to select left across a card\n  test('cursor focused on card wrapper with 0 offset', function (assert) {\n    // Cannot actually move a cursor, so just emulate what things looks like after\n    // the arrow key is pressed\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var cardSection = _ref8.cardSection;\n\n      return post([markupSection('p'), cardSection('my-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    // We need to create a selection starting from the markup section's node\n    // in order for the tail to end up focused on a div instead of a text node\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.firstChild.firstChild, 0, editorElement.lastChild, 0);\n    var _editor8 = editor;\n    var range = _editor8.range;\n\n    assert.positionIsEqual(range.tail, editor.post.sections.tail.headPosition());\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/215\n  test('selecting the entire editor element reports a selection range of the entire post', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('1234')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement, 0, editorElement, editorElement.childNodes.length);\n    var _editor9 = editor;\n    var range = _editor9.range;\n\n    assert.positionIsEqual(range.head, editor.post.sections.head.headPosition());\n    assert.positionIsEqual(range.tail, editor.post.sections.tail.tailPosition());\n  });\n\n  test('when at the head of an atom', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n      var atom = _ref10.atom;\n\n      return post([markupSection('p', [marker('aa'), atom('my-atom'), marker('cc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: atoms });\n    editor.render(editorElement);\n\n    var atomWrapper = editor.post.sections.head.markers.objectAt(1).renderNode.element;\n\n    // Before zwnj\n    //\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.firstChild, 0);\n    var range = editor.range;\n\n    var positionBeforeAtom = editor.post.sections.head.toPosition('aa'.length);\n\n    assert.positionIsEqual(range.head, positionBeforeAtom);\n\n    // After zwnj\n    //\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.firstChild, 1);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, positionBeforeAtom);\n\n    // On wrapper\n    //\n    [0, 1].forEach(function (index) {\n      _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper, index);\n      range = editor.range;\n\n      assert.positionIsEqual(range.head, positionBeforeAtom);\n    });\n\n    // text node before wrapper\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.previousSibling, 2);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, positionBeforeAtom);\n  });\n\n  test('when at the tail of an atom', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n      var atom = _ref11.atom;\n\n      return post([markupSection('p', [marker('aa'), atom('my-atom'), marker('cc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: atoms });\n    editor.render(editorElement);\n\n    var atomWrapper = editor.post.sections.head.markers.objectAt(1).renderNode.element;\n    var positionAfterAtom = editor.post.sections.head.toPosition('aa'.length + 1);\n\n    // Before zwnj\n    //\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.lastChild, 0);\n    var range = editor.range;\n\n    assert.positionIsEqual(range.head, positionAfterAtom);\n\n    // After zwnj\n    //\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.lastChild, 1);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, positionAfterAtom);\n\n    // On wrapper\n    //\n    [2, 3].forEach(function (index) {\n      _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper, index);\n      range = editor.range;\n      assert.positionIsEqual(range.head, positionAfterAtom);\n    });\n\n    // After wrapper\n    //\n    _testHelpers['default'].dom.moveCursorTo(editor, atomWrapper.nextSibling, 0);\n    range = editor.range;\n\n    assert.positionIsEqual(range.head, positionAfterAtom);\n  });\n});","define('tests/acceptance/editor-atoms-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/renderers/mobiledoc/0-3-1', 'mobiledoc-kit/utils/cursor/range'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitRenderersMobiledoc031, _mobiledocKitUtilsCursorRange) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var simpleAtom = {\n    name: 'simple-atom',\n    type: 'dom',\n    render: function render(_ref) {\n      var value = _ref.value;\n\n      var element = document.createElement('span');\n      element.setAttribute('id', 'simple-atom');\n      element.appendChild(document.createTextNode(value));\n      return element;\n    }\n  };\n\n  var editor = undefined,\n      editorElement = undefined;\n  var mobiledocWithAtom = {\n    version: _mobiledocKitRenderersMobiledoc031.MOBILEDOC_VERSION,\n    atoms: [['simple-atom', 'Bob']],\n    cards: [],\n    markups: [],\n    sections: [[1, \"P\", [[0, [], 0, \"text before atom\"], [1, [], 0, 0], [0, [], 0, \"text after atom\"]]]]\n  };\n  var editorOptions = { atoms: [simpleAtom] };\n\n  _module('Acceptance: Atoms', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('keystroke of character before starting atom inserts character', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref2) {\n      var post = _ref2.post;\n      var atom = _ref2.atom;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      expected = post([markupSection('p', [marker('A'), atom('simple-atom', 'first')])]);\n      return post([markupSection('p', [atom('simple-atom', 'first')])]);\n    }, editorOptions);\n\n    editor.selectRange(editor.post.headPosition());\n    _testHelpers['default'].dom.insertText(editor, 'A');\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('keystroke of character before mid-text atom inserts character', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref3) {\n      var post = _ref3.post;\n      var atom = _ref3.atom;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      expected = post([markupSection('p', [marker('ABC'), atom('simple-atom', 'first')])]);\n      return post([markupSection('p', [marker('AB'), atom('simple-atom', 'first')])]);\n    }, editorOptions);\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(editor.post.sections.head, 'AB'.length));\n    _testHelpers['default'].dom.insertText(editor, 'C');\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('keystroke of character after mid-text atom inserts character', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref4) {\n      var post = _ref4.post;\n      var atom = _ref4.atom;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      expected = post([markupSection('p', [atom('simple-atom', 'first'), marker('ABC')])]);\n      return post([markupSection('p', [atom('simple-atom', 'first'), marker('BC')])]);\n    }, editorOptions);\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(editor.post.sections.head, 1));\n    _testHelpers['default'].dom.insertText(editor, 'A');\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('keystroke of character after end-text atom inserts character', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref5) {\n      var post = _ref5.post;\n      var atom = _ref5.atom;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n\n      expected = post([markupSection('p', [atom('simple-atom', 'first'), marker('A')])]);\n      return post([markupSection('p', [atom('simple-atom', 'first')])]);\n    }, editorOptions);\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(editor.post.sections.head, 1));\n    _testHelpers['default'].dom.insertText(editor, 'A');\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('keystroke of delete removes character after atom', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledocWithAtom, atoms: [simpleAtom] });\n    editor.render(editorElement);\n\n    var pNode = $('#editor p')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, pNode.lastChild, 1);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.postIsSimilar(editor.post, _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var atom = _ref6.atom;\n      var marker = _ref6.marker;\n\n      return post([markupSection('p', [marker('text before atom'), atom('simple-atom', 'Bob'), marker('ext after atom')])]);\n    }));\n  });\n\n  test('keystroke of delete removes atom', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledocWithAtom, atoms: [simpleAtom] });\n    editor.render(editorElement);\n\n    var pNode = $('#editor p')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, pNode.lastChild, 0);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.postIsSimilar(editor.post, _testHelpers['default'].postAbstract.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var atom = _ref7.atom;\n      var marker = _ref7.marker;\n\n      return post([markupSection('p', [marker('text before atomtext after atom')])]);\n    }));\n  });\n\n  test('keystroke of forward delete removes atom', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledocWithAtom, atoms: [simpleAtom] });\n    editor.render(editorElement);\n\n    var pNode = $('#editor p')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, pNode.firstChild, 16);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.postIsSimilar(editor.post, _testHelpers['default'].postAbstract.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var atom = _ref8.atom;\n      var marker = _ref8.marker;\n\n      return post([markupSection('p', [marker('text before atomtext after atom')])]);\n    }));\n  });\n\n  test('keystroke of enter in section with atom creates new section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledocWithAtom, atoms: [simpleAtom] });\n    editor.render(editorElement);\n\n    var pNode = $('#editor p')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, pNode.lastChild, 1);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.postIsSimilar(editor.post, _testHelpers['default'].postAbstract.build(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var atom = _ref9.atom;\n      var marker = _ref9.marker;\n\n      return post([markupSection('p', [marker('text before atom'), atom('simple-atom', 'Bob'), marker('t')]), markupSection('p', [marker('ext after atom')])]);\n    }));\n  });\n\n  test('keystroke of enter after atom and before marker creates new section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledocWithAtom, atoms: [simpleAtom] });\n    editor.render(editorElement);\n\n    var pNode = $('#editor p')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, pNode.lastChild, 0);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.postIsSimilar(editor.post, _testHelpers['default'].postAbstract.build(function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var atom = _ref10.atom;\n      var marker = _ref10.marker;\n\n      return post([markupSection('p', [marker('text before atom'), atom('simple-atom', 'Bob')]), markupSection('p', [marker('text after atom')])]);\n    }));\n  });\n\n  test('keystroke of enter before atom and after marker creates new section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledocWithAtom, atoms: [simpleAtom] });\n    editor.render(editorElement);\n\n    var pNode = $('#editor p')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, pNode.firstChild, 16);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.postIsSimilar(editor.post, _testHelpers['default'].postAbstract.build(function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var atom = _ref11.atom;\n      var marker = _ref11.marker;\n\n      return post([markupSection('p', [marker('text before atom')]), markupSection('p', [atom('simple-atom', 'Bob'), marker('text after atom')])]);\n    }));\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/313\n  test('keystroke of enter at markup section head before atom creates new section', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref12) {\n      var post = _ref12.post;\n      var markupSection = _ref12.markupSection;\n      var atom = _ref12.atom;\n\n      expected = post([markupSection('p'), markupSection('p', [atom('simple-atom')])]);\n      return post([markupSection('p', [atom('simple-atom')])]);\n    }, editorOptions);\n\n    editor.run(function (postEditor) {\n      postEditor.setRange(editor.post.headPosition());\n    });\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor.range.head, editor.post.sections.tail.headPosition());\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/313\n  test('keystroke of enter at list item head before atom creates new section', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref13) {\n      var post = _ref13.post;\n      var listSection = _ref13.listSection;\n      var listItem = _ref13.listItem;\n      var atom = _ref13.atom;\n      var marker = _ref13.marker;\n\n      var blankMarker = marker();\n      expected = post([listSection('ul', [listItem([blankMarker]), listItem([atom('simple-atom', 'X')])])]);\n      return post([listSection('ul', [listItem([atom('simple-atom', 'X')])])]);\n    }, editorOptions);\n\n    editor.run(function (postEditor) {\n      postEditor.setRange(editor.post.headPosition());\n    });\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.postIsSimilar(editor.post, expected);\n    // FIXME the render tree does not have the blank marker render node\n    // because ListItem#isBlank is true, so it simply renders a cursor-positioning\n    // `<br>` tag instead of an empy marker, so the following render tree check\n    // is not accurate:\n    // assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor.range.head, editor.post.sections.head.items.tail.headPosition());\n  });\n\n  test('marking atom with markup adds markup', function (assert) {\n    assert.expect(1);\n    var done = assert.async();\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledocWithAtom, atoms: [simpleAtom] });\n    editor.render(editorElement);\n\n    var pNode = $('#editor p')[0];\n    _testHelpers['default'].dom.selectRange(pNode.firstChild, 16, pNode.lastChild, 0);\n\n    _testHelpers['default'].wait(function () {\n      editor.run(function (postEditor) {\n        var markup = editor.builder.createMarkup('strong');\n        postEditor.addMarkupToRange(editor.range, markup);\n      });\n\n      assert.postIsSimilar(editor.post, _testHelpers['default'].postAbstract.build(function (_ref14) {\n        var post = _ref14.post;\n        var markupSection = _ref14.markupSection;\n        var atom = _ref14.atom;\n        var marker = _ref14.marker;\n        var markup = _ref14.markup;\n\n        return post([markupSection('p', [marker('text before atom'), atom('simple-atom', 'Bob', {}, [markup('strong')]), marker('text after atom')])]);\n      }));\n\n      done();\n    });\n  });\n\n  test('typing between two atoms inserts character', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref15) {\n      var post = _ref15.post;\n      var markupSection = _ref15.markupSection;\n      var atom = _ref15.atom;\n      var marker = _ref15.marker;\n\n      expected = post([markupSection('p', [atom('simple-atom', 'first'), marker('A'), atom('simple-atom', 'last')])]);\n      return post([markupSection('p', [atom('simple-atom', 'first'), atom('simple-atom', 'last')])]);\n    }, editorOptions);\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(editor.post.sections.head, 1));\n\n    _testHelpers['default'].dom.insertText(editor, 'A');\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('delete selected text including atom deletes atom', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref16) {\n      var post = _ref16.post;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n      var atom = _ref16.atom;\n\n      expected = post([markupSection('p', [marker('abc')])]);\n      return post([markupSection('p', [marker('ab'), atom('simple-atom', 'deleteme'), marker('c')])]);\n    }, editorOptions);\n\n    var section = editor.post.sections.head;\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(section, 'ab'.length, section, 'ab'.length + 1));\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n  });\n\n  test('delete selected text that ends between atoms deletes first atom', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var marker = _ref17.marker;\n      var atom = _ref17.atom;\n\n      expected = post([markupSection('p', [marker('abd'), atom('simple-atom', 'keepme')])]);\n      return post([markupSection('p', [marker('ab'), atom('simple-atom', 'deleteme'), marker('cd'), atom('simple-atom', 'keepme')])]);\n    }, editorOptions);\n\n    var section = editor.post.sections.head;\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(section, 'ab'.length, section, 'ab'.length + 1 + 'c'.length));\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n  });\n});","define('tests/acceptance/editor-cards-test', ['exports', 'mobiledoc-kit/utils/key', '../test-helpers', 'mobiledoc-kit/models/card'], function (exports, _mobiledocKitUtilsKey, _testHelpers, _mobiledocKitModelsCard) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n  var buildFromText = _testHelpers['default'].editor.buildFromText;\n\n  var editor = undefined,\n      editorElement = undefined;\n  var editorOpts = undefined;\n  var cardText = 'card text';\n\n  var cards = [{\n    name: 'simple',\n    type: 'dom',\n    render: function render(_ref) {\n      var env = _ref.env;\n\n      var element = document.createElement('div');\n\n      var button = document.createElement('button');\n      button.setAttribute('id', 'display-button');\n      element.appendChild(button);\n      element.appendChild(document.createTextNode(cardText));\n      button.onclick = env.edit;\n\n      return element;\n    },\n    edit: function edit(_ref2) {\n      var env = _ref2.env;\n\n      var button = document.createElement('button');\n      button.setAttribute('id', 'edit-button');\n      button.onclick = env.save;\n      return button;\n    }\n  }, {\n    name: 'input',\n    type: 'dom',\n    render: function render() {\n      return $('<input id=\"simple-card-input\">')[0];\n    }\n  }, {\n    name: 'position',\n    type: 'dom',\n    render: function render() {\n      return $('<div id=\"my-simple-card\"></div>')[0];\n    }\n  }];\n\n  _module('Acceptance: editor: cards', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n      editorOpts = { element: editorElement, cards: cards };\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('changing to display state triggers update on editor', function (assert) {\n    editor = buildFromText(['[simple]'], editorOpts);\n\n    var updateCount = 0,\n        triggeredUpdate = function triggeredUpdate() {\n      return updateCount++;\n    };\n    editor.postDidChange(triggeredUpdate);\n\n    var displayButton = document.getElementById('display-button');\n    assert.ok(!!displayButton, 'precond - display button is there');\n\n    _testHelpers['default'].dom.triggerEvent(displayButton, 'click');\n\n    var editButton = document.getElementById('edit-button');\n    assert.ok(!!editButton, 'precond - edit button is there after clicking the display button');\n\n    var currentUpdateCount = updateCount;\n\n    _testHelpers['default'].dom.triggerEvent(editButton, 'click');\n\n    assert.equal(updateCount, currentUpdateCount + 1, 'update is triggered after switching to display mode');\n  });\n\n  test('editor listeners are quieted for card actions', function (assert) {\n    var done = assert.async();\n\n    editor = buildFromText(['[simple]'], editorOpts);\n\n    _testHelpers['default'].dom.selectText(editor, cardText, editorElement);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    _testHelpers['default'].wait(function () {\n      // FIXME should have a better assertion here\n      assert.ok(true, 'made it here with no javascript errors');\n      done();\n    });\n  });\n\n  test('removing last card from mobiledoc allows additional editing', function (assert) {\n    var done = assert.async();\n    var button = undefined;\n    var cards = [{\n      name: 'removable',\n      type: 'dom',\n      render: function render(_ref3) {\n        var env = _ref3.env;\n\n        button = $('<button id=\"removable-button\">Click me</button>');\n        button.on('click', env.remove);\n        return button[0];\n      }\n    }];\n    editor = buildFromText(['[removable]'], { element: editorElement, cards: cards });\n\n    assert.hasElement('#editor button:contains(Click me)', 'precond - button');\n\n    button.click();\n\n    _testHelpers['default'].wait(function () {\n      assert.hasNoElement('#editor button:contains(Click me)', 'button is removed');\n      assert.hasNoElement('#editor p');\n      _testHelpers['default'].dom.moveCursorTo(editor, $('#editor')[0]);\n      _testHelpers['default'].dom.insertText(editor, 'X');\n      assert.hasElement('#editor p:contains(X)');\n\n      done();\n    });\n  });\n\n  test('delete when cursor is positioned at end of a card deletes card, replace with empty markup section', function (assert) {\n    editor = buildFromText(['[position]|'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasNoElement('#editor p', 'precond - has no markup section');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasNoElement('#my-simple-card', 'removes card after delete');\n    assert.hasElement('#editor p', 'has markup section after delete');\n  });\n\n  test('delete when cursor is at start of a card and prev section is blank deletes prev section', function (assert) {\n    editor = buildFromText(['', '|[position]'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasElement('#editor p', 'precond - has blank markup section');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#my-simple-card', 'card still exists after delete');\n    assert.hasNoElement('#editor p', 'blank markup section deleted');\n  });\n\n  test('forward-delete when cursor is positioned at start of a card deletes card, replace with empty markup section', function (assert) {\n    editor = buildFromText(['|[position]'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasNoElement('#editor p', 'precond - has no markup section');\n\n    _testHelpers['default'].dom.triggerDelete(editor, _mobiledocKitUtilsKey.DIRECTION.FORWARD);\n\n    assert.hasNoElement('#my-simple-card', 'removes card after delete');\n    assert.hasElement('#editor p', 'has markup section after delete');\n  });\n\n  test('forward-delete when cursor is positioned at end of a card and next section is blank deletes next section', function (assert) {\n    editor = buildFromText(['[position]|', ''], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasElement('#editor p', 'precond - has blank markup section');\n\n    _testHelpers['default'].dom.triggerDelete(editor, _mobiledocKitUtilsKey.DIRECTION.FORWARD);\n\n    assert.hasElement('#my-simple-card', 'still has card after delete');\n    assert.hasNoElement('#editor p', 'deletes blank markup section');\n  });\n\n  test('selecting a card and deleting deletes the card', function (assert) {\n    editor = buildFromText(['<[position]>'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasNoElement('#editor p', 'precond - has no markup section');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasNoElement('#my-simple-card', 'has no card after delete');\n    assert.hasElement('#editor p', 'has blank markup section');\n  });\n\n  test('selecting a card and some text after and deleting deletes card and text', function (assert) {\n    editor = buildFromText(['<[position]', 'a>bc'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasElement('#editor p:contains(abc)', 'precond - has markup section');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasNoElement('#my-simple-card', 'has no card after delete');\n    assert.hasElement('p:contains(bc)', 'p with bc');\n    assert.hasNoElement('p:contains(abc)', '\"a\" is deleted');\n  });\n\n  test('deleting at start of empty markup section with prev card deletes the markup section', function (assert) {\n    editor = buildFromText(['[position]', '|'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasElement('#editor p', 'precond - has blank markup section');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#my-simple-card', 'has card after delete');\n    assert.hasNoElement('#editor p', 'paragraph is gone');\n  });\n\n  test('press enter at end of card inserts section after card', function (assert) {\n    editor = buildFromText(['[position]|'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasNoElement('#editor p', 'precond - has no markup section');\n\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.hasElement('#my-simple-card', 'has card after enter');\n    assert.hasElement('#editor p', 'markup section is added');\n  });\n\n  test('press enter at start of card inserts section before card', function (assert) {\n    editor = buildFromText(['|[position]'], editorOpts);\n\n    assert.hasElement('#my-simple-card', 'precond - renders card');\n    assert.hasNoElement('#editor p', 'precond - has no markup section');\n\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.hasElement('#my-simple-card', 'has card after enter');\n    assert.hasElement('#editor p', 'markup section is added');\n  });\n\n  test('editor ignores events when focus is inside a card', function (assert) {\n    editor = buildFromText(['', '[input]'], editorOpts);\n\n    assert.hasElement('#simple-card-input', 'precond - renders card');\n\n    var inputEvents = 0;\n    editor._eventManager.keyup = function () {\n      return inputEvents++;\n    };\n\n    var input = $('#simple-card-input')[0];\n    _testHelpers['default'].dom.triggerEvent(input, 'keyup');\n\n    assert.equal(inputEvents, 0, 'editor does not handle keyup event when in card');\n\n    var p = $('#editor p')[0];\n    _testHelpers['default'].dom.triggerEvent(p, 'keyup');\n\n    assert.equal(inputEvents, 1, 'editor handles keyup event outside of card');\n  });\n\n  test('a moved card retains its inital editing mode', function (assert) {\n    editorOpts.beforeRender = function (editor) {\n      editor.post.sections.tail.setInitialMode(_mobiledocKitModelsCard.CARD_MODES.EDIT);\n    };\n    editor = buildFromText(['', '[simple]'], editorOpts);\n\n    assert.hasElement('#edit-button', 'precond - card is in edit mode');\n\n    editor.run(function (postEditor) {\n      var card = editor.post.sections.tail;\n      postEditor.moveSectionUp(card);\n    });\n\n    assert.hasElement('#edit-button', 'card is still in edit mode');\n  });\n\n  test('a moved card retains its current editing mode', function (assert) {\n    editor = buildFromText(['', '[simple]'], editorOpts);\n\n    assert.hasNoElement('#edit-button', 'precond - card is not in edit mode');\n\n    editor.editCard(editor.post.sections.tail);\n    assert.hasElement('#edit-button', 'precond - card is in edit mode');\n\n    editor.run(function (postEditor) {\n      return postEditor.moveSectionUp(editor.post.sections.tail);\n    });\n\n    assert.hasElement('#edit-button', 'card is still in edit mode');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/475\n  test('when editing is disabled, cards can be moved and deleted', function (assert) {\n    var removeHook = undefined;\n    editorOpts.unknownCardHandler = function (_ref4) {\n      var _ref4$env = _ref4.env;\n      var name = _ref4$env.name;\n      var remove = _ref4$env.remove;\n\n      if (name === 'card-b') {\n        removeHook = remove;\n      }\n      return $('<h1>' + name + '</h1>')[0];\n    };\n    editor = buildFromText(['[card-a]', '[card-b]|'], editorOpts);\n    editor.disableEditing();\n\n    var card = editor.post.sections.tail;\n    editor.run(function (postEditor) {\n      // In order to recreate the problematic scenario, we must explicitly set the range\n      // here to the moved section's tail position\n      var movedSection = postEditor.moveSectionUp(card);\n      postEditor.setRange(movedSection.tailPosition());\n    });\n\n    assert.hasElement('h1:contains(card-a)');\n    assert.hasElement('h1:contains(card-b)');\n    var text = $(editorElement).text();\n    assert.ok(text.indexOf('card-b') < text.indexOf('card-a'), 'card b is moved up');\n\n    removeHook();\n\n    assert.hasNoElement('h1:contains(card-b)');\n  });\n});","define('tests/acceptance/editor-copy-paste-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/utils/parse-utils', 'mobiledoc-kit/utils/keycodes'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitUtilsParseUtils, _mobiledocKitUtilsKeycodes) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var cards = [{\n    name: 'my-card',\n    type: 'dom',\n    render: function render() {},\n    edit: function edit() {}\n  }];\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  _module('Acceptance: editor: copy-paste', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n      _testHelpers['default'].dom.clearCopyData();\n    }\n  });\n\n  // TODO: Modify these tests to use IE's nonstandard clipboard access pattern\n  // See: https://remysharp.com/2015/10/14/the-art-of-debugging\n  test('simple copy-paste at end of section works', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'abc', editorElement);\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var textNode = $('#editor p')[0].childNodes[0];\n    assert.equal(textNode.textContent, 'abc'); //precond\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, textNode.length);\n\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');\n  });\n\n  test('paste plain text', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var textNode = $('#editor p')[0].childNodes[0];\n    assert.equal(textNode.textContent, 'abc'); //precond\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, textNode.length);\n\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, 'abc');\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');\n  });\n\n  test('paste plain text with line breaks', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var textNode = $('#editor p')[0].childNodes[0];\n    assert.equal(textNode.textContent, 'abc'); //precond\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, textNode.length);\n\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, ['abc', 'def'].join('\\n'));\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');\n    assert.hasElement('#editor p:contains(def)', 'second section is pasted');\n    assert.equal($('#editor p').length, 2, 'adds a second section');\n  });\n\n  test('paste plain text with list items', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var textNode = $('#editor p')[0].childNodes[0];\n    assert.equal(textNode.textContent, 'abc'); //precond\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, textNode.length);\n\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, ['* abc', '* def'].join('\\n'));\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');\n    assert.hasElement('#editor ul li:contains(def)', 'list item is pasted');\n  });\n\n  test('paste plain text into an empty Mobiledoc', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref5) {\n      var post = _ref5.post;\n\n      return post();\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, 'abc');\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(abc)', 'pastes the text');\n  });\n\n  test('can cut and then paste content', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor p:contains(abc)', 'precond - has p');\n\n    _testHelpers['default'].dom.selectText(editor, 'abc', editorElement);\n    _testHelpers['default'].dom.triggerCutEvent(editor);\n\n    assert.hasNoElement('#editor p:contains(abc)', 'content removed after cutting');\n\n    var textNode = $('#editor p')[0].childNodes[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, textNode.length);\n\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(abc)', 'pastes the text');\n  });\n\n  test('paste when text is selected replaces that text', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor p:contains(abc)', 'precond - has p');\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement);\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    _testHelpers['default'].dom.selectText(editor, 'a', editorElement);\n\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(bcbc)', 'pastes, replacing the selection');\n  });\n\n  test('simple copy-paste with markup at end of section works', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n      var markup = _ref8.markup;\n\n      return post([markupSection('p', [marker('a', [markup('strong')]), marker('bc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'a', editorElement, 'b', editorElement);\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var textNode = $('#editor p')[0].childNodes[1];\n    assert.equal(textNode.textContent, 'bc'); //precond\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, textNode.length);\n\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(abcab)', 'pastes the text');\n    assert.equal($('#editor p strong:contains(a)').length, 2, 'two bold As');\n  });\n\n  test('simple copy-paste in middle of section works', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      return post([markupSection('p', [marker('abcd')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'c', editorElement);\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var textNode = $('#editor p')[0].childNodes[0];\n    assert.equal(textNode.textContent, 'abcd'); //precond\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 1);\n\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(acbcd)', 'pastes the text');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor p:contains(acXbcd)', 'inserts text in right spot');\n  });\n\n  test('simple copy-paste at start of section works', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n\n      return post([markupSection('p', [marker('abcd')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'c', editorElement);\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var textNode = $('#editor p')[0].childNodes[0];\n    assert.equal(textNode.textContent, 'abcd'); //precond\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 0);\n\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor p:contains(cabcd)', 'pastes the text');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor p:contains(cXabcd)', 'inserts text in right spot');\n  });\n\n  test('copy-paste can copy cards', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n      var cardSection = _ref11.cardSection;\n\n      return post([markupSection('p', [marker('abc')]), cardSection('test-card', { foo: 'bar' }), markupSection('p', [marker('123')])]);\n    });\n    var cards = [{\n      name: 'test-card',\n      type: 'dom',\n      render: function render(_ref12) {\n        var payload = _ref12.payload;\n\n        return $('<div class=\\'' + payload.foo + '\\'>' + payload.foo + '</div>')[0];\n      }\n    }];\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor .bar', 'precond - renders card');\n\n    var startEl = $('#editor p:eq(0)')[0],\n        endEl = $('#editor p:eq(1)')[0];\n    assert.equal(endEl.textContent, '123', 'precond - endEl has correct text');\n    _testHelpers['default'].dom.selectText(editor, 'c', startEl, '1', endEl);\n\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var textNode = $('#editor p')[1].childNodes[0];\n    assert.equal(textNode.textContent, '123', 'precond - correct textNode');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 2); // '3'\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.equal($('#editor .bar').length, 2, 'renders a second card');\n  });\n\n  test('copy-paste can copy list sections', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref13) {\n      var post = _ref13.post;\n      var markupSection = _ref13.markupSection;\n      var marker = _ref13.marker;\n      var listSection = _ref13.listSection;\n      var listItem = _ref13.listItem;\n\n      return post([markupSection('p', [marker('abc')]), listSection('ul', [listItem([marker('list')])]), markupSection('p', [marker('123')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'c', editor.element, '1', editor.element);\n\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var textNode = $('#editor p')[1].childNodes[0];\n    assert.equal(textNode.textContent, '123', 'precond - correct textNode');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 3); // end of node\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.equal($('#editor ul').length, 2, 'pastes the list');\n    assert.hasElement($('#editor ul:eq(0) li:contains(list)'));\n  });\n\n  test('copy-paste can copy card following list section', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref14) {\n      var post = _ref14.post;\n      var markupSection = _ref14.markupSection;\n      var marker = _ref14.marker;\n      var listSection = _ref14.listSection;\n      var listItem = _ref14.listItem;\n      var cardSection = _ref14.cardSection;\n\n      return post([markupSection('p', [marker('abc')]), listSection('ul', [listItem([marker('list')])]), cardSection('test-card', { foo: 'bar' }), markupSection('p', [marker('123')])]);\n    });\n    var cards = [{\n      name: 'test-card',\n      type: 'dom',\n      render: function render(_ref15) {\n        var payload = _ref15.payload;\n\n        return $('<div class=\\'' + payload.foo + '\\'>' + payload.foo + '</div>')[0];\n      }\n    }];\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor .bar', 'precond - renders card');\n\n    _testHelpers['default'].dom.selectText(editor, 'c', editor.element, '3', editor.element);\n\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var textNode = $('#editor p')[1].childNodes[0];\n    assert.equal(textNode.textContent, '123', 'precond - correct textNode');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 3); // end of node\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.equal($('#editor ul').length, 2, 'pastes the list');\n    assert.hasElement('#editor ul:eq(1) li:contains(list)');\n\n    assert.equal($('#editor .bar').length, 2, 'renders a second card');\n  });\n\n  test('copy sets html & text for pasting externally', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref16) {\n      var post = _ref16.post;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n\n      return post([markupSection('h1', [marker('h1 heading')]), markupSection('h2', [marker('h2 subheader')]), markupSection('p', [marker('The text')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'heading', editor.element, 'The text', editor.element);\n\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    var html = _testHelpers['default'].dom.getCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_HTML);\n    var text = _testHelpers['default'].dom.getCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN);\n    assert.equal(text, [\"heading\", \"h2 subheader\", \"The text\"].join('\\n'), 'gets plain text');\n\n    assert.ok(html.indexOf(\"<h1>heading\") !== -1, 'html has h1');\n    assert.ok(html.indexOf(\"<h2>h2 subheader\") !== -1, 'html has h2');\n    assert.ok(html.indexOf(\"<p>The text\") !== -1, 'html has p');\n  });\n\n  test('pasting when cursor is on left/right side of card adds content before/after card', function (assert) {\n    var expected1 = undefined,\n        expected2 = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var cardSection = _ref17.cardSection;\n      var marker = _ref17.marker;\n\n      expected1 = post([markupSection('p', [marker('abc')]), cardSection('my-card')]);\n\n      expected2 = post([markupSection('p', [marker('abc')]), cardSection('my-card'), markupSection('p', [marker('123')])]);\n\n      return post([cardSection('my-card')]);\n    }, { cards: cards });\n\n    var card = editor.post.sections.objectAt(0);\n    assert.ok(card.isCardSection, 'precond - get card');\n\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, 'abc');\n    editor.selectRange(card.headPosition());\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.postIsSimilar(editor.post, expected1, 'content pasted before card');\n\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, '123');\n    editor.selectRange(card.tailPosition());\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.postIsSimilar(editor.post, expected2, 'content pasted after card');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/249\n  test('pasting when replacing a list item works', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref18) {\n      var post = _ref18.post;\n      var listSection = _ref18.listSection;\n      var listItem = _ref18.listItem;\n      var markupSection = _ref18.markupSection;\n      var marker = _ref18.marker;\n\n      return post([markupSection('p', [marker('X')]), listSection('ul', [listItem([marker('Y')])])]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor li:contains(Y)', 'precond: has li with Y');\n\n    _testHelpers['default'].dom.selectText(editor, 'X', editorElement);\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n\n    _testHelpers['default'].dom.selectText(editor, 'Y', editorElement);\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.hasElement('#editor li:contains(X)', 'replaces Y with X in li');\n    assert.hasNoElement('#editor li:contains(Y)', 'li with Y is gone');\n  });\n\n  test('paste with shift key pastes plain text', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref19) {\n      var post = _ref19.post;\n      var markupSection = _ref19.markupSection;\n      var marker = _ref19.marker;\n      var markup = _ref19.markup;\n\n      expected = post([markupSection('p', [marker('a'), marker('b', [markup('b')]), marker('cabc')])]);\n      return post([markupSection('p', [marker('a'), marker('b', [markup('b')]), marker('c')])]);\n    });\n\n    editor.selectRange(editor.post.toRange());\n    _testHelpers['default'].dom.triggerCopyEvent(editor);\n    editor.selectRange(editor.post.tailPosition());\n\n    _testHelpers['default'].dom.triggerKeyEvent(editor, 'keydown', { keyCode: _mobiledocKitUtilsKeycodes['default'].SHIFT });\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  test('paste with html that parses to blank doc doesn\\'t error', function (assert) {\n    var expected = undefined;\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref20) {\n      var post = _ref20.post;\n      var markupSection = _ref20.markupSection;\n      var marker = _ref20.marker;\n\n      expected = post([markupSection('p', [])]);\n\n      return post([markupSection('p', [marker('abcd')])]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.setCopyData('text/html', '<div></div>');\n    editor.selectRange(editor.post.toRange());\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n\n    assert.postIsSimilar(editor.post, expected);\n  });\n});","define('tests/acceptance/editor-disable-editing-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/utils/characters', 'mobiledoc-kit/utils/parse-utils'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitUtilsCharacters, _mobiledocKitUtilsParseUtils) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var cards = [{\n    name: 'my-card',\n    type: 'dom',\n    render: function render() {},\n    edit: function edit() {}\n  }];\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  _module('Acceptance: editor: #disableEditing', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('#disableEditing before render is meaningful', function (assert) {\n    editor = new _mobiledocKit.Editor();\n    editor.disableEditing();\n    editor.render(editorElement);\n\n    assert.equal(editorElement.getAttribute('contenteditable'), 'false', 'element is not contenteditable');\n    editor.enableEditing();\n    assert.equal(editorElement.getAttribute('contenteditable'), 'true', 'element is contenteditable');\n  });\n\n  test('when editing is disabled, the placeholder is not shown', function (assert) {\n    editor = new _mobiledocKit.Editor({ placeholder: 'the placeholder' });\n    editor.disableEditing();\n    editor.render(editorElement);\n\n    assert.isBlank(_testHelpers['default'].dom.getData(editorElement, 'placeholder'), 'no placeholder when disabled');\n    editor.enableEditing();\n    assert.equal(_testHelpers['default'].dom.getData(editorElement, 'placeholder'), 'the placeholder', 'placeholder is shown when editable');\n  });\n\n  test('#disableEditing and #enableEditing toggle contenteditable', function (assert) {\n    editor = new _mobiledocKit.Editor();\n    editor.render(editorElement);\n\n    assert.equal(editorElement.getAttribute('contenteditable'), 'true', 'element is contenteditable');\n    editor.disableEditing();\n    assert.equal(editorElement.getAttribute('contenteditable'), 'false', 'element is not contenteditable');\n    editor.enableEditing();\n    assert.equal(editorElement.getAttribute('contenteditable'), 'true', 'element is contenteditable');\n  });\n\n  // https://github.com/bustle/mobiledoc-kit/issues/572\n  test('pasting after #disableEditing does not insert text', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('abc|', { element: editorElement });\n\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, 'def');\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n    assert.hasElement('#editor:contains(abcdef)', 'precond - text is pasted');\n\n    editor.disableEditing();\n\n    _testHelpers['default'].dom.selectText(editor, 'def');\n    _testHelpers['default'].dom.setCopyData(_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, 'ghi');\n    _testHelpers['default'].dom.triggerPasteEvent(editor);\n    assert.hasNoElement('#editor:contains(ghi)', 'text is not pasted after #disableEditing');\n  });\n});","define('tests/acceptance/editor-drag-drop-test', ['exports', '../test-helpers'], function (exports, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  function findCenterPointOfTextNode(node) {\n    var range = document.createRange();\n    range.setStart(node, 0);\n    range.setEnd(node, node.textContent.length);\n\n    var _range$getBoundingClientRect = range.getBoundingClientRect();\n\n    var left = _range$getBoundingClientRect.left;\n    var top = _range$getBoundingClientRect.top;\n    var width = _range$getBoundingClientRect.width;\n    var height = _range$getBoundingClientRect.height;\n\n    var clientX = left + width / 2;\n    var clientY = top + height / 2;\n\n    return { clientX: clientX, clientY: clientY };\n  }\n\n  _module('Acceptance: editor: drag-drop', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n\n      /**\n       * `document.elementFromPoint` return `null` if the element is outside the\n       * viewport, so force the editor element to be in the viewport for this test suite\n       */\n      $(editorElement).css({\n        position: 'fixed',\n        top: '100px',\n        left: '100px'\n      });\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('inserts dropped HTML content at the drop position', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      expected = post([markupSection('h2', [marker('--->some text<---')])]);\n      return post([markupSection('h2', [marker('---><---')])]);\n    });\n\n    var html = '<p>some text</p>';\n    var node = _testHelpers['default'].dom.findTextNode(editorElement, '---><---');\n\n    var _findCenterPointOfTextNode = findCenterPointOfTextNode(node);\n\n    var clientX = _findCenterPointOfTextNode.clientX;\n    var clientY = _findCenterPointOfTextNode.clientY;\n\n    _testHelpers['default'].dom.triggerDropEvent(editor, { html: html, clientX: clientX, clientY: clientY });\n\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  test('inserts dropped text content at the drop position if no html data', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      expected = post([markupSection('h2', [marker('--->some text<---')])]);\n      return post([markupSection('h2', [marker('---><---')])]);\n    });\n\n    var text = 'some text';\n    var node = _testHelpers['default'].dom.findTextNode(editorElement, '---><---');\n\n    var _findCenterPointOfTextNode2 = findCenterPointOfTextNode(node);\n\n    var clientX = _findCenterPointOfTextNode2.clientX;\n    var clientY = _findCenterPointOfTextNode2.clientY;\n\n    _testHelpers['default'].dom.triggerDropEvent(editor, { text: text, clientX: clientX, clientY: clientY });\n\n    assert.postIsSimilar(editor.post, expected);\n  });\n});","define('tests/acceptance/editor-input-handlers-test', ['exports', '../test-helpers', 'mobiledoc-kit/utils/cursor/range', 'mobiledoc-kit/renderers/editor-dom', 'mobiledoc-kit/utils/characters', 'mobiledoc-kit/utils/key'], function (exports, _testHelpers, _mobiledocKitUtilsCursorRange, _mobiledocKitRenderersEditorDom, _mobiledocKitUtilsCharacters, _mobiledocKitUtilsKey) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n  var buildFromText = _testHelpers['default'].editor.buildFromText;\n  var DEFAULT_ATOM_NAME = _testHelpers['default'].postAbstract.DEFAULT_ATOM_NAME;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  function renderEditor() {\n    var _Helpers$mobiledoc;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    editor = (_Helpers$mobiledoc = _testHelpers['default'].mobiledoc).renderInto.apply(_Helpers$mobiledoc, [editorElement].concat(args));\n    editor.selectRange(editor.post.tailPosition());\n    return editor;\n  }\n\n  var atom = {\n    name: DEFAULT_ATOM_NAME,\n    type: 'dom',\n    render: function render() {}\n  };\n\n  _module('Acceptance: Editor: Text Input Handlers', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  var headerTests = [{\n    text: '#',\n    toInsert: ' ',\n    headerTagName: 'h1'\n  }, {\n    text: '##',\n    toInsert: ' ',\n    headerTagName: 'h2'\n  }, {\n    text: '###',\n    toInsert: ' ',\n    headerTagName: 'h3'\n  }, {\n    text: '####',\n    toInsert: ' ',\n    headerTagName: 'h4'\n  }, {\n    text: '#####',\n    toInsert: ' ',\n    headerTagName: 'h5'\n  }, {\n    text: '######',\n    toInsert: ' ',\n    headerTagName: 'h6'\n  }];\n\n  headerTests.forEach(function (_ref) {\n    var text = _ref.text;\n    var toInsert = _ref.toInsert;\n    var headerTagName = _ref.headerTagName;\n\n    test('typing \"' + text + toInsert + '\" converts to ' + headerTagName, function (assert) {\n      renderEditor(function (_ref2) {\n        var post = _ref2.post;\n        var markupSection = _ref2.markupSection;\n        var marker = _ref2.marker;\n\n        return post([markupSection('p', [marker(text)])]);\n      });\n      assert.hasElement('#editor p', 'precond - has p');\n      _testHelpers['default'].dom.insertText(editor, toInsert);\n      assert.hasNoElement('#editor p', 'p is gone');\n      assert.hasElement('#editor ' + headerTagName, 'p -> ' + headerTagName);\n\n      // Different browsers report different selections, so we grab the selection\n      // here and then set it to what we expect it to be, and compare what\n      // window.getSelection() reports.\n      // E.g., in Firefox getSelection() reports that the anchorNode is the \"br\",\n      // but Safari and Chrome report that the anchorNode is the header element\n      var selection = window.getSelection();\n\n      var cursorElement = $('#editor ' + headerTagName + ' br')[0];\n      assert.ok(cursorElement, 'has cursorElement');\n      _testHelpers['default'].dom.selectRange(cursorElement, 0, cursorElement, 0);\n\n      var newSelection = window.getSelection();\n      assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');\n      assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');\n      assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');\n      assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');\n\n      _testHelpers['default'].dom.insertText(editor, 'X');\n      assert.hasElement('#editor ' + headerTagName + ':contains(X)', 'text is inserted correctly');\n    });\n\n    test('typing \"' + text + '\" but not \"' + toInsert + '\" does not convert to ' + headerTagName, function (assert) {\n      editor = buildFromText(text, { element: editorElement });\n      assert.hasElement('#editor p', 'precond - has p');\n      _testHelpers['default'].dom.insertText(editor, 'X');\n\n      assert.hasElement('#editor p', 'still has p');\n      assert.hasNoElement('#editor ' + headerTagName, 'does not change to ' + headerTagName);\n    });\n  });\n\n  test('typing \"* \" converts to ul > li', function (assert) {\n    renderEditor(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      return post([markupSection('p', [marker('*')])]);\n    });\n\n    _testHelpers['default'].dom.insertText(editor, ' ');\n    assert.hasNoElement('#editor p', 'p is gone');\n    assert.hasElement('#editor ul > li', 'p -> \"ul > li\"');\n\n    // Store the selection so we can compare later\n    var selection = window.getSelection();\n    var cursorElement = $('#editor ul > li > br')[0];\n    assert.ok(cursorElement, 'has cursorElement for cursor position');\n    _testHelpers['default'].dom.selectRange(cursorElement, 0, cursorElement, 0);\n\n    var newSelection = window.getSelection();\n    assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');\n    assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');\n    assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');\n    assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor ul > li:contains(X)', 'text is inserted correctly');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/280\n  test('typing \"* \" at start of markup section does not remove it', function (assert) {\n    renderEditor(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      return post([markupSection('p', [marker('*abc')])]);\n    });\n\n    editor.selectRange(editor.post.sections.head.toPosition(1));\n\n    _testHelpers['default'].dom.insertText(editor, ' ');\n    assert.hasElement('#editor p:contains(* abc)', 'p is still there');\n  });\n\n  test('typing \"* \" inside of a list section does not create a new list section', function (assert) {\n    renderEditor(function (_ref5) {\n      var post = _ref5.post;\n      var listSection = _ref5.listSection;\n      var listItem = _ref5.listItem;\n      var marker = _ref5.marker;\n\n      return post([listSection('ul', [listItem([marker('*')])])]);\n    });\n    var position = editor.post.sections.head.items.head.tailPosition();\n    editor.selectRange(position);\n\n    assert.hasElement('#editor ul > li:contains(*)', 'precond - has li');\n\n    _testHelpers['default'].dom.insertText(editor, ' ');\n    // note: the actual text is \"*&nbsp;\", so only check that the \"*\" is there,\n    assert.hasElement('#editor ul > li', 'still has li');\n    var el = $('#editor ul > li')[0];\n    assert.equal(el.textContent, '*' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE);\n  });\n\n  test('typing \"1 \" converts to ol > li', function (assert) {\n    editor = buildFromText(['1|'], { element: editorElement });\n    _testHelpers['default'].dom.insertText(editor, ' ');\n    assert.hasNoElement('#editor p', 'p is gone');\n    assert.hasElement('#editor ol > li', 'p -> \"ol > li\"');\n\n    // Store the selection so we can compare later\n    var selection = window.getSelection();\n    var cursorElement = $('#editor ol > li > br')[0];\n    assert.ok(cursorElement, 'has cursorElement for cursor position');\n    _testHelpers['default'].dom.selectRange(cursorElement, 0, cursorElement, 0);\n\n    var newSelection = window.getSelection();\n    assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');\n    assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');\n    assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');\n    assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(X)', 'text is inserted correctly');\n  });\n\n  test('typing \"1. \" converts to ol > li', function (assert) {\n    editor = buildFromText('1.|', { element: editorElement });\n    _testHelpers['default'].dom.insertText(editor, ' ');\n    assert.hasNoElement('#editor p', 'p is gone');\n    assert.hasElement('#editor ol > li', 'p -> \"ol > li\"');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(X)', 'text is inserted correctly');\n  });\n\n  test('an input handler will trigger anywhere in the text', function (assert) {\n    editor = buildFromText('@abc@', { element: editorElement, atoms: [atom] });\n\n    var expandCount = 0;\n    var lastMatches = undefined;\n    editor.onTextInput({\n      name: 'at',\n      text: '@',\n      run: function run(editor, matches) {\n        expandCount++;\n        lastMatches = matches;\n      }\n    });\n\n    // at start\n    editor.selectRange(editor.post.headPosition());\n    _testHelpers['default'].dom.insertText(editor, '@');\n    assert.equal(expandCount, 1, 'expansion was run at start');\n    assert.deepEqual(lastMatches, ['@'], 'correct match at start');\n\n    // middle\n    editor.selectRange(editor.post.sections.head.toPosition('@'.length + 1 + 'ab'.length));\n    _testHelpers['default'].dom.insertText(editor, '@');\n    assert.equal(expandCount, 2, 'expansion was run at middle');\n    assert.deepEqual(lastMatches, ['@'], 'correct match at middle');\n\n    // end\n    editor.selectRange(editor.post.tailPosition());\n    _testHelpers['default'].dom.insertText(editor, '@');\n    assert.equal(expandCount, 3, 'expansion was run at end');\n    assert.deepEqual(lastMatches, ['@'], 'correct match at end');\n  });\n\n  test('an input handler can provide a `match` instead of `text`', function (assert) {\n    editor = buildFromText('@abc@', { element: editorElement, atoms: [atom] });\n\n    var expandCount = 0;\n    var lastMatches = undefined;\n    var regex = /.(.)X$/;\n    editor.onTextInput({\n      name: 'test',\n      match: regex,\n      run: function run(editor, matches) {\n        expandCount++;\n        lastMatches = matches;\n      }\n    });\n\n    // at start\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition()));\n    _testHelpers['default'].dom.insertText(editor, 'abX');\n    assert.equal(expandCount, 1, 'expansion was run at start');\n    assert.deepEqual(lastMatches, regex.exec('abX'), 'correct match at start');\n\n    // middle\n    editor.selectRange(editor.post.sections.head.toPosition('abX'.length + 1 + 'ab'.length));\n    _testHelpers['default'].dom.insertText(editor, '..X');\n    assert.equal(expandCount, 2, 'expansion was run at middle');\n    assert.deepEqual(lastMatches, regex.exec('..X'), 'correct match at middle');\n\n    // end\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n    _testHelpers['default'].dom.insertText(editor, '**X');\n    assert.equal(expandCount, 3, 'expansion was run at end');\n    assert.deepEqual(lastMatches, regex.exec('**X'), 'correct match at end');\n  });\n\n  test('an input handler can provide a `match` that matches at start and end', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText(['@abc@'], { element: editorElement, atoms: [atom] });\n\n    var expandCount = 0;\n    var lastMatches = undefined;\n    var regex = /^\\d\\d\\d$/;\n    editor.onTextInput({\n      name: 'test',\n      match: regex,\n      run: function run(editor, matches) {\n        expandCount++;\n        lastMatches = matches;\n      }\n    });\n\n    // at start\n    editor.selectRange(editor.post.headPosition());\n    _testHelpers['default'].dom.insertText(editor, '123');\n    assert.equal(expandCount, 1, 'expansion was run at start');\n    assert.deepEqual(lastMatches, regex.exec('123'), 'correct match at start');\n\n    // middle\n    editor.selectRange(editor.post.sections.head.toPosition('123'.length + 2));\n    _testHelpers['default'].dom.insertText(editor, '123');\n    assert.equal(expandCount, 1, 'expansion was not run at middle');\n\n    // end\n    editor.selectRange(editor.post.tailPosition());\n    _testHelpers['default'].dom.insertText(editor, '123');\n    assert.equal(expandCount, 1, 'expansion was not run at end');\n  });\n\n  // See https://github.com/bustle/mobiledoc-kit/issues/400\n  test('input handler can be triggered by TAB', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('abc|', { element: editorElement });\n\n    var didMatch = undefined;\n    editor.onTextInput({\n      name: 'test',\n      match: /abc\\t/,\n      run: function run() {\n        didMatch = true;\n      }\n    });\n\n    _testHelpers['default'].dom.insertText(editor, _mobiledocKitUtilsCharacters.TAB);\n\n    assert.ok(didMatch);\n  });\n\n  test('input handler can be triggered by ENTER', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('abc|', { element: editorElement });\n\n    var didMatch = undefined;\n    editor.onTextInput({\n      name: 'test',\n      match: /abc\\n/,\n      run: function run() {\n        didMatch = true;\n      }\n    });\n\n    _testHelpers['default'].dom.insertText(editor, _mobiledocKitUtilsCharacters.ENTER);\n\n    assert.ok(didMatch);\n  });\n\n  // See https://github.com/bustle/mobiledoc-kit/issues/565\n  test('typing ctrl-TAB does not insert TAB text', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('abc|', { element: editorElement });\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, _mobiledocKitUtilsCharacters.TAB, [_mobiledocKitUtilsKey.MODIFIERS.CTRL]);\n\n    assert.equal(editorElement.textContent, 'abc', 'no TAB is inserted');\n  });\n\n  test('can unregister all handlers', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('');\n    // there are 3 default helpers\n    assert.equal(editor._eventManager._textInputHandler._handlers.length, 3);\n    editor.onTextInput({\n      name: 'first',\n      match: /abc\\t/,\n      run: function run() {}\n    });\n    editor.onTextInput({\n      name: 'second',\n      match: /abc\\t/,\n      run: function run() {}\n    });\n    assert.equal(editor._eventManager._textInputHandler._handlers.length, 5);\n    editor.unregisterAllTextInputHandlers();\n    assert.equal(editor._eventManager._textInputHandler._handlers.length, 0);\n  });\n\n  test('can unregister handler by name', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('');\n    var handlerName = 'ul';\n    var handlers = editor._eventManager._textInputHandler._handlers;\n    assert.ok(handlers.filter(function (handler) {\n      return handler.name === handlerName;\n    }).length);\n    editor.unregisterTextInputHandler(handlerName);\n    assert.notOk(handlers.filter(function (handler) {\n      return handler.name === handlerName;\n    }).length);\n  });\n\n  test('can unregister handlers by duplicate name', function (assert) {\n    editor = _testHelpers['default'].editor.buildFromText('');\n    var handlerName = 'ul';\n    editor.onTextInput({\n      name: handlerName,\n      match: /abc/,\n      run: function run() {}\n    });\n    var handlers = editor._eventManager._textInputHandler._handlers;\n    assert.equal(handlers.length, 4); // 3 default + 1 custom handlers\n    editor.unregisterTextInputHandler(handlerName);\n    assert.equal(handlers.length, 2);\n    assert.notOk(handlers.filter(function (handler) {\n      return handler.name === handlerName;\n    }).length);\n  });\n});","define('tests/acceptance/editor-key-commands-test', ['exports', 'mobiledoc-kit/utils/key', 'mobiledoc-kit/utils/keycodes', '../test-helpers', 'mobiledoc-kit/utils/browser', 'mobiledoc-kit/editor/ui'], function (exports, _mobiledocKitUtilsKey, _mobiledocKitUtilsKeycodes, _testHelpers, _mobiledocKitUtilsBrowser, _mobiledocKitEditorUi) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n  var skip = _testHelpers['default'].skip;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  function labelForModifier(key) {\n    switch (key) {\n      case _mobiledocKitUtilsKey.MODIFIERS.META:\n        return 'META';\n      case _mobiledocKitUtilsKey.MODIFIERS.CTRL:\n        return 'CTRL';\n    }\n  }\n\n  _module('Acceptance: Editor: Key Commands', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  function testStatefulCommand(_ref) {\n    var modifierName = _ref.modifierName;\n    var key = _ref.key;\n    var command = _ref.command;\n    var markupName = _ref.markupName;\n\n    test(command + ' applies markup ' + markupName + ' to highlighted text', function (assert) {\n      assert.expect(3);\n      var done = assert.async();\n\n      var modifier = _mobiledocKitUtilsKey.MODIFIERS[modifierName];\n      var modifierKeyCode = _mobiledocKitUtilsKeycodes['default'][modifierName];\n      var initialText = 'something';\n      editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref2) {\n        var post = _ref2.post;\n        var markupSection = _ref2.markupSection;\n        var marker = _ref2.marker;\n        return post([markupSection('p', [marker(initialText)])]);\n      });\n\n      assert.ok(editor.hasCursor(), 'precond - editor should have cursor');\n\n      assert.hasNoElement('#editor ' + markupName, 'precond - no ' + markupName + ' text');\n      _testHelpers['default'].dom.selectText(editor, initialText, editorElement);\n      _testHelpers['default'].dom.triggerKeyCommand(editor, key, modifier);\n      _testHelpers['default'].dom.triggerKeyEvent(editor, 'keyup', { charCode: 0, keyCode: modifierKeyCode });\n\n      _testHelpers['default'].wait(function () {\n        assert.hasElement('#editor ' + markupName + ':contains(' + initialText + ')', 'text wrapped in ' + markupName);\n        done();\n      });\n    });\n\n    test(command + ' toggles ' + markupName + ' for next entered text', function (assert) {\n      var done = assert.async();\n      assert.expect(8);\n\n      var modifier = _mobiledocKitUtilsKey.MODIFIERS[modifierName];\n      var modifierKeyCode = _mobiledocKitUtilsKeycodes['default'][modifierName];\n      var initialText = 'something';\n\n      editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref3) {\n        var post = _ref3.post;\n        var markupSection = _ref3.markupSection;\n        var marker = _ref3.marker;\n        return post([markupSection('p', [marker(initialText)])]);\n      });\n\n      assert.ok(editor.hasCursor(), 'has cursor');\n\n      assert.hasNoElement('#editor ' + markupName, 'precond - no ' + markupName + ' text');\n      _testHelpers['default'].dom.moveCursorTo(editor, editor.post.sections.head.markers.head.renderNode.element, initialText.length);\n\n      _testHelpers['default'].wait(function () {\n        _testHelpers['default'].dom.triggerKeyCommand(editor, key, modifier);\n        // simulate meta/ctrl keyup\n        _testHelpers['default'].dom.triggerKeyEvent(editor, 'keyup', { charCode: 0, keyCode: modifierKeyCode });\n\n        _testHelpers['default'].wait(function () {\n          _testHelpers['default'].dom.insertText(editor, 'z');\n\n          var expected1 = _testHelpers['default'].postAbstract.build(function (_ref4) {\n            var post = _ref4.post;\n            var markupSection = _ref4.markupSection;\n            var marker = _ref4.marker;\n            var markup = _ref4.markup;\n\n            return post([markupSection('p', [marker(initialText), marker('z', [markup(markupName)])])]);\n          });\n          var expected2 = _testHelpers['default'].postAbstract.build(function (_ref5) {\n            var post = _ref5.post;\n            var markupSection = _ref5.markupSection;\n            var marker = _ref5.marker;\n            var markup = _ref5.markup;\n\n            return post([markupSection('p', [marker(initialText), marker('z', [markup(markupName)]), marker('x')])]);\n          });\n\n          assert.postIsSimilar(editor.post, expected1);\n          assert.renderTreeIsEqual(editor._renderTree, expected1);\n          assert.positionIsEqual(editor.range.head, editor.post.tailPosition());\n\n          _testHelpers['default'].wait(function () {\n            // un-toggles markup\n            _testHelpers['default'].dom.triggerKeyCommand(editor, key, modifier);\n            _testHelpers['default'].dom.triggerKeyEvent(editor, 'keyup', { charCode: 0, keyCode: modifierKeyCode });\n\n            _testHelpers['default'].wait(function () {\n              _testHelpers['default'].dom.insertText(editor, 'x');\n\n              assert.postIsSimilar(editor.post, expected2);\n              assert.renderTreeIsEqual(editor._renderTree, expected2);\n              assert.positionIsEqual(editor.range.head, editor.post.tailPosition());\n\n              done();\n            });\n          });\n        });\n      });\n    });\n  }\n\n  testStatefulCommand({\n    modifierName: 'META',\n    key: 'B',\n    command: 'command-B',\n    markupName: 'strong'\n  });\n\n  testStatefulCommand({\n    modifierName: 'CTRL',\n    key: 'B',\n    command: 'ctrl-B',\n    markupName: 'strong'\n  });\n\n  testStatefulCommand({\n    modifierName: 'META',\n    key: 'I',\n    command: 'command-I',\n    markupName: 'em'\n  });\n\n  testStatefulCommand({\n    modifierName: 'CTRL',\n    key: 'I',\n    command: 'ctrl-I',\n    markupName: 'em'\n  });\n\n  testStatefulCommand({\n    modifierName: 'META',\n    key: 'U',\n    command: 'command-U',\n    markupName: 'u'\n  });\n\n  testStatefulCommand({\n    modifierName: 'CTRL',\n    key: 'U',\n    command: 'ctrl-U',\n    markupName: 'u'\n  });\n\n  if (_mobiledocKitUtilsBrowser['default'].isMac()) {\n    test('[Mac] ctrl-k clears to the end of a line', function (assert) {\n      var initialText = 'something';\n      editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref6) {\n        var post = _ref6.post;\n        var markupSection = _ref6.markupSection;\n        var marker = _ref6.marker;\n        return post([markupSection('p', [marker(initialText)])]);\n      });\n\n      assert.ok(editor.hasCursor(), 'has cursor');\n\n      var textElement = editor.post.sections.head.markers.head.renderNode.element;\n      _testHelpers['default'].dom.moveCursorTo(editor, textElement, 4);\n      _testHelpers['default'].dom.triggerKeyCommand(editor, 'K', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n      var changedMobiledoc = editor.serialize();\n      var expectedMobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref7) {\n        var post = _ref7.post;\n        var markupSection = _ref7.markupSection;\n        var marker = _ref7.marker;\n\n        return post([markupSection('p', [marker('some')])]);\n      });\n      assert.deepEqual(changedMobiledoc, expectedMobiledoc, 'mobiledoc updated appropriately');\n    });\n\n    test('[Mac] ctrl-k clears selected text', function (assert) {\n      var initialText = 'something';\n      editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref8) {\n        var post = _ref8.post;\n        var markupSection = _ref8.markupSection;\n        var marker = _ref8.marker;\n        return post([markupSection('p', [marker(initialText)])]);\n      });\n\n      assert.ok(editor.hasCursor(), 'has cursor');\n\n      var textElement = editor.post.sections.head.markers.head.renderNode.element;\n      _testHelpers['default'].dom.moveCursorTo(editor, textElement, 4, textElement, 8);\n      _testHelpers['default'].dom.triggerKeyCommand(editor, 'K', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n      var changedMobiledoc = editor.serialize();\n      var expectedMobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref9) {\n        var post = _ref9.post;\n        var markupSection = _ref9.markupSection;\n        var marker = _ref9.marker;\n\n        return post([markupSection('p', [marker('someg')])]);\n      });\n      assert.deepEqual(changedMobiledoc, expectedMobiledoc, 'mobiledoc updated appropriately');\n    });\n  }\n\n  var toggleLinkTest = function toggleLinkTest(assert, modifier) {\n    assert.expect(3);\n\n    var url = 'http://bustle.com';\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    editor.registerKeyCommand({\n      str: labelForModifier(modifier) + '+K',\n      run: function run(editor) {\n        (0, _mobiledocKitEditorUi.toggleLink)(editor, function (prompt, defaultUrl, callback) {\n          assert.ok(true, 'calls showPrompt');\n          callback(url);\n        });\n      }\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    _testHelpers['default'].dom.selectText(editor, 'something', editorElement);\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'K', modifier);\n\n    assert.hasElement('#editor a[href=\"' + url + '\"]:contains(something)');\n  };\n\n  var toggleLinkUnlinkTest = function toggleLinkUnlinkTest(assert, modifier) {\n    assert.expect(4);\n\n    var url = 'http://bustle.com';\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n      var markup = _ref11.markup;\n      return post([markupSection('p', [marker('something', [markup('a', { href: url })])])]);\n    });\n\n    editor.registerKeyCommand({\n      str: labelForModifier(modifier) + '+K',\n      run: function run(editor) {\n        (0, _mobiledocKitEditorUi.toggleLink)(editor, function (prompt, defaultUrl, callback) {\n          assert.ok(false, 'should not call showPrompt');\n          callback(url);\n        });\n      }\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    assert.hasElement('#editor a[href=\"' + url + '\"]:contains(something)', 'precond -- has link');\n\n    _testHelpers['default'].dom.selectText(editor, 'something', editorElement);\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'K', modifier);\n\n    assert.hasNoElement('#editor a[href=\"' + url + '\"]:contains(something)', 'removes linked text');\n    assert.hasElement('#editor p:contains(something)', 'unlinked text remains');\n  };\n\n  var toggleTests = [{\n    precondition: function precondition() {\n      return _mobiledocKitUtilsBrowser['default'].isMac();\n    },\n    msg: '[Mac] cmd-k links selected text',\n    testFn: toggleLinkTest,\n    modifier: _mobiledocKitUtilsKey.MODIFIERS.META\n  }, {\n    precondition: function precondition() {\n      return _mobiledocKitUtilsBrowser['default'].isMac();\n    },\n    msg: '[Mac] cmd-k unlinks selected text if it was already linked',\n    testFn: toggleLinkUnlinkTest,\n    modifier: _mobiledocKitUtilsKey.MODIFIERS.META\n  }, {\n    precondition: function precondition() {\n      return _mobiledocKitUtilsBrowser['default'].isWin();\n    },\n    msg: '[Windows] ctrl-k links selected text',\n    testFn: toggleLinkTest,\n    modifier: _mobiledocKitUtilsKey.MODIFIERS.CTRL\n  }, {\n    precondition: function precondition() {\n      return _mobiledocKitUtilsBrowser['default'].isWin();\n    },\n    msg: '[Windows] ctrl-k unlinks selected text if it was already linked',\n    testFn: toggleLinkUnlinkTest,\n    modifier: _mobiledocKitUtilsKey.MODIFIERS.CTRL\n  }];\n\n  toggleTests.forEach(function (_ref12) {\n    var precondition = _ref12.precondition;\n    var msg = _ref12.msg;\n    var testFn = _ref12.testFn;\n    var modifier = _ref12.modifier;\n\n    if (!precondition()) {\n      skip(msg);\n    } else {\n      test(msg, function (assert) {\n        testFn(assert, modifier);\n      });\n    }\n  });\n\n  test('new key commands can be registered', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref13) {\n      var post = _ref13.post;\n      var markupSection = _ref13.markupSection;\n      var marker = _ref13.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    var passedEditor = undefined;\n    editor.registerKeyCommand({\n      str: 'ctrl+x',\n      run: function run(editor) {\n        passedEditor = editor;\n      }\n    });\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'Y', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(!passedEditor, 'incorrect key combo does not trigger key command');\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'X', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(!!passedEditor && passedEditor === editor, 'run method is called');\n  });\n\n  test('new key commands can be registered without modifiers', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref14) {\n      var post = _ref14.post;\n      var markupSection = _ref14.markupSection;\n      var marker = _ref14.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    var passedEditor = undefined;\n    editor.registerKeyCommand({\n      str: 'X',\n      run: function run(editor) {\n        passedEditor = editor;\n      }\n    });\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'Y', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(!passedEditor, 'incorrect key combo does not trigger key command');\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'X', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(!passedEditor, 'key with modifier combo does not trigger key command');\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'X');\n\n    assert.ok(!!passedEditor && passedEditor === editor, 'run method is called');\n  });\n\n  test('duplicate key commands can be registered with the last registered winning', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref15) {\n      var post = _ref15.post;\n      var markupSection = _ref15.markupSection;\n      var marker = _ref15.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    var firstCommandRan = undefined,\n        secondCommandRan = undefined;\n\n    editor.registerKeyCommand({\n      str: 'ctrl+x',\n      run: function run() {\n        firstCommandRan = true;\n      }\n    });\n    editor.registerKeyCommand({\n      str: 'ctrl+x',\n      run: function run() {\n        secondCommandRan = true;\n      }\n    });\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'X', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(!firstCommandRan, 'first registered method not called');\n    assert.ok(!!secondCommandRan, 'last registered method is called');\n  });\n\n  test('returning false from key command causes next match to run', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref16) {\n      var post = _ref16.post;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    var firstCommandRan = undefined,\n        secondCommandRan = undefined;\n\n    editor.registerKeyCommand({\n      str: 'ctrl+x',\n      run: function run() {\n        firstCommandRan = true;\n      }\n    });\n    editor.registerKeyCommand({\n      str: 'ctrl+x',\n      run: function run() {\n        secondCommandRan = true;\n        return false;\n      }\n    });\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'X', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(!!secondCommandRan, 'last registered method is called');\n    assert.ok(!!firstCommandRan, 'first registered method is called');\n  });\n\n  test('key commands can override built-in functionality', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var marker = _ref17.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    var passedEditor = undefined;\n    editor.registerKeyCommand({\n      str: 'enter',\n      run: function run(editor) {\n        passedEditor = editor;\n      }\n    });\n\n    assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 5);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.ok(!!passedEditor && passedEditor === editor, 'run method is called');\n\n    assert.equal($('#editor p').length, 1, 'still has just one paragraph');\n  });\n\n  test('returning false from key command still runs built-in functionality', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref18) {\n      var post = _ref18.post;\n      var markupSection = _ref18.markupSection;\n      var marker = _ref18.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n\n    var passedEditor = undefined;\n    editor.registerKeyCommand({\n      str: 'enter',\n      run: function run(editor) {\n        passedEditor = editor;\n        return false;\n      }\n    });\n\n    assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 5);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.ok(!!passedEditor && passedEditor === editor, 'run method is called');\n\n    assert.equal($('#editor p').length, 2, 'has added a new paragraph');\n  });\n\n  test('new key commands can be registered and then unregistered', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref19) {\n      var post = _ref19.post;\n      var markupSection = _ref19.markupSection;\n      var marker = _ref19.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    assert.ok(editor.hasCursor(), 'has cursor');\n    var passedEditorCount = 0;\n    var passedEditor = undefined;\n    editor.registerKeyCommand({\n      name: 'cut',\n      str: 'ctrl+x',\n      run: function run(editor) {\n        passedEditor = editor;passedEditorCount++;\n      }\n    });\n\n    editor.registerKeyCommand({\n      name: 'cut',\n      str: 'ctrl+d',\n      run: function run(editor) {\n        passedEditor = editor;passedEditorCount++;\n      }\n    });\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'x', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'd', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(!!passedEditor && passedEditor === editor, 'run method is called');\n    assert.ok(passedEditorCount === 2, 'the passedEditor has been called twice');\n\n    editor.unregisterKeyCommands('cut');\n\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'x', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'd', _mobiledocKitUtilsKey.MODIFIERS.CTRL);\n\n    assert.ok(passedEditorCount === 2, 'the passedEditor has still only been called twice');\n  });\n});","define('tests/acceptance/editor-list-test', ['exports', 'mobiledoc-kit', '../test-helpers'], function (exports, _mobiledocKit, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  function listMobileDoc() {\n    return _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var listSection = _ref.listSection;\n      var listItem = _ref.listItem;\n      var marker = _ref.marker;\n      return post([listSection('ul', [listItem([marker('first item')]), listItem([marker('second item')])])]);\n    });\n  }\n\n  function createEditorWithMobiledoc(mobiledoc) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n  }\n\n  function createEditorWithListMobiledoc() {\n    createEditorWithMobiledoc(listMobileDoc());\n  }\n\n  _module('Acceptance: Editor: Lists', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('can type in middle of a list item', function (assert) {\n    createEditorWithListMobiledoc();\n\n    var listItem = $('#editor li:contains(first item)')[0];\n    assert.ok(!!listItem, 'precond - has li');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, listItem.childNodes[0], 'first'.length);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(firstX item)', 'inserts text at right spot');\n  });\n\n  test('can type at end of a list item', function (assert) {\n    createEditorWithListMobiledoc();\n\n    var listItem = $('#editor li:contains(first item)')[0];\n    assert.ok(!!listItem, 'precond - has li');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, listItem.childNodes[0], 'first item'.length);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(first itemX)', 'inserts text at right spot');\n  });\n\n  test('can type at start of a list item', function (assert) {\n    createEditorWithListMobiledoc();\n\n    var listItem = $('#editor li:contains(first item)')[0];\n    assert.ok(!!listItem, 'precond - has li');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, listItem.childNodes[0], 0);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(Xfirst item)', 'inserts text at right spot');\n  });\n\n  test('can delete selection across list items', function (assert) {\n    createEditorWithListMobiledoc();\n\n    var listItem = $('#editor li:contains(first item)')[0];\n    assert.ok(!!listItem, 'precond - has li1');\n\n    var listItem2 = $('#editor li:contains(second item)')[0];\n    assert.ok(!!listItem2, 'precond - has li2');\n\n    _testHelpers['default'].dom.selectText(editor, ' item', listItem, 'secon', listItem2);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor li:contains(d item)', 'results in correct text');\n    assert.equal($('#editor li').length, 1, 'only 1 remaining li');\n  });\n\n  test('can exit list section altogether by deleting', function (assert) {\n    createEditorWithListMobiledoc();\n\n    var listItem2 = $('#editor li:contains(second item)')[0];\n    assert.ok(!!listItem2, 'precond - has listItem2');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, listItem2.childNodes[0], 0);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor li:contains(first item)', 'still has first item');\n    assert.hasNoElement('#editor li:contains(second item)', 'second li is gone');\n    assert.hasElement('#editor p:contains(second item)', 'second li becomes p');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor p:contains(Xsecond item)', 'new text is in right spot');\n  });\n\n  test('can split list item with <enter>', function (assert) {\n    createEditorWithListMobiledoc();\n\n    var li = $('#editor li:contains(first item)')[0];\n    assert.ok(!!li, 'precond');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, li.childNodes[0], 'fir'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.hasNoElement('#editor li:contains(first item)', 'first item is split');\n    assert.hasElement('#editor li:contains(fir)', 'has split \"fir\" li');\n    assert.hasElement('#editor li:contains(st item)', 'has split \"st item\" li');\n    assert.hasElement('#editor li:contains(second item)', 'has unchanged last li');\n    assert.equal($('#editor li').length, 3, 'has 3 lis');\n\n    // hitting enter can create the right DOM but put the AT out of sync with the\n    // renderTree, so we must hit enter once more to fully test this\n\n    li = $('#editor li:contains(fir)')[0];\n    assert.ok(!!li, 'precond - has \"fir\"');\n    _testHelpers['default'].dom.moveCursorTo(editor, li.childNodes[0], 'fi'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.hasNoElement('#editor li:contains(fir)');\n    assert.hasElement('#editor li:contains(fi)', 'has split \"fi\" li');\n    assert.hasElement('#editor li:contains(r)', 'has split \"r\" li');\n    assert.equal($('#editor li').length, 4, 'has 4 lis');\n  });\n\n  test('can hit enter at end of list item to add new item', function (assert) {\n    var done = assert.async();\n    createEditorWithListMobiledoc();\n\n    var li = $('#editor li:contains(first item)')[0];\n    assert.ok(!!li, 'precond');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, li.childNodes[0], 'first item'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor li').length, 3, 'adds a new li');\n    var newLi = $('#editor li:eq(1)');\n    assert.equal(newLi.text(), '', 'new li has no text');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    _testHelpers['default'].wait(function () {\n      assert.hasElement('#editor li:contains(X)', 'text goes in right spot');\n\n      var liCount = $('#editor li').length;\n      _testHelpers['default'].dom.triggerEnter(editor);\n      _testHelpers['default'].dom.triggerEnter(editor);\n\n      assert.equal($('#editor li').length, liCount + 2, 'adds two new empty list items');\n      done();\n    });\n  });\n\n  test('hitting enter to add list item, deleting to remove it, adding new list item, exiting list and typing', function (assert) {\n    createEditorWithListMobiledoc();\n\n    var li = $('#editor li:contains(first item)')[0];\n    assert.ok(!!li, 'precond');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, li.childNodes[0], 'first item'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor li').length, 3, 'adds a new li');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor li').length, 2, 'removes middle, empty li after delete');\n    assert.equal($('#editor p').length, 1, 'adds a new paragraph section where delete happened');\n\n    li = $('#editor li:contains(first item)')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, li.childNodes[0], 'first item'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor li').length, 3, 'adds a new li after enter again');\n\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor li').length, 2, 'removes newly added li after enter on last list item');\n    assert.equal($('#editor p').length, 2, 'adds a second p section');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor p:eq(0):contains(X)', 'inserts text in right spot');\n  });\n\n  test('hitting enter at empty last list item exists list', function (assert) {\n    createEditorWithListMobiledoc();\n\n    assert.equal($('#editor p').length, 0, 'precond - no ps');\n\n    var li = $('#editor li:contains(second item)')[0];\n    assert.ok(!!li, 'precond');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, li.childNodes[0], 'second item'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor li').length, 3, 'precond - adds a third li');\n\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor li').length, 2, 'removes empty li');\n    assert.equal($('#editor p').length, 1, 'adds 1 new p');\n    assert.equal($('#editor p').text(), '', 'p has no text');\n    assert.hasNoElement('#editor ul p', 'does not nest p under ul');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor p:contains(X)', 'text goes in right spot');\n  });\n\n  // https://github.com/bustle/mobiledoc-kit/issues/117\n  test('deleting at start of non-empty section after list item joins it with list item', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var markupSection = builder.markupSection;\n      var marker = builder.marker;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n\n      return post([listSection('ul', [listItem([marker('abc')])]), markupSection('p', [marker('def')])]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    var p = $('#editor p:contains(def)')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, p.childNodes[0], 0);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasNoElement('#editor p');\n    assert.hasElement('#editor li:contains(abcdef)');\n  });\n\n  // https://github.com/bustle/mobiledoc-kit/issues/117\n  test('deleting at start of empty section after list item joins it with list item', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var markupSection = builder.markupSection;\n      var marker = builder.marker;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n\n      return post([listSection('ul', [listItem([marker('abc')])]), markupSection('p')]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    assert.hasElement('#editor p br', 'precond - br');\n    var node = $('#editor p br')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 0);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasNoElement('#editor p', 'removes p');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(abcX)', 'inserts text at right spot');\n  });\n\n  test('forward-delete in empty list item with nothing after it does nothing', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n\n      return post([listSection('ul', [listItem()])]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    assert.hasElement('#editor li br', 'precond - br');\n    var node = $('#editor li br')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 0);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.hasElement('#editor li', 'li remains');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(X)', 'inserts text at right spot');\n  });\n\n  test('forward-delete in empty li with li after it joins with li', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n      var marker = builder.marker;\n\n      return post([listSection('ul', [listItem(), listItem([marker('abc')])])]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    assert.equal($('#editor li').length, 2, 'precond - 2 lis');\n    assert.hasElement('#editor li br', 'precond - br');\n    var node = $('#editor li br')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 0);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.equal($('#editor li').length, 1, '1 li remains');\n    assert.hasElement('#editor li:contains(abc)', 'correct li remains');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(Xabc)', 'inserts text at right spot');\n  });\n\n  test('forward-delete in empty li with markup section after it joins markup section', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n      var markupSection = builder.markupSection;\n      var marker = builder.marker;\n\n      return post([listSection('ul', [listItem()]), markupSection('p', [marker('abc')])]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    assert.hasElement('#editor li br', 'precond - br');\n    var node = $('#editor li br')[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 0);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.hasElement('#editor li:contains(abc)', 'joins markup section');\n    assert.hasNoElement('#editor p', 'p is removed');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor li:contains(Xabc)', 'inserts text at right spot');\n  });\n\n  test('forward-delete end of li with nothing after', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n      var marker = builder.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')])])]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    var node = $('#editor li')[0].childNodes[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 'abc'.length);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.hasElement('#editor li:contains(abc)', 'li remains');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor li:contains(abcX)', 'inserts text at right spot');\n  });\n\n  test('forward-delete end of li with li after', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n      var marker = builder.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')])])]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    assert.equal($('#editor li').length, 2, 'precond - 2 lis');\n    var node = $('#editor li')[0].childNodes[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 'abc'.length);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.hasElement('#editor li:contains(abcdef)', 'li is joined');\n    assert.equal($('#editor li').length, 1, 'only 1 li');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor li:contains(abcXdef)', 'inserts text at right spot');\n  });\n\n  test('forward-delete end of li with markup section after', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n      var marker = builder.marker;\n      var markupSection = builder.markupSection;\n\n      return post([listSection('ul', [listItem([marker('abc')])]), markupSection('p', [marker('def')])]);\n    });\n    createEditorWithMobiledoc(mobiledoc);\n\n    var node = $('#editor li')[0].childNodes[0];\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 'abc'.length);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.hasElement('#editor li:contains(abcdef)', 'li is joined');\n    assert.equal($('#editor li').length, 1, 'only 1 li');\n    assert.hasNoElement('#editor p', 'p is removed');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor li:contains(abcXdef)', 'inserts text at right spot');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/130\n  test('selecting empty list items does not cause error', function (assert) {\n    var done = assert.async();\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n      var marker = builder.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem(), listItem([marker('def')])])]);\n    });\n\n    createEditorWithMobiledoc(mobiledoc);\n\n    assert.equal($('#editor li').length, 3, 'precond - 3 lis');\n    _testHelpers['default'].dom.moveCursorTo(editor, $('#editor li:eq(1)')[0], 0, $('#editor li:eq(2)')[0], 0);\n    _testHelpers['default'].dom.triggerEvent(editor.element, 'click');\n    _testHelpers['default'].wait(function () {\n      assert.ok(true, 'no error');\n\n      _testHelpers['default'].dom.insertText(editor, 'X');\n      assert.hasElement('#editor li:contains(Xdef)', 'insert text');\n      assert.equal($('#editor li').length, 2, 'inserting text deletes selected li');\n      done();\n    });\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/128\n  test('selecting list item and deleting leaves following section intact', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (builder) {\n      var post = builder.post;\n      var markupSection = builder.markupSection;\n      var listSection = builder.listSection;\n      var listItem = builder.listItem;\n      var marker = builder.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem()]), markupSection('p', [marker('123')])]);\n    });\n\n    createEditorWithMobiledoc(mobiledoc);\n\n    // precond\n    assert.hasElement('#editor p:contains(123)');\n    assert.hasElement('#editor li:contains(abc)');\n\n    var liTextNode = $('#editor li:eq(0)')[0].childNodes[0];\n    var emptyLiNode = $('#editor li:eq(1)')[0];\n    assert.equal(liTextNode.textContent, 'abc'); // precond\n    _testHelpers['default'].dom.moveCursorTo(editor, liTextNode, 0, emptyLiNode, 0);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor p', 'does not delete p');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasNoElement('#editor li:contains(abc)', 'li text is removed');\n    assert.hasElement('#editor li:contains(X)', 'text is inserted');\n  });\n});","define('tests/acceptance/editor-post-editor-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/utils/cursor/range'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitUtilsCursorRange) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  _module('Acceptance: Editor - PostEditor', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('#insertSectionAtEnd inserts the section at the end', function (assert) {\n    var newSection = undefined;\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      newSection = markupSection('p', [marker('123')]);\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    //precond\n    assert.hasElement('#editor p:contains(abc)');\n    assert.hasNoElement('#editor p:contains(123)');\n\n    editor.run(function (postEditor) {\n      return postEditor.insertSectionAtEnd(newSection);\n    });\n    assert.hasElement('#editor p:eq(1):contains(123)', 'new section added at end');\n  });\n\n  test('#insertSection inserts after the cursor active section', function (assert) {\n    var newSection = undefined;\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      newSection = markupSection('p', [marker('123')]);\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('def')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    //precond\n    assert.hasElement('#editor p:eq(0):contains(abc)');\n    assert.hasElement('#editor p:eq(1):contains(def)');\n    assert.hasNoElement('#editor p:contains(123)');\n\n    _testHelpers['default'].dom.selectText(editor, 'b', editorElement);\n\n    editor.run(function (postEditor) {\n      return postEditor.insertSection(newSection);\n    });\n    assert.hasElement('#editor p:eq(0):contains(abc)', 'still has 1st section');\n    assert.hasElement('#editor p:eq(1):contains(123)', 'new section added after active section');\n    assert.hasElement('#editor p:eq(2):contains(def)', '2nd section -> 3rd spot');\n  });\n\n  test('#insertSection inserts at end when no active cursor section', function (assert) {\n    var newSection = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      newSection = markupSection('p', [marker('123')]);\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('def')])]);\n    }, { autofocus: false });\n\n    //precond\n    assert.ok(!editor.hasCursor(), 'editor has no cursor');\n    assert.ok(editor.range.isBlank, 'editor has no cursor');\n    assert.hasElement('#editor p:eq(0):contains(abc)');\n    assert.hasElement('#editor p:eq(1):contains(def)');\n    assert.hasNoElement('#editor p:contains(123)');\n\n    _testHelpers['default'].dom.clearSelection();\n    editor.run(function (postEditor) {\n      return postEditor.insertSection(newSection);\n    });\n    assert.hasElement('#editor p:eq(0):contains(abc)', 'still has 1st section');\n    assert.hasElement('#editor p:eq(2):contains(123)', 'new section added at end');\n    assert.hasElement('#editor p:eq(1):contains(def)', '2nd section -> same spot');\n  });\n\n  test('#insertSection can insert card, render it in display mode', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var displayedCard = undefined,\n        editedCard = undefined;\n    var cards = [{\n      name: 'sample-card',\n      type: 'dom',\n      render: function render() {\n        displayedCard = true;\n      },\n      edit: function edit() {\n        editedCard = true;\n      }\n    }];\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    editor.run(function (postEditor) {\n      var cardSection = postEditor.builder.createCardSection('sample-card');\n      postEditor.insertSection(cardSection);\n    });\n\n    assert.ok(displayedCard, 'rendered card in display mode');\n  });\n\n  test('#insertSection inserts card, can render it in edit mode using #editCard', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var displayedCard = undefined,\n        editedCard = undefined;\n    var cards = [{\n      name: 'sample-card',\n      type: 'dom',\n      render: function render() {\n        displayedCard = true;\n      },\n      edit: function edit() {\n        editedCard = true;\n      }\n    }];\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    editor.run(function (postEditor) {\n      var cardSection = postEditor.builder.createCardSection('sample-card');\n      postEditor.insertSection(cardSection);\n      editor.editCard(cardSection);\n    });\n\n    assert.ok(editedCard, 'rendered card in edit mode');\n    assert.ok(!displayedCard, 'did not render in display mode');\n  });\n\n  test('after inserting a section, can use editor#editCard to switch it to edit mode', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref6) {\n      var post = _ref6.post;\n      var cardSection = _ref6.cardSection;\n\n      return post([cardSection('sample-card')]);\n    });\n\n    var displayedCard = undefined,\n        editedCard = undefined;\n    var cards = [{\n      name: 'sample-card',\n      type: 'dom',\n      render: function render() {\n        displayedCard = true;\n      },\n      edit: function edit() {\n        editedCard = true;\n      }\n    }];\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n    assert.ok(displayedCard, 'called display#setup');\n    assert.ok(!editedCard, 'did not call edit#setup yet');\n\n    displayedCard = false;\n    var card = editor.post.sections.head;\n    editor.editCard(card);\n\n    assert.ok(editedCard, 'called edit#setup');\n    assert.ok(!displayedCard, 'did not call display#setup again');\n  });\n\n  test('can call editor#displayCard to switch card into display mode', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref7) {\n      var post = _ref7.post;\n      var cardSection = _ref7.cardSection;\n\n      return post([cardSection('sample-card')]);\n    });\n\n    var displayedCard = undefined,\n        editedCard = undefined;\n    var cards = [{\n      name: 'sample-card',\n      type: 'dom',\n      render: function render() {\n        displayedCard = true;\n      },\n      edit: function edit() {\n        editedCard = true;\n      }\n    }];\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    assert.ok(displayedCard, 'precond - called display#setup');\n    assert.ok(!editedCard, 'precond - did not call edit#setup yet');\n\n    displayedCard = false;\n    var card = editor.post.sections.head;\n    editor.editCard(card);\n\n    assert.ok(!displayedCard, 'card not in display mode');\n    assert.ok(editedCard, 'card in edit mode');\n\n    editedCard = false;\n\n    editor.displayCard(card);\n\n    assert.ok(displayedCard, 'card back in display mode');\n    assert.ok(!editedCard, 'card not in edit mode');\n  });\n\n  test('#toggleMarkup adds markup by tag name', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n\n      return post([markupSection('p', [marker('abc'), marker('def')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    //precond\n    assert.hasNoElement('#editor strong');\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement, 'd', editorElement);\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n    assert.hasElement('#editor strong:contains(bcd)');\n  });\n\n  test('#toggleMarkup removes markup by tag name', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n      var markup = _ref9.markup;\n\n      var strong = markup('strong');\n      return post([markupSection('p', [marker('a'), marker('bcde', [strong]), marker('f')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    //precond\n    assert.hasElement('#editor strong:contains(bcde)');\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement, 'd', editorElement);\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n    assert.hasNoElement('#editor strong:contains(bcd)', 'markup removed from selection');\n    assert.hasElement('#editor strong:contains(e)', 'unselected text still bold');\n  });\n\n  test('#toggleMarkup does nothing with an empty selection', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n\n      return post([markupSection('p', [marker('a')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n\n    assert.hasNoElement('#editor strong', 'strong not added, nothing selected');\n  });\n\n  test('postEditor reads editor range, sets it with #setRange', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var _editor = editor;\n    var post = _editor.post;\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement);\n    var range = editor.range;\n    var expectedRange = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 'a'.length, post.sections.head, 'abc'.length);\n    assert.ok(range.isEqual(expectedRange), 'precond - editor.range is correct');\n\n    var newRange = undefined;\n    editor.run(function (postEditor) {\n      newRange = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 0, post.sections.head, 1);\n      postEditor.setRange(newRange);\n    });\n\n    assert.ok(editor.range.isEqual(newRange), 'newRange is rendered after run');\n  });\n});","define('tests/acceptance/editor-reparse-test', ['exports', '../test-helpers', 'mobiledoc-kit/renderers/editor-dom'], function (exports, _testHelpers, _mobiledocKitRenderersEditorDom) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var simpleAtom = {\n    name: 'simple-atom',\n    type: 'dom',\n    render: function render(_ref) {\n      var value = _ref.value;\n\n      var element = document.createElement('span');\n      element.setAttribute('id', 'simple-atom');\n      element.appendChild(document.createTextNode(value));\n      return element;\n    }\n  };\n\n  var editor = undefined,\n      editorElement = undefined;\n  var editorOptions = { atoms: [simpleAtom] };\n\n  _module('Acceptance: Editor: Reparsing', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('changing text node content causes reparse of section', function (assert) {\n    var done = assert.async();\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      expected = post([markupSection('p', [marker('def')])]);\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var section = editor.post.sections.head;\n    var node = section.markers.head.renderNode.element;\n\n    assert.equal(node.textContent, 'abc', 'precond - correct text node');\n    assert.equal(section.text, 'abc', 'precond - correct section');\n\n    node.textContent = 'def';\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(section.text, 'def', 'section reparsed correctly');\n      assert.postIsSimilar(editor.post, expected);\n      done();\n    });\n  });\n\n  test('removing text node causes reparse of section', function (assert) {\n    var done = assert.async();\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      expected = post([markupSection('p', [marker('def')])]);\n\n      return post([markupSection('p', [marker('abc'), marker('def')])]);\n    });\n\n    var section = editor.post.sections.head;\n    var node = section.markers.head.renderNode.element;\n\n    assert.equal(node.textContent, 'abc', 'precond - correct text node');\n    assert.equal(section.text, 'abcdef', 'precond - correct section');\n\n    node.parentNode.removeChild(node);\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(section.text, 'def', 'section reparsed correctly');\n      assert.postIsSimilar(editor.post, expected);\n      done();\n    });\n  });\n\n  test('removing section node causes reparse of post', function (assert) {\n    var done = assert.async();\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      expected = post([markupSection('p', [marker('123')])]);\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('123')])]);\n    });\n\n    var node = editor.post.sections.head.renderNode.element;\n    assert.equal(node.innerHTML, 'abc', 'precond - correct node');\n\n    node.parentNode.removeChild(node);\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      done();\n    });\n  });\n\n  test('inserting styled span in section causes section reparse', function (assert) {\n    var done = assert.async();\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n\n      expected = post([markupSection('p', [marker('abc'), marker('def')])]);\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var node = editor.post.sections.head.renderNode.element;\n    assert.equal(node.innerHTML, 'abc', 'precond - correct node');\n\n    var span = document.createElement('span');\n    span.setAttribute('style', 'font-size: 24px; font-color: blue');\n    span.appendChild(document.createTextNode('def'));\n    node.appendChild(span);\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      done();\n    });\n  });\n\n  test('inserting new top-level node causes reparse of post', function (assert) {\n    var done = assert.async();\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n\n      expected = post([markupSection('p', [marker('abc')]), markupSection('p', [marker('123')])]);\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var span = document.createElement('span');\n    span.appendChild(document.createTextNode('123'));\n    editorElement.appendChild(span);\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      done();\n    });\n  });\n\n  test('inserting node into blank post causes reparse', function (assert) {\n    var done = assert.async();\n    var expected = undefined;\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      expected = post([markupSection('p', [marker('123')])]);\n      return post();\n    });\n\n    var span = document.createElement('span');\n    span.appendChild(document.createTextNode('123'));\n    editorElement.appendChild(span);\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      done();\n    });\n  });\n\n  test('after reparsing post, mutations still handled properly', function (assert) {\n    var done = assert.async();\n    var expected1 = undefined,\n        expected2 = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n\n      expected1 = post([markupSection('p', [marker('abc')]), markupSection('p', [marker('123')])]);\n\n      expected2 = post([markupSection('p', [marker('def')]), markupSection('p', [marker('123')])]);\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var span = document.createElement('span');\n    span.appendChild(document.createTextNode('123'));\n    editorElement.appendChild(span);\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected1);\n\n      var node = editorElement.firstChild.firstChild;\n      assert.equal(node.textContent, 'abc', 'precond - correct node');\n\n      node.textContent = 'def';\n\n      _testHelpers['default'].wait(function () {\n        assert.postIsSimilar(editor.post, expected2);\n\n        done();\n      });\n    });\n  });\n\n  test('inserting text into text node on left/right of atom is reparsed correctly', function (assert) {\n    var done = assert.async();\n    var expected1 = undefined,\n        expected2 = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n      var atom = _ref9.atom;\n\n      expected1 = post([markupSection('p', [atom('simple-atom', 'first'), marker('Z')])]);\n\n      expected2 = post([markupSection('p', [marker('A'), atom('simple-atom', 'first'), marker('Z')])]);\n\n      return post([markupSection('p', [atom('simple-atom', 'first')])]);\n    }, editorOptions);\n\n    var atom = editor.post.sections.head.markers.head;\n    var rightCursorNode = atom.renderNode.tailTextNode;\n\n    assert.ok(rightCursorNode && rightCursorNode.textContent === _mobiledocKitRenderersEditorDom.ZWNJ, 'precond - correct right cursor node');\n\n    rightCursorNode.textContent = 'Z';\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected1);\n      assert.renderTreeIsEqual(editor._renderTree, expected1);\n\n      var leftCursorNode = atom.renderNode.headTextNode;\n      assert.ok(leftCursorNode && leftCursorNode.textContent === _mobiledocKitRenderersEditorDom.ZWNJ, 'precond - correct left cursor node');\n      leftCursorNode.textContent = 'A';\n\n      _testHelpers['default'].wait(function () {\n        assert.postIsSimilar(editor.post, expected2);\n        assert.renderTreeIsEqual(editor._renderTree, expected2);\n\n        done();\n      });\n    });\n  });\n\n  test('mutation inside card element does not cause reparse', function (assert) {\n    var done = assert.async();\n    var parseCount = 0;\n    var myCard = {\n      name: 'my-card',\n      type: 'dom',\n      render: function render() {\n        return document.createTextNode('howdy');\n      }\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref10) {\n      var post = _ref10.post;\n      var cardSection = _ref10.cardSection;\n\n      return post([cardSection('my-card', {})]);\n    }, {\n      cards: [myCard]\n    });\n\n    editor.didUpdatePost(function () {\n      parseCount++;\n    });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'howdy');\n    textNode.textContent = 'adios';\n\n    // Allow the mutation observer to fire then...\n    _testHelpers['default'].wait(function () {\n      assert.equal(0, parseCount);\n      done();\n    });\n  });\n});","define('tests/acceptance/editor-sections-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/renderers/mobiledoc/0-2', 'mobiledoc-kit/renderers/editor-dom', 'mobiledoc-kit/utils/cursor/range', 'mobiledoc-kit/utils/keycodes', 'mobiledoc-kit/utils/browser', 'mobiledoc-kit/utils/key'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitRenderersMobiledoc02, _mobiledocKitRenderersEditorDom, _mobiledocKitUtilsCursorRange, _mobiledocKitUtilsKeycodes, _mobiledocKitUtilsBrowser, _mobiledocKitUtilsKey) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var editor = undefined,\n      editorElement = undefined;\n  var mobileDocWith1Section = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[], [[1, \"P\", [[[], 0, \"only section\"]]]]]\n  };\n  var mobileDocWith2Sections = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[], [[1, \"P\", [[[], 0, \"first section\"]]], [1, \"P\", [[[], 0, \"second section\"]]]]]\n  };\n  var mobileDocWith3Sections = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[], [[1, \"P\", [[[], 0, \"first section\"]]], [1, \"P\", [[[], 0, \"second section\"]]], [1, \"P\", [[[], 0, \"third section\"]]]]]\n  };\n\n  var mobileDocWith2Markers = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[['b']], [[1, \"P\", [[[0], 1, \"bold\"], [[], 0, \"plain\"]]]]]\n  };\n\n  var mobileDocWith1Character = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[], [[1, \"P\", [[[], 0, \"c\"]]]]]\n  };\n\n  var mobileDocWithNoCharacter = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[], [[1, \"P\", [[[], 0, \"\"]]]]]\n  };\n\n  _module('Acceptance: Editor sections', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('typing enter inserts new section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith1Section });\n    editor.render(editorElement);\n    assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 5);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');\n    assert.hasElement('#editor p:contains(only)', 'has correct first pargraph text');\n    assert.hasElement('#editor p:contains(section)', 'has correct second paragraph text');\n  });\n\n  test('typing enter inserts new section from blank section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWithNoCharacter });\n    editor.render(editorElement);\n    assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 0);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');\n  });\n\n  test('hitting enter in first section splits it correctly', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n    assert.equal($('#editor p').length, 2, 'precond - has 2 paragraphs');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 3);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 3, 'has 3 paragraphs after typing return');\n\n    assert.equal($('#editor p:eq(0)').text(), 'fir', 'first para has correct text');\n    assert.equal($('#editor p:eq(1)').text(), 'st section', 'second para has correct text');\n    assert.equal($('#editor p:eq(2)').text(), 'second section', 'third para still has correct text');\n\n    assert.deepEqual(_testHelpers['default'].dom.getCursorPosition(), { node: editorElement.childNodes[1].childNodes[0],\n      offset: 0 });\n  });\n\n  test('hitting enter at start of a section creates empty section where cursor was', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith1Section });\n    editor.render(editorElement);\n    assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 0);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');\n\n    var firstP = $('#editor p:eq(0)');\n    assert.equal(firstP.text(), '', 'first para has no text');\n    assert.hasElement('#editor p:eq(1):contains(only section)', 'has correct second paragraph text');\n\n    assert.deepEqual(_testHelpers['default'].dom.getCursorPosition(), { node: editorElement.childNodes[1].childNodes[0],\n      offset: 0 });\n  });\n\n  test('hitting enter at end of a section creates new empty section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith1Section });\n    editor.render(editorElement);\n    assert.equal($('#editor p').length, 1, 'has 1 section to start');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 'only section'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 2, 'has 2 sections after typing return');\n    assert.hasElement('#editor p:eq(0):contains(only section)', 'has same first section text');\n    assert.hasElement('#editor p:eq(1):contains()', 'second section has no text');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor p:eq(1):contains(X)', 'text is inserted in the new section');\n  });\n\n  test('hitting enter in a section creates a new basic section', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n      return post([markupSection('h2', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n    assert.hasElement('#editor h2:contains(abc)', 'precond - h2 is there');\n    assert.hasNoElement('#editor p', 'precond - no p tag');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, $('#editor h2')[0].childNodes[0], 'abc'.length);\n    _testHelpers['default'].dom.triggerEnter(editor);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor h2:contains(abc)', 'h2 still there');\n    assert.hasElement('#editor p:contains(X)', 'p tag instead of h2 generated');\n  });\n\n  test('deleting across 2 sections does nothing if editing is disabled', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n    editor.disableEditing();\n    assert.equal($('#editor p').length, 2, 'precond - has 2 sections to start');\n\n    var p0 = $('#editor p:eq(0)')[0],\n        p1 = $('#editor p:eq(1)')[0];\n\n    _testHelpers['default'].dom.selectText(editor, 'tion', p0, 'sec', p1);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p').length, 2, 'still has 2 sections');\n  });\n\n  test('deleting across 2 sections merges them', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n    assert.equal($('#editor p').length, 2, 'precond - has 2 sections to start');\n\n    var p0 = $('#editor p:eq(0)')[0],\n        p1 = $('#editor p:eq(1)')[0];\n\n    _testHelpers['default'].dom.selectText(editor, 'tion', p0, 'sec', p1);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p').length, 1, 'has only 1 paragraph after deletion');\n    assert.hasElement('#editor p:contains(first second section)', 'remaining paragraph has correct text');\n  });\n\n  test('deleting across 1 section removes it, joins the 2 boundary sections', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith3Sections });\n    editor.render(editorElement);\n    assert.equal($('#editor p').length, 3, 'precond - has 3 paragraphs to start');\n\n    var p0 = $('#editor p:eq(0)')[0],\n        p1 = $('#editor p:eq(1)')[0],\n        p2 = $('#editor p:eq(2)')[0];\n    assert.ok(p0 && p1 && p2, 'precond - paragraphs exist');\n\n    _testHelpers['default'].dom.selectText(editor, 'section', p0, 'third ', p2);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p').length, 1, 'has only 1 paragraph after deletion');\n    assert.hasElement('#editor p:contains(first section)', 'remaining paragraph has correct text');\n  });\n\n  test('failing to delete will not trigger deleting hooks', function (assert) {\n    assert.expect(0);\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.willDelete(function () {\n      assert.ok(false, 'willDelete should not be triggered');\n    });\n    editor.didDelete(function () {\n      assert.ok(false, 'didDelete should not be triggered');\n    });\n\n    editor.render(editorElement);\n    editor.disableEditing();\n    _testHelpers['default'].dom.triggerDelete(editor);\n  });\n\n  test('deleting chracter triggers deleting hooks', function (assert) {\n    assert.expect(9);\n    var lifeCycles = [];\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.willDelete(function (range, direction, unit) {\n      assert.ok(range, 'range is not empty');\n      assert.equal(direction, -1, 'direction defaults to -1');\n      assert.equal(unit, 'char', 'unit defaults to char');\n      assert.ok(true, 'willDelete is triggered');\n      lifeCycles.push('willDelete');\n    });\n    editor.didDelete(function (range, direction, unit) {\n      assert.ok(range, 'range is not empty');\n      assert.equal(direction, -1, 'direction defaults to -1');\n      assert.equal(unit, 'char', 'unit defaults to char');\n      assert.ok(true, 'didDelete is triggered');\n      lifeCycles.push('didDelete');\n    });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n    assert.deepEqual(lifeCycles, ['willDelete', 'didDelete'], 'hooks are triggered in order');\n  });\n\n  test('keystroke of delete removes that character', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith3Sections });\n    editor.render(editorElement);\n    var getFirstTextNode = function getFirstTextNode() {\n      return editor.element.firstChild. // section\n      firstChild; // marker\n    };\n    var textNode = getFirstTextNode();\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 1);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p:eq(0)').html(), 'irst section', 'deletes first character');\n\n    var newTextNode = getFirstTextNode();\n    assert.deepEqual(_testHelpers['default'].dom.getCursorPosition(), { node: newTextNode, offset: 0 }, 'cursor is at start of new text node');\n  });\n\n  test('keystroke of delete removes emoji character', function (assert) {\n    var monkey = 'monkey🙈';\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      return post([markupSection('p', [marker(monkey)])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n    var textNode = editorElement.firstChild. // section\n    firstChild; // marker\n    assert.equal(textNode.textContent, monkey, 'precond - correct text');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, monkey.length);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p:eq(0)').text(), 'monkey', 'deletes the emoji');\n  });\n\n  test('keystroke of forward delete removes emoji character', function (assert) {\n    var monkey = 'monkey🙈';\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      return post([markupSection('p', [marker(monkey)])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n    var textNode = editorElement.firstChild. // section\n    firstChild; // marker\n    assert.equal(textNode.textContent, monkey, 'precond - correct text');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'monkey'.length);\n    _testHelpers['default'].dom.triggerForwardDelete(editor);\n\n    assert.equal($('#editor p:eq(0)').text(), 'monkey', 'deletes the emoji');\n  });\n\n  test('keystroke of delete when cursor is at beginning of marker removes character from previous marker', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Markers });\n    editor.render(editorElement);\n    var textNode = editor.element.firstChild. // section\n    childNodes[1]; // plain marker\n\n    assert.ok(!!textNode, 'gets text node');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 0);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p:eq(0)').html(), '<b>bol</b>plain', 'deletes last character of previous marker');\n\n    var boldNode = editor.element.firstChild. // section\n    firstChild; // bold marker\n    var boldTextNode = boldNode.firstChild;\n\n    assert.deepEqual(_testHelpers['default'].dom.getCursorPosition(), { node: boldTextNode, offset: 3 }, 'cursor moves to end of previous text node');\n  });\n\n  test('keystroke of delete when cursor is after only char in only marker of section removes character', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith1Character });\n    editor.render(editorElement);\n    var getTextNode = function getTextNode() {\n      return editor.element.firstChild. // section\n      firstChild;\n    }; // c marker\n\n    var textNode = getTextNode();\n    assert.ok(!!textNode, 'gets text node');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 1);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor p:eq(0):contains()', 'first p is empty');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('#editor p:eq(0):contains(X)', 'text is added back to section');\n  });\n\n  test('keystroke of character in empty section adds character, moves cursor', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWithNoCharacter });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor p br', 'precond - br tag rendered for empty section');\n    var pNode = $('#editor p')[0];\n\n    // Firefox requires that the cursor be placed explicitly for this test to pass\n    _testHelpers['default'].dom.moveCursorTo(editor, pNode, 0);\n\n    var letter = 'M';\n    _testHelpers['default'].dom.insertText(editor, letter);\n\n    assert.hasElement('#editor p:contains(' + letter + ')', 'adds char');\n\n    var otherLetter = 'X';\n    _testHelpers['default'].dom.insertText(editor, otherLetter);\n\n    assert.hasElement('#editor p:contains(' + letter + otherLetter + ')', 'adds char in correct spot');\n  });\n\n  test('keystroke of delete at start of section joins with previous section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var secondSectionTextNode = editor.element.childNodes[1].firstChild;\n\n    assert.equal(secondSectionTextNode.textContent, 'second section', 'precond - section section text node');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, secondSectionTextNode, 0);\n    //editor.range = null;\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal(editor.element.childNodes.length, 1, 'only 1 section remaining');\n\n    var secondSectionNode = editor.element.firstChild;\n    secondSectionTextNode = secondSectionNode.firstChild;\n    assert.equal(secondSectionNode.textContent, 'first sectionsecond section', 'joins two sections');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor p:contains(first sectionXsecond section)', 'inserts text at correct spot');\n  });\n\n  test('keystroke of delete at start of first section does nothing', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var firstSectionTextNode = editor.element.childNodes[0].firstChild;\n\n    assert.equal(firstSectionTextNode.textContent, 'first section', 'finds first section text node');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, firstSectionTextNode, 0);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal(editor.element.childNodes.length, 2, 'still 2 sections');\n    firstSectionTextNode = editor.element.childNodes[0].firstChild;\n    assert.equal(firstSectionTextNode.textContent, 'first section', 'first section still has same text content');\n\n    assert.deepEqual(_testHelpers['default'].dom.getCursorPosition(), { node: firstSectionTextNode,\n      offset: 0 }, 'cursor stays at start of first section');\n  });\n\n  test('when selection incorrectly contains P end tag, editor reports correct selection', function (assert) {\n    var done = assert.async();\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var secondSectionTextNode = editor.element.childNodes[1].firstChild;\n    var firstSectionPNode = editor.element.childNodes[0];\n\n    _testHelpers['default'].dom.moveCursorTo(editor, firstSectionPNode, 0, secondSectionTextNode, 0);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    _testHelpers['default'].wait(function () {\n      assert.ok(true, 'No error should occur');\n\n      var _editor$range = editor.range;\n      var headSection = _editor$range.headSection;\n      var tailSection = _editor$range.tailSection;\n      var headMarker = _editor$range.headMarker;\n      var tailMarker = _editor$range.tailMarker;\n      var headSectionOffset = _editor$range.headSectionOffset;\n      var tailSectionOffset = _editor$range.tailSectionOffset;\n      var headMarkerOffset = _editor$range.headMarkerOffset;\n      var tailMarkerOffset = _editor$range.tailMarkerOffset;\n\n      assert.ok(headSection === editor.post.sections.objectAt(0), 'returns first section head');\n      assert.ok(tailSection === editor.post.sections.objectAt(1), 'returns second section tail');\n      assert.ok(headMarker === editor.post.sections.objectAt(0).markers.head, 'returns first section marker head');\n      assert.ok(tailMarker === editor.post.sections.objectAt(1).markers.head, 'returns second section marker tail');\n      assert.equal(headMarkerOffset, 0, 'headMarkerOffset correct');\n      assert.equal(tailMarkerOffset, 0, 'tailMarkerOffset correct');\n      assert.equal(headSectionOffset, 0, 'headSectionOffset correct');\n      assert.equal(tailSectionOffset, 0, 'tailSectionOffset correct');\n\n      done();\n    });\n  });\n\n  test('when selection incorrectly contains P start tag, editor reports correct selection', function (assert) {\n    var done = assert.async();\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var firstSectionTextNode = editor.element.childNodes[0].firstChild;\n    var secondSectionPNode = editor.element.childNodes[1];\n\n    _testHelpers['default'].dom.moveCursorTo(editor, firstSectionTextNode, 0, secondSectionPNode, 0);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    _testHelpers['default'].wait(function () {\n      assert.ok(true, 'No error should occur');\n\n      var _editor$range2 = editor.range;\n      var headSection = _editor$range2.headSection;\n      var tailSection = _editor$range2.tailSection;\n      var headMarker = _editor$range2.headMarker;\n      var tailMarker = _editor$range2.tailMarker;\n      var headSectionOffset = _editor$range2.headSectionOffset;\n      var tailSectionOffset = _editor$range2.tailSectionOffset;\n      var headMarkerOffset = _editor$range2.headMarkerOffset;\n      var tailMarkerOffset = _editor$range2.tailMarkerOffset;\n\n      assert.equal(headSection, editor.post.sections.objectAt(0), 'returns first section head');\n      assert.equal(tailSection, editor.post.sections.objectAt(1), 'returns second section tail');\n      assert.equal(headMarker, editor.post.sections.objectAt(0).markers.head, 'returns first section marker head');\n      assert.equal(tailMarker, editor.post.sections.objectAt(1).markers.head, 'returns second section marker tail');\n      assert.equal(headMarkerOffset, 0, 'headMarkerOffset correct');\n      assert.equal(tailMarkerOffset, 0, 'tailMarkerOffset correct');\n      assert.equal(headSectionOffset, 0, 'headSectionOffset correct');\n      assert.equal(tailSectionOffset, 0, 'tailSectionOffset correct');\n\n      done();\n    });\n  });\n\n  test('deleting when after deletion there is a trailing space positions cursor at end of selection', function (assert) {\n    var done = assert.async();\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var firstSectionTextNode = editor.element.childNodes[0].firstChild;\n    _testHelpers['default'].dom.moveCursorTo(editor, firstSectionTextNode, 'first section'.length);\n\n    var count = 'ection'.length;\n    while (count--) {\n      _testHelpers['default'].dom.triggerDelete(editor);\n    }\n\n    assert.equal($('#editor p:eq(0)').text(), 'first s', 'precond - correct section text after initial deletions');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p:eq(0)').text(), 'first' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE, 'precond - correct text after deleting last char before space');\n\n    var text = 'e';\n    _testHelpers['default'].dom.insertText(editor, text);\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(editor.post.sections.head.text, 'first ' + text, 'character is placed after space');\n\n      done();\n    });\n  });\n\n  test('deleting when after deletion there is a leading space positions cursor at start of selection', function (assert) {\n    var done = assert.async();\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'second', editorElement);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p:eq(1)').text(), _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + 'section', 'correct text after deletion');\n    var text = 'e';\n    _testHelpers['default'].dom.insertText(editor, text);\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(editor.post.sections.tail.text, text + ' section', 'correct text after insertion');\n      done();\n    });\n  });\n\n  test('inserting multiple spaces renders them with nbsps', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n\n      return post([markupSection()]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    // Tests on FF fail if the editor doesn't have a cursor, we must\n    // render it explicitly\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n\n    assert.ok(editor.hasCursor(), 'precond - has cursor');\n\n    var sp = ' ',\n        nbsp = _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE;\n    _testHelpers['default'].dom.insertText(editor, sp + sp + sp);\n    assert.equal($('#editor p:eq(0)').text(), nbsp + nbsp + nbsp, 'correct nbsps in text');\n  });\n\n  test('deleting when the previous section is also blank', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWithNoCharacter });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement.childNodes[0].childNodes[0], 0);\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal($('#editor p').length, 1, 'has 1 paragraphs after typing delete');\n  });\n\n  test('deleting from head of section when previous section is non-markerable', function (assert) {\n    var card = {\n      name: 'some-card',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n      var cardSection = _ref5.cardSection;\n\n      expected = post([cardSection('some-card'), markupSection('p', [marker('abc')])]);\n      return post([cardSection('some-card'), markupSection('p', [marker('abc')])]);\n    }, { cards: [card] });\n\n    var node = _testHelpers['default'].dom.findTextNode(editorElement, 'abc');\n    _testHelpers['default'].dom.moveCursorTo(editor, node, 0);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.positionIsEqual(editor.range.head, editor.post.sections.head.tailPosition(), 'moves cursor to end of card section');\n    assert.postIsSimilar(editor.post, expected, 'post is not changed');\n  });\n\n  test('delete with option (Mac) or control (Win)  key deletes full word', function (assert) {\n    assert.expect(1);\n    if (!_mobiledocKitUtilsBrowser['default'].isMac() && !_mobiledocKitUtilsBrowser['default'].isWin()) {\n      assert.ok(true, 'SKIP on non-mac non-win');\n      return;\n    }\n\n    var done = assert.async();\n\n    var _Helpers$postAbstract$buildFromText = _testHelpers['default'].postAbstract.buildFromText(\"abc def\");\n\n    var post = _Helpers$postAbstract$buildFromText.post;\n\n    var _Helpers$postAbstract$buildFromText2 = _testHelpers['default'].postAbstract.buildFromText(\"abc \");\n\n    var expected = _Helpers$postAbstract$buildFromText2.post;\n\n    editor = _testHelpers['default'].mobiledoc.renderPostInto(editorElement, post);\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n\n    var altKey = undefined,\n        ctrlKey = undefined;\n    if (_mobiledocKitUtilsBrowser['default'].isMac()) {\n      /* Mac key codes for navigation by word */\n      altKey = true;\n      ctrlKey = false;\n    } else {\n      /* PC key codes for navigation by word */\n      altKey = false;\n      ctrlKey = true;\n    }\n\n    _testHelpers['default'].wait(function () {\n      _testHelpers['default'].dom.triggerDelete(editor, _mobiledocKitUtilsKey.DIRECTION.BACKWARD, { altKey: altKey, ctrlKey: ctrlKey });\n\n      _testHelpers['default'].wait(function () {\n        assert.postIsSimilar(editor.post, expected);\n        done();\n      });\n    });\n  });\n});","define('tests/acceptance/editor-selections-test', ['exports', 'mobiledoc-kit', '../test-helpers', 'mobiledoc-kit/renderers/mobiledoc/0-2'], function (exports, _mobiledocKit, _testHelpers, _mobiledocKitRenderersMobiledoc02) {\n  'use strict';\n\n  var test = _testHelpers['default'].test;\n  var _module = _testHelpers['default'].module;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  var mobileDocWithSection = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[], [[1, \"P\", [[[], 0, \"one trick pony\"]]]]]\n  };\n\n  var mobileDocWith2Sections = {\n    version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n    sections: [[], [[1, \"P\", [[[], 0, \"first section\"]]], [1, \"P\", [[[], 0, \"second section\"]]]]]\n  };\n\n  _module('Acceptance: Editor Selections', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n      }\n    }\n  });\n\n  test('selecting across sections is possible', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var firstSection = $('p:contains(first section)')[0];\n    var secondSection = $('p:contains(second section)')[0];\n\n    _testHelpers['default'].dom.selectText(editor, 'section', firstSection, 'second', secondSection);\n\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n    assert.equal(editor.activeSections.length, 2, 'selects 2 sections');\n  });\n\n  test('when editing is disabled, the selection detection code is disabled', function (assert) {\n    var done = assert.async();\n    $('#qunit-fixture').append('<p>outside section 1</p>');\n    $('#qunit-fixture').append('<p>outside section 2</p>');\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWithSection });\n    editor.render(editorElement);\n    editor.disableEditing();\n\n    var outside1 = $('p:contains(outside section 1)')[0];\n    var outside2 = $('p:contains(outside section 2)')[0];\n\n    _testHelpers['default'].wait(function () {\n      _testHelpers['default'].dom.selectText(editor, 'outside', outside1, 'section 2', outside2);\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(editor.activeSections.length, 0, 'no selection inside the editor');\n        var selectedText = _testHelpers['default'].dom.getSelectedText();\n        assert.ok(selectedText.indexOf('outside section 1') !== -1 && selectedText.indexOf('outside section 2') !== -1, 'selects the text');\n\n        done();\n      });\n    });\n  });\n\n  test('selecting an entire section and deleting removes it', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'second section', editorElement);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor p:contains(first section)');\n    assert.hasNoElement('#editor p:contains(second section)', 'deletes contents of second section');\n    assert.equal($('#editor p').length, 2, 'still has 2 sections');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.hasElement('#editor p:eq(1):contains(X)', 'inserts text in correct spot');\n  });\n\n  test('selecting text in a section and deleting deletes it', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'cond sec', editorElement);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor p:contains(first section)', 'first section unchanged');\n    assert.hasNoElement('#editor p:contains(second section)', 'second section is no longer there');\n    assert.hasElement('#editor p:contains(setion)', 'second section has correct text');\n\n    _testHelpers['default'].dom.insertText(editor, 'Z');\n    assert.hasElement('#editor p:contains(seZtion)', 'text inserted correctly');\n  });\n\n  test('selecting text across sections and deleting joins sections', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var firstSection = $('#editor p')[0],\n        secondSection = $('#editor p')[1];\n\n    _testHelpers['default'].dom.selectText(editor, 't section', firstSection, 'second s', secondSection);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('p:contains(firsection)');\n    assert.hasNoElement('p:contains(first section)');\n    assert.hasNoElement('p:contains(second section)');\n    assert.equal($('#editor p').length, 1, 'only 1 section after deleting to join');\n  });\n\n  test('selecting text across markers and deleting joins markers', function (assert) {\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'rst sect', editorElement);\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n\n    var firstTextNode = editorElement.childNodes[0] // p\n    .childNodes[1] // b\n    .childNodes[0]; // textNode containing \"rst sect\"\n    var secondTextNode = editorElement.childNodes[0] // p\n    .childNodes[2]; // textNode containing \"ion\"\n\n    assert.equal(firstTextNode.textContent, 'rst sect', 'correct first text node');\n    assert.equal(secondTextNode.textContent, 'ion', 'correct second text node');\n    _testHelpers['default'].dom.selectText(editor, 't sect', firstTextNode, 'ion', secondTextNode);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('p:contains(firs)', 'deletes across markers');\n    assert.hasElement('strong:contains(rs)', 'maintains bold text');\n\n    firstTextNode = editorElement.childNodes[0] // p\n    .childNodes[1] // b\n    .childNodes[0]; // textNode now containing \"rs\"\n\n    assert.deepEqual(_testHelpers['default'].dom.getCursorPosition(), { node: firstTextNode, offset: 2 });\n  });\n\n  test('select text and apply markup multiple times', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 't sect', editorElement);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n\n    _testHelpers['default'].dom.selectText(editor, 'fir', editorElement);\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n\n    assert.hasElement('p:contains(first section)', 'correct first section');\n    assert.hasElement('strong:contains(fir)', 'strong \"fir\"');\n    assert.hasElement('strong:contains(t sect)', 'strong \"t sect\"');\n  });\n\n  test('selecting text across markers deletes intermediary markers', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n      var markup = _ref.markup;\n\n      return post([markupSection('p', [marker('abc'), marker('123', [markup('strong')]), marker('def')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var textNode1 = editorElement.childNodes[0].childNodes[0],\n        textNode2 = editorElement.childNodes[0].childNodes[2];\n\n    assert.equal(textNode1.textContent, 'abc', 'precond - text node 1');\n    assert.equal(textNode2.textContent, 'def', 'precond - text node 2');\n    _testHelpers['default'].dom.selectText(editor, 'b', textNode1, 'e', textNode2);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('p:contains(af)', 'has remaining first section');\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.hasElement('p:contains(aXf)', 'inserts text at correct place');\n  });\n\n  test('deleting text across markers preserves node after', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n      var markup = _ref2.markup;\n\n      return post([markupSection('p', [marker('abc'), marker('123', [markup('strong')]), marker('def')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var textNode1 = editorElement.childNodes[0].childNodes[0],\n        textNode2 = editorElement.childNodes[0].childNodes[1];\n    assert.equal(textNode1.textContent, 'abc', 'precond -text node 1');\n    assert.equal(textNode2.textContent, '123', 'precond -text node 2');\n\n    _testHelpers['default'].dom.selectText(editor, 'b', editorElement, '2', editorElement);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal(editorElement.childNodes[0].textContent, 'a3def', 'has remaining first section');\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    assert.equal(editorElement.childNodes[0].textContent, 'aX3def', 'inserts text at correct spot');\n  });\n\n  test('selecting text across sections and hitting enter deletes and moves cursor to last selected section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var firstSection = $('#editor p:eq(0)')[0],\n        secondSection = $('#editor p:eq(1)')[0];\n\n    _testHelpers['default'].dom.selectText(editor, ' section', firstSection, 'second ', secondSection);\n\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 2, 'still 2 sections');\n    assert.equal($('#editor p:eq(0)').text(), 'first', 'correct text in 1st section');\n    assert.equal($('#editor p:eq(1)').text(), 'section', 'correct text in 2nd section');\n\n    var secondSectionTextNode = editor.element.childNodes[1].childNodes[0];\n    assert.deepEqual(_testHelpers['default'].dom.getCursorPosition(), { node: secondSectionTextNode, offset: 0 }, 'cursor is at start of second section');\n  });\n\n  test('keystroke of printable character while text is selected deletes the text', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'first section', editorElement);\n\n    editor.run(function (postEditor) {\n      editor.activeSections.forEach(function (section) {\n        postEditor.changeSectionTagName(section, 'h2');\n      });\n    });\n\n    assert.ok($('#editor h2:contains(first section)').length, 'first section is a heading');\n\n    var firstSectionTextNode = editorElement.childNodes[0].childNodes[0];\n    var secondSectionTextNode = editorElement.childNodes[1].childNodes[0];\n    _testHelpers['default'].dom.selectText(editor, 'section', firstSectionTextNode, 'secon', secondSectionTextNode);\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    assert.ok($('#editor h2:contains(first Xd section)').length, 'updates the section');\n  });\n\n  test('selecting text bounded by space and typing replaces it', function (assert) {\n    var done = assert.async();\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWithSection });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'trick', editorElement);\n    _testHelpers['default'].dom.insertText(editor, 'X');\n    _testHelpers['default'].wait(function () {\n      assert.equal(editor.post.sections.head.text, 'one X pony', 'new text present');\n\n      _testHelpers['default'].dom.insertText(editor, 'Y');\n      _testHelpers['default'].wait(function () {\n        assert.equal(editor.post.sections.head.text, 'one XY pony', 'further new text present');\n        done();\n      });\n    });\n  });\n\n  test('selecting all text across sections and hitting enter deletes and moves cursor to empty section', function (assert) {\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobileDocWith2Sections });\n    editor.render(editorElement);\n\n    var firstSection = $('#editor p:eq(0)')[0],\n        secondSection = $('#editor p:eq(1)')[0];\n\n    _testHelpers['default'].dom.selectText(editor, 'first section', firstSection, 'second section', secondSection);\n\n    _testHelpers['default'].dom.triggerEnter(editor);\n\n    assert.equal($('#editor p').length, 1, 'single section');\n    assert.equal($('#editor p:eq(0)').text(), '', 'blank text');\n\n    // Firefox reports that the cursor is on the \"<br>\", but Safari and Chrome do not.\n    // Grab the selection here, then set it to the expected value, and compare again\n    // the window's selection\n    var selection = window.getSelection();\n    var cursorElement = $('#editor p br')[0];\n    assert.ok(cursorElement, 'has cursor element');\n    _testHelpers['default'].dom.selectRange(cursorElement, 0, cursorElement, 0);\n    var newSelection = window.getSelection();\n    assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');\n    assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');\n    assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');\n    assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');\n  });\n\n  test('selecting text across markup and list sections', function (assert) {\n    var build = _testHelpers['default'].mobiledoc.build;\n    var mobiledoc = build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var listSection = _ref3.listSection;\n      var listItem = _ref3.listItem;\n      var marker = _ref3.marker;\n      return post([markupSection('p', [marker('abc')]), listSection('ul', [listItem([marker('123')]), listItem([marker('456')])])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement, '12', editorElement);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor p:contains(a3)', 'combines partially-selected list item onto markup section');\n\n    assert.hasNoElement('#editor p:contains(bc)', 'deletes selected text \"bc\"');\n    assert.hasNoElement('#editor p:contains(12)', 'deletes selected text \"12\"');\n\n    assert.hasElement('#editor li:contains(6)', 'leaves remaining text in list item');\n  });\n\n  test('selecting text that covers a list section', function (assert) {\n    var build = _testHelpers['default'].mobiledoc.build;\n    var mobiledoc = build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var listSection = _ref4.listSection;\n      var listItem = _ref4.listItem;\n      var marker = _ref4.marker;\n      return post([markupSection('p', [marker('abc')]), listSection('ul', [listItem([marker('123')]), listItem([marker('456')])]), markupSection('p', [marker('def')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement, 'de', editorElement);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor p:contains(af)', 'combines sides of selection');\n\n    assert.hasNoElement('#editor li:contains(123)', 'deletes li 1');\n    assert.hasNoElement('#editor li:contains(456)', 'deletes li 2');\n    assert.hasNoElement('#editor ul', 'removes ul');\n  });\n\n  test('selecting text that starts in a list item and ends in a markup section', function (assert) {\n    var build = _testHelpers['default'].mobiledoc.build;\n    var mobiledoc = build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var listSection = _ref5.listSection;\n      var listItem = _ref5.listItem;\n      var marker = _ref5.marker;\n      return post([listSection('ul', [listItem([marker('123')]), listItem([marker('456')])]), markupSection('p', [marker('def')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, '23', editorElement, 'de', editorElement);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor li:contains(1f)', 'combines sides of selection');\n\n    assert.hasNoElement('#editor li:contains(123)', 'deletes li 1');\n    assert.hasNoElement('#editor li:contains(456)', 'deletes li 2');\n    assert.hasNoElement('#editor p:contains(def)', 'deletes p content');\n    assert.hasNoElement('#editor p', 'removes p entirely');\n  });\n\n  test('selecting text that includes a card section and deleting deletes card section', function (assert) {\n    var build = _testHelpers['default'].mobiledoc.build;\n    var mobiledoc = build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var cardSection = _ref6.cardSection;\n      var marker = _ref6.marker;\n      return post([markupSection('p', [marker('abc')]), cardSection('simple-card'), markupSection('p', [marker('def')])]);\n    });\n    var cards = [{\n      name: 'simple-card',\n      type: 'dom',\n      render: function render() {\n        return $('<span id=\"card-el\"></span>')[0];\n      }\n    }];\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: cards });\n    editor.render(editorElement);\n\n    assert.hasElement('#card-el', 'precond - card el is rendered');\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement, 'de', editorElement);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor p:contains(af)', 'combines sides of selection');\n\n    assert.hasNoElement('#editor span#card-el', 'card el is removed');\n    assert.hasNoElement('#editor p:contains(abc)', 'previous section 1 is removed');\n    assert.hasNoElement('#editor p:contains(def)', 'previous section 2 is removed');\n  });\n\n  test('selecting text that touches bold text should not be considered bold', function (assert) {\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.selectText(editor, 'b', editorElement);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n\n    assert.hasElement('#editor strong:contains(b)', 'precond - bold text');\n\n    _testHelpers['default'].dom.selectText(editor, 'c', editorElement);\n    _testHelpers['default'].dom.triggerEvent(document, 'mouseup');\n\n    var bold = editor.builder.createMarkup('strong');\n    assert.ok(editor.activeMarkups.indexOf(bold) === -1, 'strong is not in selection');\n  });\n\n  // https://github.com/bustle/mobiledoc-kit/issues/121\n  test('selecting text that includes a 1-character marker and unbolding it', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n      var markup = _ref8.markup;\n\n      var b = markup('strong');\n      return post([markupSection('p', [marker('a'), marker('b', [b]), marker('c')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor strong:contains(b)', 'precond - bold');\n\n    _testHelpers['default'].dom.selectText(editor, 'b', editorElement, 'c', editorElement);\n\n    var bold = editor.builder.createMarkup('strong');\n    assert.ok(editor.activeMarkups.indexOf(bold) !== -1, 'strong is in selection');\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n\n    assert.hasNoElement('#editor strong', 'bold text is unboldened');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/128\n  test('selecting text that includes an empty section and applying markup to it', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    // precond\n    assert.hasElement('#editor p:contains(abc)');\n    assert.ok($('#editor p:eq(1)').text() === '', 'no text in second p');\n    var t1 = $('#editor p:eq(0)')[0].childNodes[0];\n    assert.equal(t1.textContent, 'abc', 'correct text node');\n    var p2 = $('#editor p:eq(1)')[0];\n\n    _testHelpers['default'].dom.moveCursorTo(editor, t1, 0, p2, 0);\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('strong');\n    });\n\n    assert.hasElement('#editor p strong:contains(abc)', 'bold is applied to text');\n  });\n\n  test('placing cursor inside a strong section should cause activeMarkups to contain \"strong\"', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n      var markup = _ref10.markup;\n\n      var b = markup('strong');\n      return post([markupSection('p', [marker('before'), marker('loud', [b]), marker('after')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, $('#editor strong')[0].firstChild, 1);\n\n    var bold = editor.builder.createMarkup('strong');\n    assert.ok(editor.activeMarkups.indexOf(bold) !== -1, 'strong is in selection');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, $('#editor')[0].childNodes[0], 1);\n    delete editor._activeMarkups;\n\n    assert.ok(editor.activeMarkups.indexOf(bold) === -1, 'strong is not in selection');\n  });\n});","define('tests/acceptance/editor-undo-redo-test', ['exports', 'mobiledoc-kit/utils/key', '../test-helpers'], function (exports, _mobiledocKitUtilsKey, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var undoBlockTimeout = 2000;\n\n  var editor = undefined,\n      editorElement = undefined,\n      oldDateNow = undefined;\n\n  function undo(editor) {\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'Z', [_mobiledocKitUtilsKey.MODIFIERS.META]);\n  }\n\n  function redo(editor) {\n    _testHelpers['default'].dom.triggerKeyCommand(editor, 'Z', [_mobiledocKitUtilsKey.MODIFIERS.META, _mobiledocKitUtilsKey.MODIFIERS.SHIFT]);\n  }\n\n  _module('Acceptance: Editor: Undo/Redo', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n      oldDateNow = Date.now;\n    },\n    afterEach: function afterEach() {\n      Date.now = oldDateNow;\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('undo/redo the insertion of a character', function (assert) {\n    var done = assert.async();\n    var expectedBeforeUndo = undefined,\n        expectedAfterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      expectedBeforeUndo = post([markupSection('p', [marker('abcD')])]);\n      expectedAfterUndo = post([markupSection('p', [marker('abc')])]);\n      return expectedAfterUndo;\n    });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'abc');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'abc'.length);\n\n    _testHelpers['default'].dom.insertText(editor, 'D');\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expectedBeforeUndo); // precond\n      undo(editor);\n      assert.postIsSimilar(editor.post, expectedAfterUndo);\n      assert.renderTreeIsEqual(editor._renderTree, expectedAfterUndo);\n\n      var position = editor.range.head;\n      assert.positionIsEqual(position, editor.post.sections.head.tailPosition());\n\n      redo(editor);\n\n      assert.postIsSimilar(editor.post, expectedBeforeUndo);\n      assert.renderTreeIsEqual(editor._renderTree, expectedBeforeUndo);\n\n      position = editor.range.head;\n      assert.positionIsEqual(position, editor.post.sections.head.tailPosition());\n\n      done();\n    });\n  });\n\n  // Test to ensure that we don't push empty snapshots on the undo stack\n  // when typing characters\n  test('undo/redo the insertion of multiple characters', function (assert) {\n    var done = assert.async();\n    var beforeUndo = undefined,\n        afterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      beforeUndo = post([markupSection('p', [marker('abcDE')])]);\n      afterUndo = post([markupSection('p', [marker('abc')])]);\n      return afterUndo;\n    });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'abc');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'abc'.length);\n\n    _testHelpers['default'].dom.insertText(editor, 'D');\n\n    _testHelpers['default'].wait(function () {\n      _testHelpers['default'].dom.insertText(editor, 'E');\n\n      _testHelpers['default'].wait(function () {\n        assert.postIsSimilar(editor.post, beforeUndo, 'precond - post was updated with new characters');\n\n        undo(editor);\n        assert.postIsSimilar(editor.post, afterUndo, 'ensure undo grouped to include both characters');\n\n        redo(editor);\n        assert.postIsSimilar(editor.post, beforeUndo, 'ensure redo grouped to include both characters');\n        done();\n      });\n    });\n  });\n\n  // Test to ensure that undo events group after a timeout\n  test('make sure undo/redo events group when adding text', function (assert) {\n    var done = assert.async();\n    var beforeUndo = undefined,\n        afterUndo1 = undefined,\n        afterUndo2 = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      beforeUndo = post([markupSection('p', [marker('123456789')])]);\n      afterUndo1 = post([markupSection('p', [marker('123456')])]);\n      afterUndo2 = post([markupSection('p', [marker('123')])]);\n      return afterUndo2;\n    }, { undoBlockTimeout: undoBlockTimeout });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, '123');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, '123'.length);\n\n    _testHelpers['default'].dom.insertText(editor, '4');\n\n    _testHelpers['default'].wait(function () {\n      _testHelpers['default'].dom.insertText(editor, '5');\n      _testHelpers['default'].wait(function () {\n        _testHelpers['default'].dom.insertText(editor, '6');\n        _testHelpers['default'].wait(function () {\n          Date.now = function () {\n            return oldDateNow.call(Date) + undoBlockTimeout + 1;\n          };\n          _testHelpers['default'].dom.insertText(editor, '7');\n          _testHelpers['default'].wait(function () {\n            _testHelpers['default'].dom.insertText(editor, '8');\n            _testHelpers['default'].wait(function () {\n              _testHelpers['default'].dom.insertText(editor, '9');\n              assert.postIsSimilar(editor.post, beforeUndo);\n\n              undo(editor);\n              assert.postIsSimilar(editor.post, afterUndo1);\n\n              undo(editor);\n              assert.postIsSimilar(editor.post, afterUndo2);\n\n              redo(editor);\n              assert.postIsSimilar(editor.post, afterUndo1);\n              done();\n            });\n          });\n        });\n      });\n    });\n  });\n\n  test('make sure undo/redo events group when deleting text', function (assert) {\n    var done = assert.async();\n    var beforeUndo = undefined,\n        afterUndo1 = undefined,\n        afterUndo2 = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      beforeUndo = post([markupSection('p', [marker('123')])]);\n      afterUndo1 = post([markupSection('p', [marker('123456')])]);\n      afterUndo2 = post([markupSection('p', [marker('123456789')])]);\n      return afterUndo2;\n    }, { undoBlockTimeout: undoBlockTimeout });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, '123456789');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, '123456789'.length);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n    _testHelpers['default'].dom.triggerDelete(editor);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    _testHelpers['default'].wait(function () {\n      Date.now = function () {\n        return oldDateNow.call(Date) + undoBlockTimeout + 1;\n      };\n\n      _testHelpers['default'].dom.triggerDelete(editor);\n      _testHelpers['default'].dom.triggerDelete(editor);\n      _testHelpers['default'].dom.triggerDelete(editor);\n\n      assert.postIsSimilar(editor.post, beforeUndo);\n\n      undo(editor);\n      assert.postIsSimilar(editor.post, afterUndo1);\n\n      undo(editor);\n      assert.postIsSimilar(editor.post, afterUndo2);\n\n      redo(editor);\n      assert.postIsSimilar(editor.post, afterUndo1);\n      done();\n    });\n  });\n\n  test('adding and deleting characters break the undo group/run', function (assert) {\n    var beforeUndo = undefined,\n        afterUndo1 = undefined,\n        afterUndo2 = undefined;\n    var done = assert.async();\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n\n      beforeUndo = post([markupSection('p', [marker('abcXY')])]);\n      afterUndo1 = post([markupSection('p', [marker('abc')])]);\n      afterUndo2 = post([markupSection('p', [marker('abcDE')])]);\n      return afterUndo2;\n    });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'abcDE');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'abcDE'.length);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    _testHelpers['default'].dom.insertText(editor, 'X');\n\n    _testHelpers['default'].wait(function () {\n      _testHelpers['default'].dom.insertText(editor, 'Y');\n\n      _testHelpers['default'].wait(function () {\n        assert.postIsSimilar(editor.post, beforeUndo); // precond\n\n        undo(editor);\n        assert.postIsSimilar(editor.post, afterUndo1);\n\n        undo(editor);\n        assert.postIsSimilar(editor.post, afterUndo2);\n\n        redo(editor);\n        assert.postIsSimilar(editor.post, afterUndo1);\n\n        redo(editor);\n        assert.postIsSimilar(editor.post, beforeUndo);\n        done();\n      });\n    });\n  });\n\n  test('undo the deletion of a character', function (assert) {\n    var expectedBeforeUndo = undefined,\n        expectedAfterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n\n      expectedBeforeUndo = post([markupSection('p', [marker('abc')])]);\n      expectedAfterUndo = post([markupSection('p', [marker('abcD')])]);\n      return expectedAfterUndo;\n    });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'abcD');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'abcD'.length);\n\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.postIsSimilar(editor.post, expectedBeforeUndo); // precond\n\n    undo(editor);\n    assert.postIsSimilar(editor.post, expectedAfterUndo);\n    assert.renderTreeIsEqual(editor._renderTree, expectedAfterUndo);\n    var position = editor.range.head;\n    assert.positionIsEqual(position, editor.post.sections.head.tailPosition());\n\n    redo(editor);\n    assert.postIsSimilar(editor.post, expectedBeforeUndo);\n    assert.renderTreeIsEqual(editor._renderTree, expectedBeforeUndo);\n    position = editor.range.head;\n    assert.positionIsEqual(position, editor.post.sections.head.tailPosition());\n  });\n\n  test('undo the deletion of a range', function (assert) {\n    var expectedBeforeUndo = undefined,\n        expectedAfterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      expectedBeforeUndo = post([markupSection('p', [marker('ad')])]);\n      expectedAfterUndo = post([markupSection('p', [marker('abcd')])]);\n      return expectedAfterUndo;\n    });\n\n    _testHelpers['default'].dom.selectText(editor, 'bc', editorElement);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.postIsSimilar(editor.post, expectedBeforeUndo); // precond\n\n    undo(editor);\n    assert.postIsSimilar(editor.post, expectedAfterUndo);\n    assert.renderTreeIsEqual(editor._renderTree, expectedAfterUndo);\n    var _editor$range = editor.range;\n    var head = _editor$range.head;\n    var tail = _editor$range.tail;\n\n    var section = editor.post.sections.head;\n    assert.positionIsEqual(head, section.toPosition('a'.length));\n    assert.positionIsEqual(tail, section.toPosition('abc'.length));\n\n    redo(editor);\n    assert.postIsSimilar(editor.post, expectedBeforeUndo);\n    assert.renderTreeIsEqual(editor._renderTree, expectedBeforeUndo);\n    head = editor.range.head;\n    tail = editor.range.tail;\n    section = editor.post.sections.head;\n    assert.positionIsEqual(head, section.toPosition('a'.length));\n    assert.positionIsEqual(tail, section.toPosition('a'.length));\n  });\n\n  test('undo insertion of character to a list item', function (assert) {\n    var done = assert.async();\n    var expectedBeforeUndo = undefined,\n        expectedAfterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref8) {\n      var post = _ref8.post;\n      var listSection = _ref8.listSection;\n      var listItem = _ref8.listItem;\n      var marker = _ref8.marker;\n\n      expectedBeforeUndo = post([listSection('ul', [listItem([marker('abcD')])])]);\n      expectedAfterUndo = post([listSection('ul', [listItem([marker('abc')])])]);\n      return expectedAfterUndo;\n    });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'abc');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'abc'.length);\n    _testHelpers['default'].dom.insertText(editor, 'D');\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expectedBeforeUndo); // precond\n\n      undo(editor);\n      assert.postIsSimilar(editor.post, expectedAfterUndo);\n      assert.renderTreeIsEqual(editor._renderTree, expectedAfterUndo);\n      var _editor$range2 = editor.range;\n      var head = _editor$range2.head;\n      var tail = _editor$range2.tail;\n\n      var section = editor.post.sections.head.items.head;\n      assert.positionIsEqual(head, section.toPosition('abc'.length));\n      assert.positionIsEqual(tail, section.toPosition('abc'.length));\n\n      redo(editor);\n      assert.postIsSimilar(editor.post, expectedBeforeUndo);\n      assert.renderTreeIsEqual(editor._renderTree, expectedBeforeUndo);\n      head = editor.range.head;\n      tail = editor.range.tail;\n      section = editor.post.sections.head.items.head;\n      assert.positionIsEqual(head, section.toPosition('abcD'.length));\n      assert.positionIsEqual(tail, section.toPosition('abcD'.length));\n\n      done();\n    });\n  });\n\n  test('undo stack length can be configured (depth 1)', function (assert) {\n    var done = assert.async();\n    var editorOptions = { undoDepth: 1 };\n\n    var beforeUndo = undefined,\n        afterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      beforeUndo = post([markupSection('p', [marker('abcDE')])]);\n      afterUndo = post([markupSection('p', [marker('abc')])]);\n      return post([markupSection('p', [marker('abc')])]);\n    }, editorOptions);\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'abc');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'abc'.length);\n    _testHelpers['default'].dom.insertText(editor, 'D');\n\n    _testHelpers['default'].wait(function () {\n      _testHelpers['default'].dom.insertText(editor, 'E');\n\n      _testHelpers['default'].wait(function () {\n        assert.postIsSimilar(editor.post, beforeUndo); // precond\n\n        undo(editor);\n        assert.postIsSimilar(editor.post, afterUndo);\n        assert.renderTreeIsEqual(editor._renderTree, afterUndo);\n        assert.positionIsEqual(editor.range.head, editor.post.sections.head.tailPosition());\n\n        undo(editor);\n        assert.postIsSimilar(editor.post, afterUndo, 'second undo does not change post');\n        assert.renderTreeIsEqual(editor._renderTree, afterUndo);\n        assert.positionIsEqual(editor.range.head, editor.post.sections.head.tailPosition());\n\n        done();\n      });\n    });\n  });\n\n  test('undo stack length can be configured (depth 0)', function (assert) {\n    var done = assert.async();\n    var editorOptions = { undoDepth: 0 };\n\n    var beforeUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n\n      beforeUndo = post([markupSection('p', [marker('abcDE')])]);\n      return post([markupSection('p', [marker('abc')])]);\n    }, editorOptions);\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'abc');\n    _testHelpers['default'].dom.moveCursorTo(editor, textNode, 'abc'.length);\n    _testHelpers['default'].dom.insertText(editor, 'D');\n\n    _testHelpers['default'].wait(function () {\n      _testHelpers['default'].dom.insertText(editor, 'E');\n\n      _testHelpers['default'].wait(function () {\n        assert.postIsSimilar(editor.post, beforeUndo); // precond\n\n        undo(editor);\n        assert.postIsSimilar(editor.post, beforeUndo, 'nothing is undone');\n        assert.renderTreeIsEqual(editor._renderTree, beforeUndo);\n        assert.positionIsEqual(editor.range.head, editor.post.sections.head.tailPosition());\n\n        done();\n      });\n    });\n  });\n\n  test('taking and restoring a snapshot with no cursor', function (assert) {\n    var beforeUndo = undefined,\n        afterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n\n      beforeUndo = post([markupSection('p', [marker('abc')])]);\n      afterUndo = post([markupSection('p', [])]);\n      return afterUndo;\n    }, { autofocus: false });\n\n    assert.ok(!editor.cursor.hasCursor(), 'precond - no cursor');\n    editor.run(function (postEditor) {\n      postEditor.insertText(editor.post.headPosition(), 'abc');\n    });\n    assert.postIsSimilar(editor.post, beforeUndo, 'precond - text is added');\n\n    undo(editor);\n    assert.postIsSimilar(editor.post, afterUndo, 'text is removed');\n  });\n\n  test('take and undo a snapshot based on drag/dropping of text', function (assert) {\n    var done = assert.async();\n    var text = 'abc';\n    var beforeUndo = undefined,\n        afterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref12) {\n      var post = _ref12.post;\n      var markupSection = _ref12.markupSection;\n      var marker = _ref12.marker;\n\n      beforeUndo = post([markupSection('p', [marker(text)])]);\n      afterUndo = post([markupSection('p', [marker('a')])]);\n      return afterUndo;\n    });\n\n    var textNode = _testHelpers['default'].dom.findTextNode(editorElement, 'a');\n    textNode.textContent = text;\n\n    // Allow the mutation observer to fire, then...\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, beforeUndo, 'precond - text is added');\n      undo(editor);\n      assert.postIsSimilar(editor.post, afterUndo, 'text is removed');\n      done();\n    });\n  });\n\n  test('take and undo a snapshot when adding a card', function (assert) {\n    var text = 'abc';\n    var myCard = {\n      name: 'my-card',\n      type: 'dom',\n      render: function render() {\n        return document.createTextNode('card contents');\n      }\n    };\n\n    var beforeUndo = undefined,\n        afterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref13) {\n      var post = _ref13.post;\n      var markupSection = _ref13.markupSection;\n      var marker = _ref13.marker;\n      var cardSection = _ref13.cardSection;\n\n      beforeUndo = post([markupSection('p', [marker(text)]), cardSection('my-card', {})]);\n      afterUndo = post([markupSection('p', [marker(text)])]);\n      return afterUndo;\n    }, {\n      cards: [myCard]\n    });\n\n    editor.run(function (postEditor) {\n      var card = editor.builder.createCardSection('my-card', {});\n      postEditor.insertSectionBefore(editor.post.sections, card, null);\n    });\n\n    assert.postIsSimilar(editor.post, beforeUndo, 'precond - card is added');\n    undo(editor);\n    assert.postIsSimilar(editor.post, afterUndo, 'card is removed');\n  });\n\n  test('take and undo a snapshot when removing an atom', function (assert) {\n    var text = 'abc';\n    var myAtom = {\n      name: 'my-atom',\n      type: 'dom',\n      render: function render() {\n        return document.createTextNode('atom contents');\n      }\n    };\n\n    var beforeUndo = undefined,\n        afterUndo = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref14) {\n      var post = _ref14.post;\n      var markupSection = _ref14.markupSection;\n      var marker = _ref14.marker;\n      var atom = _ref14.atom;\n\n      beforeUndo = post([markupSection('p', [marker(text)])]);\n      afterUndo = post([markupSection('p', [marker(text), atom('my-atom', 'content', {})])]);\n      return afterUndo;\n    }, {\n      atoms: [myAtom]\n    });\n\n    editor.run(function (postEditor) {\n      postEditor.removeMarker(editor.post.sections.head.markers.tail);\n    });\n\n    assert.postIsSimilar(editor.post, beforeUndo, 'precond - atom is removed');\n    undo(editor);\n    assert.postIsSimilar(editor.post, afterUndo, 'atom is restored');\n  });\n});","QUnit.module('ESLint | tests/eslint/acceptance/basic-editor-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/basic-editor-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/cursor-movement-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/cursor-movement-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/cursor-position-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/cursor-position-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-atoms-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-atoms-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-cards-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-cards-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-copy-paste-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-copy-paste-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-disable-editing-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-disable-editing-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-drag-drop-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-drag-drop-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-input-handlers-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-input-handlers-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-key-commands-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-key-commands-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-list-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-list-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-post-editor-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-post-editor-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-reparse-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-reparse-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-sections-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-sections-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-selections-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-selections-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/acceptance/editor-undo-redo-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/acceptance/editor-undo-redo-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/fixtures/google-docs.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/fixtures/google-docs.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/assertions.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/assertions.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/browsers.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/browsers.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/dom.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/dom.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/editor.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/editor.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/mobiledoc.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/mobiledoc.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/mock-editor.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/mock-editor.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/module-load-failure.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/module-load-failure.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/post-abstract.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/post-abstract.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/post-editor-run.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/post-editor-run.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/render-built-abstract.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/render-built-abstract.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/helpers/wait.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/helpers/wait.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/cards/image.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/cards/image.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/edit-history.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/edit-history.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/edit-state.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/edit-state.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/editor.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/editor.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/event-manager.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/event-manager.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/key-commands.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/key-commands.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/mutation-handler.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/mutation-handler.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/post.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/post.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/post/post-inserter.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/post/post-inserter.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/selection-change-observer.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/selection-change-observer.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/selection-manager.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/selection-manager.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/text-input-handler.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/text-input-handler.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/text-input-handlers.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/text-input-handlers.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/editor/ui.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/editor/ui.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/index.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/index.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/_markerable.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/_markerable.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/_section.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/_section.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/atom-node.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/atom-node.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/atom.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/atom.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/card-node.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/card-node.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/card.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/card.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/image.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/image.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/lifecycle-callbacks.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/lifecycle-callbacks.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/list-item.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/list-item.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/list-section.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/list-section.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/marker.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/marker.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/markup-section.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/markup-section.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/markup.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/markup.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/post-node-builder.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/post-node-builder.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/post.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/post.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/render-node.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/render-node.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/render-tree.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/render-tree.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/models/types.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/models/types.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/dom.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/dom.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/html.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/html.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/mobiledoc/0-2.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/mobiledoc/0-2.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/mobiledoc/0-3-1.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/mobiledoc/0-3-1.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/mobiledoc/0-3.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/mobiledoc/0-3.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/mobiledoc/index.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/mobiledoc/index.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/section.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/section.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/parsers/text.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/parsers/text.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/renderers/editor-dom.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/renderers/editor-dom.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/renderers/mobiledoc/0-2.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/renderers/mobiledoc/0-2.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/renderers/mobiledoc/0-3-1.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/renderers/mobiledoc/0-3-1.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/renderers/mobiledoc/0-3.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/renderers/mobiledoc/0-3.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/renderers/mobiledoc/index.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/renderers/mobiledoc/index.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/array-utils.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/array-utils.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/assert.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/assert.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/browser.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/browser.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/characters.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/characters.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/compiler.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/compiler.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/copy.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/copy.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/cursor.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/cursor.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/cursor/position.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/cursor/position.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/cursor/range.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/cursor/range.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/deprecate.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/deprecate.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/dom-utils.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/dom-utils.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/element-map.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/element-map.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/element-utils.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/element-utils.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/environment.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/environment.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/fixed-queue.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/fixed-queue.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/key.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/key.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/keycodes.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/keycodes.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/keys.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/keys.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/linked-item.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/linked-item.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/linked-list.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/linked-list.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/log-manager.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/log-manager.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/markuperable.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/markuperable.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/merge.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/merge.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/mixin.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/mixin.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/mobiledoc-error.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/mobiledoc-error.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/parse-utils.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/parse-utils.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/placeholder-image-src.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/placeholder-image-src.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/selection-utils.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/selection-utils.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/set.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/set.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/string-utils.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/string-utils.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/utils/to-range.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/utils/to-range.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/version.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/version.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/views/tooltip.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/views/tooltip.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/js/views/view.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/js/views/view.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/test-helpers.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/test-helpers.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/atom-lifecycle-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/atom-lifecycle-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/card-lifecycle-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/card-lifecycle-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/editor-events-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/editor-events-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/editor-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/editor-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/key-commands-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/key-commands-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/post-delete-at-position-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/post-delete-at-position-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/post-delete-range-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/post-delete-range-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/post-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/post-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/post/insert-post-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/post/insert-post-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/editor/ui-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/editor/ui-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/atom-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/atom-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/card-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/card-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/lifecycle-callbacks-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/lifecycle-callbacks-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/list-section-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/list-section-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/marker-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/marker-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/markup-section-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/markup-section-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/post-node-builder-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/post-node-builder-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/models/post-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/models/post-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/dom-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/dom-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/html-google-docs-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/html-google-docs-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/html-google-sheets-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/html-google-sheets-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/html-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/html-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/mobiledoc-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/mobiledoc-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/mobiledoc/0-2-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/mobiledoc/0-2-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/mobiledoc/0-3-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/mobiledoc/0-3-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/section-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/section-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/parsers/text-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/parsers/text-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/renderers/editor-dom-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/renderers/editor-dom-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/renderers/mobiledoc-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/renderers/mobiledoc-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/renderers/mobiledoc/0-2-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/renderers/mobiledoc/0-2-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/renderers/mobiledoc/0-3-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/renderers/mobiledoc/0-3-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/array-utils-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/array-utils-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/assert-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/assert-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/copy-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/copy-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/cursor-position-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/cursor-position-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/cursor-range-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/cursor-range-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/fixed-queue-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/fixed-queue-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/key-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/key-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/linked-list-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/linked-list-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/parse-utils-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/parse-utils-test.js should pass ESLint\\n\\n');\n});\n","QUnit.module('ESLint | tests/eslint/unit/utils/selection-utils-test.js');\nQUnit.test('should pass ESLint', function(assert) {\n  assert.expect(1);\n  assert.ok(true, 'tests/eslint/unit/utils/selection-utils-test.js should pass ESLint\\n\\n');\n});\n","define('tests/fixtures/google-docs', ['exports'], function (exports) {\n  'use strict';\n\n  exports['default'] = {\n    'simple paragraph as span': {\n      expected: \"<p>simple paragraph</p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-d75a90f6-8c07-deca-96cb-4b79c9ad7a7f\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">simple paragraph</span></b>'\n    },\n    'simple paragraph as span (Chrome - Windows)': {\n      expected: \"<p>simple paragraph</p>\",\n      raw: '<html><body><!--StartFragment--><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-af1f8f2c-cacc-6998-07a1-89da38d9c501\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#222222;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">simple paragraph</span></b><!--EndFragment--></body></html>'\n    },\n\n    // when selecting a line without including the end of the line, the html represention\n    // includes a <span> or series of <span>s\n    'paragraph with bold as span': {\n      expected: \"<p>paragraph with <strong>bold</strong></p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-d75a90f6-8c09-8dc9-fb2f-f7eb880e143d\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">paragraph with </span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">bold</span></b>'\n    },\n    'paragraph with bold as span (Chrome - Windows)': {\n      expected: \"<p>paragraph with <strong>bold</strong></p>\",\n      raw: '<html><body><!--StartFragment--><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-af1f8f2c-cacd-c884-b763-ee9510747969\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#222222;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">paragraph with </span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#222222;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">bold</span></b><!--EndFragment--></body></html>'\n    },\n\n    // when selecting a line that includes the end (using, e.g., shift+up to selection the entire line),\n    // the html representation includes a <p> tag\n    'paragraph with bold as p': {\n      expected: \"<p>A <strong>bold</strong> paragraph.<p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-e8f29cd6-9031-bb09-1958-dcc3dd34c237\"><p dir=\"ltr\" style=\"line-height:1.38;margin-top:0pt;margin-bottom:0pt;\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">A </span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">bold</span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\"> paragraph.</span></p></b><br class=\"Apple-interchange-newline\">'\n    },\n    'paragraph with italic as span': {\n      expected: \"<p>paragraph with <em>italic</em></p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-d75a90f6-8c15-20cb-c8cd-59f592dc8402\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">paragraph with </span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">italic</span></b>'\n    },\n    'paragraph with bold + italic as p': {\n      expected: \"<p>And a second <strong>bold</strong> <em>italic</em> paragraph.\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-e8f29cd6-9038-f59a-421c-1c5303efdaf6\"><p dir=\"ltr\" style=\"line-height:1.38;margin-top:0pt;margin-bottom:0pt;\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">And a second </span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">bold</span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\"> </span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">italic</span><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\"> paragraph.</span></p></b><br class=\"Apple-interchange-newline\">'\n    },\n    '2 paragraphs as p': {\n      expected: \"<p>Paragraph 1</p><p>Paragraph 2</p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-d75a90f6-8c66-10b0-1c99-0210f64abe05\"><p dir=\"ltr\" style=\"line-height:1.38;margin-top:0pt;margin-bottom:0pt;\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">Paragraph 1</span></p><br><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">Paragraph 2</span></b>'\n    },\n    'h1 with h1 tag': {\n      expected: \"<h1>h1 text</h1>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-2f095724-903a-1280-b377-a2b08d38ffaa\"><h1 dir=\"ltr\" style=\"line-height:1.38;margin-top:20pt;margin-bottom:6pt;\"><span style=\"font-size:26.666666666666664px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">h1 text</span></h1></b>'\n    },\n    'paragraph with link as span': {\n      expected: \"<p>link to <a href='http://bustle.com'>bustle</a></p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-e8f29cd6-903c-08a3-cc9c-7841d9aa3871\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">link to </span><a href=\"http://bustle.com\" style=\"text-decoration:none;\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;vertical-align:baseline;white-space:pre-wrap;\">bustle</span></a></b>'\n    },\n    'paragraph with link as p': {\n      expected: \"<p>link to <a href='http://bustle.com'>bustle</a></p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-e8f29cd6-903b-12a4-6455-23c68a9eae95\"><p dir=\"ltr\" style=\"line-height:1.38;margin-top:0pt;margin-bottom:0pt;\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\">link to </span><a href=\"http://bustle.com\" style=\"text-decoration:none;\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;vertical-align:baseline;white-space:pre-wrap;\">bustle</span></a></p></b><br class=\"Apple-interchange-newline\">'\n    },\n    'img in span': {\n      expected: \"<p><img src='https://placehold.it/100x100'></p>\",\n      raw: '<meta charset=\\'utf-8\\'><meta charset=\"utf-8\"><b style=\"font-weight:normal;\" id=\"docs-internal-guid-7a3c9f90-a5c3-d3b6-425c-75b28c50bd7e\"><span style=\"font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;\"><img src=\"https://placehold.it/100x100\" width=\"500px;\" height=\"374px;\" style=\"border: none; transform: rotate(0.00rad); -webkit-transform: rotate(0.00rad);\"/></span></b>'\n    }\n  };\n});","define('tests/helpers/assertions', ['exports', './dom', 'mobiledoc-kit/renderers/mobiledoc', 'mobiledoc-kit/models/types'], function (exports, _dom, _mobiledocKitRenderersMobiledoc, _mobiledocKitModelsTypes) {\n  /* global QUnit, $ */\n\n  'use strict';\n\n  exports['default'] = registerAssertions;\n\n  function compareMarkers(actual, expected, assert, path, deepCompare) {\n    if (actual.value !== expected.value) {\n      assert.equal(actual.value, expected.value, 'wrong value at ' + path);\n    }\n    if (actual.markups.length !== expected.markups.length) {\n      assert.equal(actual.markups.length, expected.markups.length, 'wrong markups at ' + path);\n    }\n    if (deepCompare) {\n      actual.markups.forEach(function (markup, index) {\n        comparePostNode(markup, expected.markups[index], assert, path + ':' + index, deepCompare);\n      });\n    }\n  }\n\n  /* eslint-disable complexity */\n  function comparePostNode(actual, expected, assert) {\n    var path = arguments.length <= 3 || arguments[3] === undefined ? 'root' : arguments[3];\n    var deepCompare = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\n    if (!actual || !expected) {\n      assert.ok(!!actual, 'missing actual post node at ' + path);\n      assert.ok(!!expected, 'missing expected post node at ' + path);\n      return;\n    }\n    if (actual.type !== expected.type) {\n      assert.pushResult({\n        result: false,\n        actual: actual.type,\n        expected: expected.type,\n        message: 'wrong type at ' + path\n      });\n    }\n\n    switch (actual.type) {\n      case _mobiledocKitModelsTypes.POST_TYPE:\n        if (actual.sections.length !== expected.sections.length) {\n          assert.equal(actual.sections.length, expected.sections.length, 'wrong sections for post');\n        }\n        if (deepCompare) {\n          actual.sections.forEach(function (section, index) {\n            comparePostNode(section, expected.sections.objectAt(index), assert, path + ':' + index, deepCompare);\n          });\n        }\n        break;\n      case _mobiledocKitModelsTypes.ATOM_TYPE:\n        if (actual.name !== expected.name) {\n          assert.equal(actual.name, expected.name, 'wrong atom name at ' + path);\n        }\n        compareMarkers(actual, expected, assert, path, deepCompare);\n        break;\n      case _mobiledocKitModelsTypes.MARKER_TYPE:\n        compareMarkers(actual, expected, assert, path, deepCompare);\n        break;\n      case _mobiledocKitModelsTypes.MARKUP_SECTION_TYPE:\n      case _mobiledocKitModelsTypes.LIST_ITEM_TYPE:\n        if (actual.tagName !== expected.tagName) {\n          assert.equal(actual.tagName, expected.tagName, 'wrong tagName at ' + path);\n        }\n        if (actual.markers.length !== expected.markers.length) {\n          assert.equal(actual.markers.length, expected.markers.length, 'wrong markers at ' + path);\n        }\n        if (deepCompare) {\n          actual.markers.forEach(function (marker, index) {\n            comparePostNode(marker, expected.markers.objectAt(index), assert, path + ':' + index, deepCompare);\n          });\n        }\n        break;\n      case _mobiledocKitModelsTypes.CARD_TYPE:\n        if (actual.name !== expected.name) {\n          assert.equal(actual.name, expected.name, 'wrong card name at ' + path);\n        }\n        if (!QUnit.equiv(actual.payload, expected.payload)) {\n          assert.deepEqual(actual.payload, expected.payload, 'wrong card payload at ' + path);\n        }\n        break;\n      case _mobiledocKitModelsTypes.LIST_SECTION_TYPE:\n        if (actual.items.length !== expected.items.length) {\n          assert.equal(actual.items.length, expected.items.length, 'wrong items at ' + path);\n        }\n        if (deepCompare) {\n          actual.items.forEach(function (item, index) {\n            comparePostNode(item, expected.items.objectAt(index), assert, path + ':' + index, deepCompare);\n          });\n        }\n        break;\n      case _mobiledocKitModelsTypes.IMAGE_SECTION_TYPE:\n        if (actual.src !== expected.src) {\n          assert.equal(actual.src, expected.src, 'wrong image src at ' + path);\n        }\n        break;\n      case _mobiledocKitModelsTypes.MARKUP_TYPE:\n        if (actual.tagName !== expected.tagName) {\n          assert.equal(actual.tagName, expected.tagName, 'wrong tagName at ' + path);\n        }\n        if (!QUnit.equiv(actual.attributes, expected.attributes)) {\n          assert.deepEqual(actual.attributes, expected.attributes, 'wrong attributes at ' + path);\n        }\n        break;\n      default:\n        throw new Error('wrong type :' + actual.type);\n    }\n  }\n  /* eslint-enable complexity */\n\n  function registerAssertions(QUnit) {\n    QUnit.assert.isBlank = function (val) {\n      var message = arguments.length <= 1 || arguments[1] === undefined ? 'value is blank' : arguments[1];\n\n      this.pushResult({\n        result: val === null || val === undefined || val === '' || val === false,\n        actual: val + ' (typeof ' + typeof val + ')',\n        expected: 'null|undefined|\\'\\'|false',\n        message: message\n      });\n    };\n\n    QUnit.assert.hasElement = function (selector) {\n      var message = arguments.length <= 1 || arguments[1] === undefined ? 'hasElement \"' + selector + '\"' : arguments[1];\n      return (function () {\n        var found = $(selector);\n        this.pushResult({\n          result: found.length > 0,\n          actual: found.length + ' matches for \\'' + selector + '\\'',\n          expected: '>0 matches for \\'' + selector + '\\'',\n          message: message\n        });\n        return found;\n      }).apply(this, arguments);\n    };\n\n    QUnit.assert.hasNoElement = function (selector) {\n      var message = arguments.length <= 1 || arguments[1] === undefined ? 'hasNoElement \"' + selector + '\"' : arguments[1];\n      return (function () {\n        var found = $(selector);\n        this.pushResult({\n          result: found.length === 0,\n          actual: found.length + ' matches for \\'' + selector + '\\'',\n          expected: '0 matches for \\'' + selector + '\\'',\n          message: message\n        });\n        return found;\n      }).apply(this, arguments);\n    };\n\n    QUnit.assert.hasClass = function (element, className) {\n      var message = arguments.length <= 2 || arguments[2] === undefined ? 'element has class \"' + className + '\"' : arguments[2];\n      return (function () {\n        this.pushResult({\n          result: element.classList.contains(className),\n          actual: element.classList,\n          expected: className,\n          message: message\n        });\n      }).apply(this, arguments);\n    };\n\n    QUnit.assert.notHasClass = function (element, className) {\n      var message = arguments.length <= 2 || arguments[2] === undefined ? 'element has class \"' + className + '\"' : arguments[2];\n      return (function () {\n        this.pushResult({\n          result: !element.classList.contains(className),\n          actual: element.classList,\n          expected: className,\n          message: message\n        });\n      }).apply(this, arguments);\n    };\n\n    QUnit.assert.selectedText = function (text) {\n      var message = arguments.length <= 1 || arguments[1] === undefined ? 'selectedText \"' + text + '\"' : arguments[1];\n      return (function () {\n        var selected = _dom['default'].getSelectedText();\n        this.pushResult({\n          result: selected === text,\n          actual: selected,\n          expected: text,\n          message: message\n        });\n      }).apply(this, arguments);\n    };\n\n    QUnit.assert.inArray = function (element, array) {\n      var message = arguments.length <= 2 || arguments[2] === undefined ? 'has \"' + element + '\" in \"' + array + '\"' : arguments[2];\n      return (function () {\n        QUnit.assert.ok(array.indexOf(element) !== -1, message);\n      })();\n    };\n\n    QUnit.assert.postIsSimilar = function (post, expected) {\n      var postName = arguments.length <= 2 || arguments[2] === undefined ? 'post' : arguments[2];\n\n      comparePostNode(post, expected, this, postName, true);\n      var mobiledoc = _mobiledocKitRenderersMobiledoc['default'].render(post),\n          expectedMobiledoc = _mobiledocKitRenderersMobiledoc['default'].render(expected);\n      this.deepEqual(mobiledoc, expectedMobiledoc, postName + ' is similar to expected');\n    };\n\n    QUnit.assert.renderTreeIsEqual = function (renderTree, expectedPost) {\n      var _this = this;\n\n      if (renderTree.rootNode.isDirty) {\n        this.ok(false, 'renderTree is dirty');\n        return;\n      }\n\n      expectedPost.sections.forEach(function (section, index) {\n        var renderNode = renderTree.rootNode.childNodes.objectAt(index);\n        var path = 'post:' + index;\n\n        var compareChildren = function compareChildren(parentPostNode, parentRenderNode, path) {\n          var children = parentPostNode.markers || parentPostNode.items || [];\n\n          if (children.length !== parentRenderNode.childNodes.length) {\n            _this.equal(parentRenderNode.childNodes.length, children.length, 'wrong child render nodes at ' + path);\n            return;\n          }\n\n          children.forEach(function (child, index) {\n            var renderNode = parentRenderNode.childNodes.objectAt(index);\n\n            comparePostNode(child, renderNode && renderNode.postNode, _this, path + ':' + index, false);\n            compareChildren(child, renderNode, path + ':' + index);\n          });\n        };\n\n        comparePostNode(section, renderNode.postNode, _this, path, false);\n        compareChildren(section, renderNode, path);\n      });\n\n      this.ok(true, 'renderNode is similar');\n    };\n\n    QUnit.assert.positionIsEqual = function (position, expected) {\n      var message = arguments.length <= 2 || arguments[2] === undefined ? 'position is equal' : arguments[2];\n\n      if (position.section !== expected.section) {\n        this.pushResult({\n          result: false,\n          actual: position.section.type + ':' + position.section.tagName,\n          expected: expected.section.type + ':' + expected.section.tagName,\n          message: 'incorrect position section (' + message + ')'\n        });\n      } else if (position.offset !== expected.offset) {\n        this.pushResult({\n          result: false,\n          actual: position.offset,\n          expected: expected.offset,\n          message: 'incorrect position offset (' + message + ')'\n        });\n      } else {\n        this.pushResult({\n          result: true,\n          actual: position,\n          expected: expected,\n          message: message\n        });\n      }\n    };\n\n    QUnit.assert.rangeIsEqual = function (range, expected) {\n      var message = arguments.length <= 2 || arguments[2] === undefined ? 'range is equal' : arguments[2];\n      var head = range.head;\n      var tail = range.tail;\n      var isCollapsed = range.isCollapsed;\n      var direction = range.direction;\n      var expectedHead = expected.head;\n      var expectedTail = expected.tail;\n      var expectedIsCollapsed = expected.isCollapsed;\n      var expectedDirection = expected.direction;\n\n      var failed = false;\n\n      if (!head.isEqual(expectedHead)) {\n        failed = true;\n        this.pushResult({\n          result: false,\n          actual: head.section.type + ':' + head.section.tagName,\n          expected: expectedHead.section.type + ':' + expectedHead.section.tagName,\n          message: 'incorrect head position'\n        });\n      }\n\n      if (!tail.isEqual(expectedTail)) {\n        failed = true;\n        this.pushResult({\n          result: false,\n          actual: tail.section.type + ':' + tail.section.tagName,\n          expected: expectedTail.section.type + ':' + expectedTail.section.tagName,\n          message: 'incorrect tail position'\n        });\n      }\n\n      if (isCollapsed !== expectedIsCollapsed) {\n        failed = true;\n        this.pushResult({\n          result: false,\n          actual: isCollapsed,\n          expected: expectedIsCollapsed,\n          message: 'wrong value for isCollapsed'\n        });\n      }\n\n      if (direction !== expectedDirection) {\n        failed = true;\n        this.pushResult({\n          result: false,\n          actual: direction,\n          expected: expectedDirection,\n          message: 'wrong value for direction'\n        });\n      }\n\n      if (!failed) {\n        this.pushResult({\n          result: true,\n          actual: range,\n          expected: expected,\n          message: message\n        });\n      }\n    };\n  }\n});","define(\"tests/helpers/browsers\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  exports.detectIE = detectIE;\n  exports.detectIE11 = detectIE11;\n  exports.supportsSelectionExtend = supportsSelectionExtend;\n\n  function detectIE() {\n    var userAgent = navigator.userAgent;\n    return userAgent.indexOf(\"MSIE \") !== -1 || userAgent.indexOf(\"Trident/\") !== -1 || userAgent.indexOf('Edge/') !== -1;\n  }\n\n  function detectIE11() {\n    return detectIE() && navigator.userAgent.indexOf(\"rv:11.0\") !== -1;\n  }\n\n  function supportsSelectionExtend() {\n    var selection = window.getSelection();\n    return !!selection.extend;\n  }\n});","define('tests/helpers/dom', ['exports', 'mobiledoc-kit/utils/selection-utils', 'mobiledoc-kit/utils/array-utils', 'mobiledoc-kit/utils/keycodes', 'mobiledoc-kit/utils/key', 'mobiledoc-kit/utils/dom-utils', 'mobiledoc-kit/utils/merge', 'mobiledoc-kit', 'mobiledoc-kit/utils/parse-utils', 'mobiledoc-kit/utils/string-utils'], function (exports, _mobiledocKitUtilsSelectionUtils, _mobiledocKitUtilsArrayUtils, _mobiledocKitUtilsKeycodes, _mobiledocKitUtilsKey, _mobiledocKitUtilsDomUtils, _mobiledocKitUtilsMerge, _mobiledocKit, _mobiledocKitUtilsParseUtils, _mobiledocKitUtilsStringUtils) {\n  'use strict';\n\n  function assertEditor(editor) {\n    if (!(editor instanceof _mobiledocKit.Editor)) {\n      throw new Error('Must pass editor as first argument');\n    }\n  }\n\n  // walks DOWN the dom from node to childNodes, returning the element\n  // for which `conditionFn(element)` is true\n  function walkDOMUntil(topNode) {\n    var conditionFn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\n    if (!topNode) {\n      throw new Error('Cannot call walkDOMUntil without a node');\n    }\n    var stack = [topNode];\n    var currentElement = undefined;\n\n    while (stack.length) {\n      currentElement = stack.pop();\n\n      if (conditionFn(currentElement)) {\n        return currentElement;\n      }\n\n      (0, _mobiledocKitUtilsArrayUtils.forEach)(currentElement.childNodes, function (el) {\n        return stack.push(el);\n      });\n    }\n  }\n\n  function findTextNode(parentElement, text) {\n    return walkDOMUntil(parentElement, function (node) {\n      return (0, _mobiledocKitUtilsDomUtils.isTextNode)(node) && node.textContent.indexOf(text) !== -1;\n    });\n  }\n\n  function selectRange(startNode, startOffset, endNode, endOffset) {\n    (0, _mobiledocKitUtilsSelectionUtils.clearSelection)();\n\n    var range = document.createRange();\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n\n    var selection = window.getSelection();\n    selection.addRange(range);\n  }\n\n  function selectText(editor, startText) {\n    var startContainingElement = arguments.length <= 2 || arguments[2] === undefined ? editor.element : arguments[2];\n    var endText = arguments.length <= 3 || arguments[3] === undefined ? startText : arguments[3];\n    var endContainingElement = arguments.length <= 4 || arguments[4] === undefined ? startContainingElement : arguments[4];\n    return (function () {\n\n      assertEditor(editor);\n      var startTextNode = findTextNode(startContainingElement, startText);\n      var endTextNode = findTextNode(endContainingElement, endText);\n\n      if (!startTextNode) {\n        throw new Error('Could not find a starting textNode containing \"' + startText + '\"');\n      }\n      if (!endTextNode) {\n        throw new Error('Could not find an ending textNode containing \"' + endText + '\"');\n      }\n\n      var startOffset = startTextNode.textContent.indexOf(startText),\n          endOffset = endTextNode.textContent.indexOf(endText) + endText.length;\n      selectRange(startTextNode, startOffset, endTextNode, endOffset);\n      editor._readRangeFromDOM();\n    })();\n  }\n\n  function moveCursorWithoutNotifyingEditorTo(editor, node) {\n    var offset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n    var endNode = arguments.length <= 3 || arguments[3] === undefined ? node : arguments[3];\n    var endOffset = arguments.length <= 4 || arguments[4] === undefined ? offset : arguments[4];\n    return (function () {\n      selectRange(node, offset, endNode, endOffset);\n    })();\n  }\n\n  function moveCursorTo(editor, node) {\n    var offset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n    var endNode = arguments.length <= 3 || arguments[3] === undefined ? node : arguments[3];\n    var endOffset = arguments.length <= 4 || arguments[4] === undefined ? offset : arguments[4];\n    return (function () {\n      assertEditor(editor);\n      if (!node) {\n        throw new Error('Cannot moveCursorTo node without node');\n      }\n      moveCursorWithoutNotifyingEditorTo(editor, node, offset, endNode, endOffset);\n      editor._readRangeFromDOM();\n    })();\n  }\n\n  function triggerEvent(node, eventType) {\n    if (!node) {\n      throw new Error('Attempted to trigger event \"' + eventType + '\" on undefined node');\n    }\n\n    var clickEvent = document.createEvent('MouseEvents');\n    clickEvent.initEvent(eventType, true, true);\n    return node.dispatchEvent(clickEvent);\n  }\n\n  function _triggerEditorEvent(editor, event) {\n    editor.triggerEvent(editor.element, event.type, event);\n  }\n\n  function _buildDOM(tagName) {\n    var attributes = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    var children = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n    var el = document.createElement(tagName);\n    Object.keys(attributes).forEach(function (k) {\n      return el.setAttribute(k, attributes[k]);\n    });\n    children.forEach(function (child) {\n      return el.appendChild(child);\n    });\n    return el;\n  }\n\n  _buildDOM.text = function (string) {\n    return document.createTextNode(string);\n  };\n\n  /**\n   * Usage:\n   * build(t =>\n   *   t('div', attributes={}, children=[\n   *     t('b', {}, [\n   *       t.text('I am a bold text node')\n   *     ])\n   *   ])\n   * );\n   */\n  function build(tree) {\n    return tree(_buildDOM);\n  }\n\n  function getSelectedText() {\n    var selection = window.getSelection();\n    if (selection.rangeCount === 0) {\n      return null;\n    } else if (selection.rangeCount > 1) {\n      // FIXME?\n      throw new Error('Unable to get selected text for multiple ranges');\n    } else {\n      return selection.toString();\n    }\n  }\n\n  // returns the node and the offset that the cursor is on\n  function getCursorPosition() {\n    var selection = window.getSelection();\n    return {\n      node: selection.anchorNode,\n      offset: selection.anchorOffset\n    };\n  }\n\n  function createMockEvent(eventName, element) {\n    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var event = {\n      type: eventName,\n      preventDefault: function preventDefault() {},\n      target: element\n    };\n    (0, _mobiledocKitUtilsMerge.merge)(event, options);\n    return event;\n  }\n\n  // options is merged into the mocked `KeyboardEvent` data.\n  // Useful for simulating modifier keys, eg:\n  // triggerDelete(editor, DIRECTION.BACKWARD, {altKey: true})\n  function triggerDelete(editor) {\n    var direction = arguments.length <= 1 || arguments[1] === undefined ? _mobiledocKitUtilsKey.DIRECTION.BACKWARD : arguments[1];\n    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    assertEditor(editor);\n    var keyCode = direction === _mobiledocKitUtilsKey.DIRECTION.BACKWARD ? _mobiledocKitUtilsKeycodes['default'].BACKSPACE : _mobiledocKitUtilsKeycodes['default'].DELETE;\n    var eventOptions = (0, _mobiledocKitUtilsMerge.merge)({ keyCode: keyCode }, options);\n    var event = createMockEvent('keydown', editor.element, eventOptions);\n    _triggerEditorEvent(editor, event);\n  }\n\n  function triggerForwardDelete(editor, options) {\n    return triggerDelete(editor, _mobiledocKitUtilsKey.DIRECTION.FORWARD, options);\n  }\n\n  function triggerEnter(editor) {\n    assertEditor(editor);\n    var event = createMockEvent('keydown', editor.element, { keyCode: _mobiledocKitUtilsKeycodes['default'].ENTER });\n    _triggerEditorEvent(editor, event);\n  }\n\n  function triggerImeKeyDown(editor, key) {\n    assertEditor(editor);\n    var event = createMockEvent('keydown', editor.element, { key: key, keyCode: _mobiledocKitUtilsKeycodes['default'].IME });\n    _triggerEditorEvent(editor, event);\n  }\n\n  // keyCodes and charCodes are similar but not the same.\n  function keyCodeForChar(letter) {\n    var keyCode = undefined;\n    switch (letter) {\n      case '.':\n        keyCode = _mobiledocKitUtilsKeycodes['default']['.'];\n        break;\n      case '\\n':\n        keyCode = _mobiledocKitUtilsKeycodes['default'].ENTER;\n        break;\n      default:\n        keyCode = letter.charCodeAt(0);\n    }\n    return keyCode;\n  }\n\n  function insertText(editor, string) {\n    if (!string && editor) {\n      throw new Error('Must pass `editor` to `insertText`');\n    }\n\n    string.split('').forEach(function (letter) {\n      var stop = false;\n      var keyCode = keyCodeForChar(letter);\n      var charCode = letter.charCodeAt(0);\n      var preventDefault = function preventDefault() {\n        return stop = true;\n      };\n      var keydown = createMockEvent('keydown', editor.element, {\n        keyCode: keyCode,\n        charCode: charCode,\n        preventDefault: preventDefault\n      });\n      var keypress = createMockEvent('keypress', editor.element, {\n        keyCode: keyCode,\n        charCode: charCode\n      });\n      var keyup = createMockEvent('keyup', editor.element, {\n        keyCode: keyCode,\n        charCode: charCode,\n        preventDefault: preventDefault\n      });\n\n      _triggerEditorEvent(editor, keydown);\n      if (stop) {\n        return;\n      }\n      _triggerEditorEvent(editor, keypress);\n      if (stop) {\n        return;\n      }\n      _triggerEditorEvent(editor, keyup);\n    });\n  }\n\n  function triggerKeyEvent(editor, type, options) {\n    var event = createMockEvent(type, editor.element, options);\n    _triggerEditorEvent(editor, event);\n  }\n\n  // triggers a key sequence like cmd-B on the editor, to test out\n  // registered keyCommands\n  function triggerKeyCommand(editor, string) {\n    var modifiers = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n    if (typeof modifiers === \"number\") {\n      modifiers = [modifiers]; // convert singular to array\n    }\n    var charCode = _mobiledocKitUtilsKeycodes['default'][string] || string.toUpperCase().charCodeAt(0);\n    var keyCode = charCode;\n    var keyEvent = createMockEvent('keydown', editor.element, {\n      charCode: charCode,\n      keyCode: keyCode,\n      shiftKey: (0, _mobiledocKitUtilsArrayUtils.contains)(modifiers, _mobiledocKitUtilsKey.MODIFIERS.SHIFT),\n      metaKey: (0, _mobiledocKitUtilsArrayUtils.contains)(modifiers, _mobiledocKitUtilsKey.MODIFIERS.META),\n      ctrlKey: (0, _mobiledocKitUtilsArrayUtils.contains)(modifiers, _mobiledocKitUtilsKey.MODIFIERS.CTRL)\n    });\n    _triggerEditorEvent(editor, keyEvent);\n  }\n\n  function triggerRightArrowKey(editor, modifier) {\n    if (!(editor instanceof _mobiledocKit.Editor)) {\n      throw new Error('Must pass editor to triggerRightArrowKey');\n    }\n    var keydown = createMockEvent('keydown', editor.element, {\n      keyCode: _mobiledocKitUtilsKeycodes['default'].RIGHT,\n      shiftKey: modifier === _mobiledocKitUtilsKey.MODIFIERS.SHIFT\n    });\n    var keyup = createMockEvent('keyup', editor.element, {\n      keyCode: _mobiledocKitUtilsKeycodes['default'].RIGHT,\n      shiftKey: modifier === _mobiledocKitUtilsKey.MODIFIERS.SHIFT\n    });\n    _triggerEditorEvent(editor, keydown);\n    _triggerEditorEvent(editor, keyup);\n  }\n\n  function triggerLeftArrowKey(editor, modifier) {\n    assertEditor(editor);\n    var keydown = createMockEvent('keydown', editor.element, {\n      keyCode: _mobiledocKitUtilsKeycodes['default'].LEFT,\n      shiftKey: modifier === _mobiledocKitUtilsKey.MODIFIERS.SHIFT\n    });\n    var keyup = createMockEvent('keyup', editor.element, {\n      keyCode: _mobiledocKitUtilsKeycodes['default'].LEFT,\n      shiftKey: modifier === _mobiledocKitUtilsKey.MODIFIERS.SHIFT\n    });\n    _triggerEditorEvent(editor, keydown);\n    _triggerEditorEvent(editor, keyup);\n  }\n\n  // Allows our fake copy and paste events to communicate with each other.\n  var lastCopyData = {};\n  function triggerCopyEvent(editor) {\n    var eventData = {\n      clipboardData: {\n        setData: function setData(type, value) {\n          lastCopyData[type] = value;\n        }\n      }\n    };\n\n    var event = createMockEvent('copy', editor.element, eventData);\n    _triggerEditorEvent(editor, event);\n  }\n\n  function triggerCutEvent(editor) {\n    var event = createMockEvent('cut', editor.element, {\n      clipboardData: {\n        setData: function setData(type, value) {\n          lastCopyData[type] = value;\n        }\n      }\n    });\n    _triggerEditorEvent(editor, event);\n  }\n\n  function triggerPasteEvent(editor) {\n    var eventData = {\n      clipboardData: {\n        getData: function getData(type) {\n          return lastCopyData[type];\n        }\n      }\n    };\n\n    var event = createMockEvent('paste', editor.element, eventData);\n    _triggerEditorEvent(editor, event);\n  }\n\n  function triggerDropEvent(editor, _ref) {\n    var html = _ref.html;\n    var text = _ref.text;\n    var clientX = _ref.clientX;\n    var clientY = _ref.clientY;\n\n    if (!clientX || !clientY) {\n      throw new Error('Must pass clientX, clientY');\n    }\n    var event = createMockEvent('drop', editor.element, {\n      clientX: clientX,\n      clientY: clientY,\n      dataTransfer: {\n        getData: function getData(mimeType) {\n          switch (mimeType) {\n            case _mobiledocKitUtilsParseUtils.MIME_TEXT_HTML:\n              return html;\n            case _mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN:\n              return text;\n            default:\n              throw new Error('invalid mime type ' + mimeType);\n          }\n        }\n      }\n    });\n\n    _triggerEditorEvent(editor, event);\n  }\n\n  function getCopyData(type) {\n    return lastCopyData[type];\n  }\n\n  function setCopyData(type, value) {\n    lastCopyData[type] = value;\n  }\n\n  function clearCopyData() {\n    Object.keys(lastCopyData).forEach(function (key) {\n      delete lastCopyData[key];\n    });\n  }\n\n  function fromHTML(html) {\n    html = $.trim(html);\n    var div = document.createElement('div');\n    div.innerHTML = html;\n    return div;\n  }\n\n  /**\n   * Tests fail in IE when using `element.blur`, so remove focus by refocusing\n   * on another item instead of blurring the editor element\n   */\n  function blur() {\n    var input = $('<input>');\n    input.appendTo('#qunit-fixture');\n    input.focus();\n  }\n\n  function getData(element, name) {\n    if (element.dataset) {\n      return element.dataset[name];\n    } else {\n      return element.getAttribute((0, _mobiledocKitUtilsStringUtils.dasherize)(name));\n    }\n  }\n\n  var DOMHelper = {\n    moveCursorTo: moveCursorTo,\n    moveCursorWithoutNotifyingEditorTo: moveCursorWithoutNotifyingEditorTo,\n    selectRange: selectRange,\n    selectText: selectText,\n    clearSelection: _mobiledocKitUtilsSelectionUtils.clearSelection,\n    triggerEvent: triggerEvent,\n    build: build,\n    fromHTML: fromHTML,\n    KEY_CODES: _mobiledocKitUtilsKeycodes['default'],\n    getCursorPosition: getCursorPosition,\n    getSelectedText: getSelectedText,\n    triggerDelete: triggerDelete,\n    triggerForwardDelete: triggerForwardDelete,\n    triggerEnter: triggerEnter,\n    triggerImeKeyDown: triggerImeKeyDown,\n    insertText: insertText,\n    triggerKeyEvent: triggerKeyEvent,\n    triggerKeyCommand: triggerKeyCommand,\n    triggerRightArrowKey: triggerRightArrowKey,\n    triggerLeftArrowKey: triggerLeftArrowKey,\n    triggerCopyEvent: triggerCopyEvent,\n    triggerCutEvent: triggerCutEvent,\n    triggerPasteEvent: triggerPasteEvent,\n    triggerDropEvent: triggerDropEvent,\n    getCopyData: getCopyData,\n    setCopyData: setCopyData,\n    clearCopyData: clearCopyData,\n    createMockEvent: createMockEvent,\n    findTextNode: findTextNode,\n    blur: blur,\n    getData: getData\n  };\n\n  exports.triggerEvent = triggerEvent;\n  exports['default'] = DOMHelper;\n});","define('tests/helpers/editor', ['exports', './post-abstract', 'mobiledoc-kit/editor/editor', 'mobiledoc-kit/renderers/mobiledoc/0-3-1'], function (exports, _postAbstract, _mobiledocKitEditorEditor, _mobiledocKitRenderersMobiledoc031) {\n  'use strict';\n\n  function retargetPosition(position, toPost) {\n    var fromPost = position.section.post;\n    var sectionIndex = undefined;\n    var retargetedPosition = undefined;\n    fromPost.walkAllLeafSections(function (section, index) {\n      if (sectionIndex !== undefined) {\n        return;\n      }\n      if (section === position.section) {\n        sectionIndex = index;\n      }\n    });\n    if (sectionIndex === undefined) {\n      throw new Error('`retargetPosition` could not find section index');\n    }\n    toPost.walkAllLeafSections(function (section, index) {\n      if (retargetedPosition) {\n        return;\n      }\n      if (index === sectionIndex) {\n        retargetedPosition = section.toPosition(position.offset);\n      }\n    });\n    if (!retargetedPosition) {\n      throw new Error('`retargetPosition` could not find target section');\n    }\n    return retargetedPosition;\n  }\n\n  function retargetRange(range, toPost) {\n    var newHead = retargetPosition(range.head, toPost);\n    var newTail = retargetPosition(range.tail, toPost);\n\n    return newHead.toRange(newTail);\n  }\n\n  function buildFromText(texts) {\n    var editorOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var renderElement = editorOptions.element;\n    delete editorOptions.element;\n\n    var beforeRender = editorOptions.beforeRender || function () {};\n    delete editorOptions.beforeRender;\n\n    var _PostAbstractHelpers$buildFromText = _postAbstract['default'].buildFromText(texts);\n\n    var post = _PostAbstractHelpers$buildFromText.post;\n    var range = _PostAbstractHelpers$buildFromText.range;\n\n    var mobiledoc = _mobiledocKitRenderersMobiledoc031['default'].render(post);\n    editorOptions.mobiledoc = mobiledoc;\n    var editor = new _mobiledocKitEditorEditor['default'](editorOptions);\n    if (renderElement) {\n      beforeRender(editor);\n      editor.render(renderElement);\n      if (range) {\n        range = retargetRange(range, editor.post);\n        editor.selectRange(range);\n      }\n    }\n    return editor;\n  }\n\n  exports.buildFromText = buildFromText;\n  exports.retargetRange = retargetRange;\n  exports.retargetPosition = retargetPosition;\n});","define('tests/helpers/mobiledoc', ['exports', './post-abstract', 'mobiledoc-kit/renderers/mobiledoc', 'mobiledoc-kit/renderers/mobiledoc/0-2', 'mobiledoc-kit/renderers/mobiledoc/0-3', 'mobiledoc-kit/renderers/mobiledoc/0-3-1', 'mobiledoc-kit/editor/editor', 'mobiledoc-kit/utils/cursor/range', 'mobiledoc-kit/utils/merge'], function (exports, _postAbstract, _mobiledocKitRenderersMobiledoc, _mobiledocKitRenderersMobiledoc02, _mobiledocKitRenderersMobiledoc03, _mobiledocKitRenderersMobiledoc031, _mobiledocKitEditorEditor, _mobiledocKitUtilsCursorRange, _mobiledocKitUtilsMerge) {\n  'use strict';\n\n  /*\n   * usage:\n   *  build(({post, section, marker, markup}) =>\n   *    post([\n   *      section('P', [\n   *        marker('some text', [markup('B')])\n   *      ])\n   *    })\n   *  )\n   *  @return Mobiledoc\n   */\n  function build(treeFn, version) {\n    var post = _postAbstract['default'].build(treeFn);\n    switch (version) {\n      case _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION:\n        return _mobiledocKitRenderersMobiledoc02['default'].render(post);\n      case _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION:\n        return _mobiledocKitRenderersMobiledoc03['default'].render(post);\n      case _mobiledocKitRenderersMobiledoc031.MOBILEDOC_VERSION:\n        return _mobiledocKitRenderersMobiledoc031['default'].render(post);\n      case undefined:\n      case null:\n        return _mobiledocKitRenderersMobiledoc['default'].render(post);\n      default:\n        throw new Error('Unknown version of mobiledoc renderer requested: ' + version);\n    }\n  }\n\n  function renderPostInto(element, post) {\n    var editorOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var mobiledoc = _mobiledocKitRenderersMobiledoc['default'].render(post);\n    (0, _mobiledocKitUtilsMerge.mergeWithOptions)(editorOptions, { mobiledoc: mobiledoc });\n    var editor = new _mobiledocKitEditorEditor['default'](editorOptions);\n    editor.render(element);\n    return editor;\n  }\n\n  function renderInto(element, treeFn) {\n    var editorOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var mobiledoc = build(treeFn);\n    (0, _mobiledocKitUtilsMerge.mergeWithOptions)(editorOptions, { mobiledoc: mobiledoc });\n    var editor = new _mobiledocKitEditorEditor['default'](editorOptions);\n    editor.render(element);\n    return editor;\n  }\n\n  // In Firefox, if the window isn't active (which can happen when running tests\n  // at SauceLabs), the editor element won't have the selection. This helper method\n  // ensures that it has a cursor selection.\n  // See https://github.com/bustle/mobiledoc-kit/issues/388\n  function renderIntoAndFocusTail(editorElement, treeFn) {\n    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var editor = renderInto(editorElement, treeFn, options);\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n    return editor;\n  }\n\n  exports['default'] = {\n    build: build,\n    renderInto: renderInto,\n    renderPostInto: renderPostInto,\n    renderIntoAndFocusTail: renderIntoAndFocusTail\n  };\n});","define('tests/helpers/mock-editor', ['exports', 'mobiledoc-kit/editor/post', 'mobiledoc-kit/utils/cursor/range'], function (exports, _mobiledocKitEditorPost, _mobiledocKitUtilsCursorRange) {\n  'use strict';\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var MockEditor = (function () {\n    function MockEditor(builder) {\n      _classCallCheck(this, MockEditor);\n\n      this.builder = builder;\n      this.range = _mobiledocKitUtilsCursorRange['default'].blankRange();\n    }\n\n    _createClass(MockEditor, [{\n      key: 'run',\n      value: function run(callback) {\n        var postEditor = new _mobiledocKitEditorPost['default'](this);\n        postEditor.begin();\n        var result = callback(postEditor);\n        postEditor.end();\n        return result;\n      }\n    }, {\n      key: 'rerender',\n      value: function rerender() {}\n    }, {\n      key: '_postDidChange',\n      value: function _postDidChange() {}\n    }, {\n      key: 'selectRange',\n      value: function selectRange(range) {\n        this._renderedRange = range;\n      }\n    }, {\n      key: '_readRangeFromDOM',\n      value: function _readRangeFromDOM() {}\n    }]);\n\n    return MockEditor;\n  })();\n\n  exports['default'] = MockEditor;\n});","define('tests/helpers/module-load-failure', ['exports', 'ember-cli/test-loader'], function (exports, _emberCliTestLoader) {\n  'use strict';\n\n  /**\n   * Ensures that when the TestLoader failures to load a test module, the error\n   * is reported. Without this the rest of the full test suite still passes and there is an\n   * error printed in the console only.\n   * The technique is from: https://github.com/ember-cli/ember-cli-qunit/blob/master/vendor/ember-cli-qunit/test-loader.js#L55\n   */\n\n  exports['default'] = function (QUnit) {\n    var moduleLoadFailures = [];\n\n    _emberCliTestLoader['default'].prototype.moduleLoadFailure = function (moduleName, error) {\n      moduleLoadFailures.push(error);\n      QUnit.module('TestLoader Failures');\n      QUnit.test(moduleName + ': could not be loaded', function () {\n        throw error;\n      });\n    };\n\n    QUnit.done(function () {\n      if (moduleLoadFailures.length) {\n        throw new Error('\\n' + moduleLoadFailures.join('\\n'));\n      }\n    });\n  };\n});","define('tests/helpers/post-abstract', ['exports', 'mobiledoc-kit/models/post-node-builder'], function (exports, _mobiledocKitModelsPostNodeBuilder) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  /*\n   * usage:\n   *  Helpers.postAbstract.build(({post, section, marker, markup}) =>\n   *    post([\n   *      section('P', [\n   *        marker('some text', [markup('B')])\n   *      ])\n   *    })\n   *  )\n   */\n  function build(treeFn) {\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n\n    var simpleBuilder = {\n      post: function post() {\n        return builder.createPost.apply(builder, arguments);\n      },\n      markupSection: function markupSection() {\n        return builder.createMarkupSection.apply(builder, arguments);\n      },\n      markup: function markup() {\n        return builder.createMarkup.apply(builder, arguments);\n      },\n      marker: function marker() {\n        return builder.createMarker.apply(builder, arguments);\n      },\n      listSection: function listSection() {\n        return builder.createListSection.apply(builder, arguments);\n      },\n      listItem: function listItem() {\n        return builder.createListItem.apply(builder, arguments);\n      },\n      cardSection: function cardSection() {\n        return builder.createCardSection.apply(builder, arguments);\n      },\n      imageSection: function imageSection() {\n        return builder.createImageSection.apply(builder, arguments);\n      },\n      atom: function atom() {\n        return builder.createAtom.apply(builder, arguments);\n      }\n    };\n\n    return treeFn(simpleBuilder);\n  }\n\n  var cardRegex = /\\[(.*)\\]/;\n  var markupRegex = /\\*/g;\n  var listStartRegex = /^\\* /;\n  var cursorRegex = /<|>|\\|/g;\n\n  function parsePositionOffsets(text) {\n    var offsets = {};\n\n    if (cardRegex.test(text)) {\n      [['|', 'solo'], ['<', 'start'], ['>', 'end']].forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var char = _ref2[0];\n        var type = _ref2[1];\n\n        if (text.indexOf(char) !== -1) {\n          offsets[type] = text.indexOf(char) === 0 ? 0 : 1;\n        }\n      });\n    } else {\n      if (listStartRegex.test(text)) {\n        text = text.replace(listStartRegex, '');\n      }\n      text = text.replace(markupRegex, '');\n      if (text.indexOf('|') !== -1) {\n        offsets.solo = text.indexOf('|');\n      } else if (text.indexOf('<') !== -1 || text.indexOf('>') !== -1) {\n        var hasStart = text.indexOf('<') !== -1;\n        var hasEnd = text.indexOf('>') !== -1;\n        if (hasStart) {\n          offsets.start = text.indexOf('<');\n          text = text.replace(/</g, '');\n        }\n        if (hasEnd) {\n          offsets.end = text.indexOf('>');\n        }\n      }\n    }\n\n    return offsets;\n  }\n\n  var DEFAULT_ATOM_NAME = 'some-atom';\n  var DEFAULT_ATOM_VALUE = '@atom';\n\n  var MARKUP_CHARS = {\n    '*': 'b',\n    '_': 'em'\n  };\n\n  function parseTextIntoAtom(text, builder) {\n    var markers = [];\n    var atomIndex = text.indexOf('@');\n    var afterAtomIndex = atomIndex + 1;\n    var atomName = DEFAULT_ATOM_NAME,\n        atomValue = DEFAULT_ATOM_VALUE,\n        atomPayload = {};\n\n    // If \"@\" is followed by \"( ... json ... )\", parse the json data\n    if (text[atomIndex + 1] === \"(\") {\n      var jsonStartIndex = atomIndex + 1;\n      var jsonEndIndex = text.indexOf(\")\", jsonStartIndex);\n      afterAtomIndex = jsonEndIndex + 1;\n      if (jsonEndIndex === -1) {\n        throw new Error('Atom JSON data had unmatched \"(\": ' + text);\n      }\n      var jsonString = text.slice(jsonStartIndex + 1, jsonEndIndex);\n      jsonString = \"{\" + jsonString + \"}\";\n      try {\n        var json = JSON.parse(jsonString);\n        if (json.name) {\n          atomName = json.name;\n        }\n        if (json.value) {\n          atomValue = json.value;\n        }\n        if (json.payload) {\n          atomPayload = json.payload;\n        }\n      } catch (e) {\n        throw new Error('Failed to parse atom JSON data string: ' + jsonString + ', ' + e);\n      }\n    }\n\n    // create the atom\n    var atom = builder.atom(atomName, atomValue, atomPayload);\n\n    // recursively parse the remaining text pieces\n    var pieces = [text.slice(0, atomIndex), atom, text.slice(afterAtomIndex)];\n\n    // join the markers together\n    pieces.forEach(function (piece, index) {\n      if (index === 1) {\n        // atom\n        markers.push(piece);\n      } else if (piece.length) {\n        markers = markers.concat(parseTextIntoMarkers(piece, builder));\n      }\n    });\n\n    return markers;\n  }\n\n  function parseTextWithMarkup(text, builder) {\n    var markers = [];\n    var markup = undefined,\n        char = undefined;\n    Object.keys(MARKUP_CHARS).forEach(function (key) {\n      if (markup) {\n        return;\n      }\n      if (text.indexOf(key) !== -1) {\n        markup = builder.markup(MARKUP_CHARS[key]);\n        char = key;\n      }\n    });\n    if (!markup) {\n      throw new Error('Failed to find markup in text: ' + text);\n    }\n\n    var startIndex = text.indexOf(char);\n    var endIndex = text.indexOf(char, startIndex + 1);\n    if (endIndex === -1) {\n      throw new Error('Malformed text: char ' + char + ' do not match');\n    }\n\n    var pieces = [text.slice(0, startIndex), text.slice(startIndex + 1, endIndex), text.slice(endIndex + 1)];\n    pieces.forEach(function (piece, index) {\n      if (index === 1) {\n        // marked-up text\n        markers.push(builder.marker(piece, [markup]));\n      } else {\n        markers = markers.concat(parseTextIntoMarkers(piece, builder));\n      }\n    });\n\n    return markers;\n  }\n\n  function parseTextIntoMarkers(text, builder) {\n    text = text.replace(cursorRegex, '');\n    var markers = [];\n\n    var hasAtom = text.indexOf('@') !== -1;\n    var hasMarkup = false;\n    Object.keys(MARKUP_CHARS).forEach(function (key) {\n      if (text.indexOf(key) !== -1) {\n        hasMarkup = true;\n      }\n    });\n\n    if (hasAtom) {\n      markers = markers.concat(parseTextIntoAtom(text, builder));\n    } else if (hasMarkup) {\n      markers = markers.concat(parseTextWithMarkup(text, builder));\n    } else if (text.length) {\n      markers.push(builder.marker(text));\n    }\n\n    return markers;\n  }\n\n  function parseSingleText(text, builder) {\n    var section = undefined,\n        positions = {};\n\n    var offsets = parsePositionOffsets(text);\n\n    if (cardRegex.test(text)) {\n      section = builder.cardSection(cardRegex.exec(text)[1]);\n    } else {\n      var type = 'p';\n      if (listStartRegex.test(text)) {\n        text = text.replace(listStartRegex, '');\n        type = 'ul';\n      }\n\n      var markers = parseTextIntoMarkers(text, builder);\n\n      switch (type) {\n        case 'p':\n          section = builder.markupSection('p', markers);\n          break;\n        case 'ul':\n          section = builder.listItem(markers);\n          break;\n      }\n    }\n\n    ['start', 'end', 'solo'].forEach(function (type) {\n      if (offsets[type] !== undefined) {\n        positions[type] = section.toPosition(offsets[type]);\n      }\n    });\n\n    return { section: section, positions: positions };\n  }\n\n  /**\n   * Shorthand to create a mobiledoc simply.\n   * Pass a string or an array of strings.\n   *\n   * Returns { post, range }, a post built from the mobiledoc and a range.\n   *\n   * Use \"|\" to indicate the cursor position or \"<\" and \">\" to indicate a range.\n   * Use \"[card-name]\" to indicate a card\n   * Use asterisks to indicate bold text: \"abc *bold* def\"\n   * Use \"@\" to indicate an atom, default values for name,value,payload are DEFAULT_ATOM_NAME,DEFAULT_ATOM_VALUE,{}\n   * Use \"@(name, value, payload)\" to specify name,value and/or payload for an atom. The string from `(` to `)` is parsed as\n   *   JSON, e.g.: '@(\"name\": \"my-atom\", \"value\": \"abc\", \"payload\": {\"foo\": \"bar\"})' -> atom named \"my-atom\" with value 'abc', payload {foo: 'bar'}\n   * Use \"* \" at the start of the string to indicate a list item (\"ul\")\n   *\n   * Examples:\n   * buildFromText(\"abc\") -> { post } with 1 markup section (\"p\") with text \"abc\"\n   * buildFromText([\"abc\",\"def\"]) -> { post } with 2 markups sections (\"p\") with texts \"abc\" and \"def\"\n   * buildFromText(\"abc|def\") -> { post, range } where range is collapsed at offset 3 (after the \"c\")\n   * buildFromText([\"abcdef\",\"[some-card]\",\"def\"]) -> { post } with [MarkupSection, Card, MarkupSection] sections\n   * buildFromText([\"* item 1\", \"* item 2\"]) -> { post } with a ListSection with 2 ListItems\n   * buildFromText([\"<abc\", \"def\", \"ghi>\"]) -> { post, range } where range is the entire post (before the \"a\" to after the \"i\")\n   */\n  function buildFromText(texts) {\n    if (!Array.isArray(texts)) {\n      texts = [texts];\n    }\n    var positions = {};\n\n    var post = build(function (builder) {\n      var sections = [];\n      var curList = undefined;\n      texts.forEach(function (text, index) {\n        var _parseSingleText = parseSingleText(text, builder);\n\n        var section = _parseSingleText.section;\n        var _positions = _parseSingleText.positions;\n\n        var lastText = index === texts.length - 1;\n\n        if (curList) {\n          if (section.isListItem) {\n            curList.items.append(section);\n          } else {\n            sections.push(curList);\n            sections.push(section);\n            curList = null;\n          }\n        } else if (section.isListItem) {\n          curList = builder.listSection('ul', [section]);\n        } else {\n          sections.push(section);\n        }\n\n        if (lastText && curList) {\n          sections.push(curList);\n        }\n\n        if (_positions.start) {\n          positions.start = _positions.start;\n        }\n        if (_positions.end) {\n          positions.end = _positions.end;\n        }\n        if (_positions.solo) {\n          positions.solo = _positions.solo;\n        }\n      });\n\n      return builder.post(sections);\n    });\n\n    var range = undefined;\n    if (positions.start) {\n      if (!positions.end) {\n        throw new Error('startPos but no endPos ' + texts.join('\\n'));\n      }\n      range = positions.start.toRange(positions.end);\n    } else if (positions.solo) {\n      range = positions.solo.toRange();\n    }\n\n    return { post: post, range: range };\n  }\n\n  exports['default'] = {\n    build: build,\n    buildFromText: buildFromText,\n    DEFAULT_ATOM_NAME: DEFAULT_ATOM_NAME\n  };\n});","define('tests/helpers/post-editor-run', ['exports', 'mobiledoc-kit/models/post-node-builder', 'mobiledoc-kit/editor/post', './mock-editor', './render-built-abstract'], function (exports, _mobiledocKitModelsPostNodeBuilder, _mobiledocKitEditorPost, _mockEditor, _renderBuiltAbstract) {\n  'use strict';\n\n  exports['default'] = run;\n\n  function run(post, callback) {\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    var editor = new _mockEditor['default'](builder);\n\n    (0, _renderBuiltAbstract['default'])(post, editor);\n\n    var postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.begin();\n    var result = callback(postEditor);\n    postEditor.complete();\n    return result;\n  }\n});","define('tests/helpers/render-built-abstract', ['exports', 'mobiledoc-kit/renderers/editor-dom', 'mobiledoc-kit/models/render-tree'], function (exports, _mobiledocKitRenderersEditorDom, _mobiledocKitModelsRenderTree) {\n  'use strict';\n\n  exports['default'] = renderBuiltAbstract;\n\n  function renderBuiltAbstract(post, editor) {\n    editor.post = post;\n    var unknownCardHandler = function unknownCardHandler() {};\n    var unknownAtomHandler = function unknownAtomHandler() {};\n    var renderer = new _mobiledocKitRenderersEditorDom['default'](editor, [], [], unknownCardHandler, unknownAtomHandler);\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    renderer.render(renderTree);\n    return editor;\n  }\n});","define(\"tests/helpers/wait\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  var wait = function wait(callback) {\n    window.requestAnimationFrame(callback);\n  };\n\n  exports[\"default\"] = wait;\n});","define('tests/test-helpers', ['exports', './helpers/assertions', './helpers/module-load-failure', './helpers/dom', './helpers/mobiledoc', './helpers/post-abstract', './helpers/browsers', './helpers/wait', './helpers/mock-editor', './helpers/render-built-abstract', './helpers/post-editor-run', './helpers/editor'], function (exports, _helpersAssertions, _helpersModuleLoadFailure, _helpersDom, _helpersMobiledoc, _helpersPostAbstract, _helpersBrowsers, _helpersWait, _helpersMockEditor, _helpersRenderBuiltAbstract, _helpersPostEditorRun, _helpersEditor) {\n  /* global QUnit */\n  'use strict';\n\n  (0, _helpersAssertions['default'])(QUnit);\n\n  (0, _helpersModuleLoadFailure['default'])(QUnit);\n\n  var _QUnit = QUnit;\n  var qunitTest = _QUnit.test;\n  var _module = _QUnit.module;\n  var skip = _QUnit.skip;\n\n  QUnit.config.urlConfig.push({\n    id: 'debugTest',\n    label: 'Debug Test'\n  });\n\n  var test = function test(msg, callback) {\n    var originalCallback = callback;\n    callback = function () {\n      if (QUnit.config.debugTest) {\n        // eslint-disable-next-line no-debugger\n        debugger;\n      }\n      originalCallback.apply(undefined, arguments);\n    };\n    qunitTest(msg, callback);\n  };\n\n  var skipInIE11 = function skipInIE11(msg, callback) {\n    if ((0, _helpersBrowsers.detectIE11)()) {\n      skip('SKIPPED IN IE11: ' + msg, callback);\n    } else {\n      test(msg, callback);\n    }\n  };\n\n  QUnit.testStart(function () {\n    // The fixture is cleared between tests, clearing this\n    $('<div id=\"editor\"></div>').appendTo('#qunit-fixture');\n  });\n\n  var sauceLog = [];\n\n  QUnit.done(function (test_results) {\n    var tests = [];\n    for (var i = 0, len = sauceLog.length; i < len; i++) {\n      var details = sauceLog[i];\n      tests.push({\n        name: details.name,\n        result: details.result,\n        expected: details.expected,\n        actual: details.actual,\n        source: details.source\n      });\n    }\n    test_results.tests = tests;\n\n    window.global_test_results = test_results;\n  });\n\n  QUnit.testStart(function (testDetails) {\n    QUnit.log(function (details) {\n      if (!details.result) {\n        details.name = testDetails.name;\n        sauceLog.push(details);\n      }\n    });\n  });\n\n  exports['default'] = {\n    dom: _helpersDom['default'],\n    mobiledoc: _helpersMobiledoc['default'],\n    postAbstract: _helpersPostAbstract['default'],\n    editor: _helpersEditor['default'],\n    test: test,\n    module: _module,\n    skipInIE11: skipInIE11,\n    skip: skip,\n    wait: _helpersWait['default'],\n    postEditor: { run: _helpersPostEditorRun['default'], renderBuiltAbstract: _helpersRenderBuiltAbstract['default'], MockEditor: _helpersMockEditor['default'] }\n  };\n});","define('tests/unit/editor/atom-lifecycle-test', ['exports', '../../test-helpers', 'mobiledoc-kit', 'mobiledoc-kit/renderers/mobiledoc/0-3-1'], function (exports, _testHelpers, _mobiledocKit, _mobiledocKitRenderersMobiledoc031) {\n  'use strict';\n\n  var editorElement = undefined,\n      editor = undefined;\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n  var DEFAULT_ATOM_NAME = _testHelpers['default'].postAbstract.DEFAULT_ATOM_NAME;\n\n  _module('Unit: Editor: Atom Lifecycle', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor && !editor.isDestroyed) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  function makeEl(id) {\n    var text = arguments.length <= 1 || arguments[1] === undefined ? '@atom' : arguments[1];\n\n    var el = document.createElement('span');\n    el.id = id;\n    text = document.createTextNode(text);\n    el.appendChild(text);\n    return el;\n  }\n\n  // Default version is 0.2 for the moment\n  function build(fn) {\n    return _testHelpers['default'].mobiledoc.build(fn, _mobiledocKitRenderersMobiledoc031.MOBILEDOC_VERSION);\n  }\n\n  function assertRenderArguments(assert, args, expected) {\n    var env = args.env;\n    var options = args.options;\n    var payload = args.payload;\n\n    assert.deepEqual(payload, expected.payload, 'correct payload');\n    assert.deepEqual(options, expected.options, 'correct options');\n\n    // basic env\n    var name = env.name;\n    var onTeardown = env.onTeardown;\n\n    assert.equal(name, expected.name, 'correct name');\n    assert.ok(!!onTeardown, 'has onTeardown');\n  }\n\n  test('rendering a mobiledoc with atom calls atom#render', function (assert) {\n    var atomPayload = { foo: 'bar' };\n    var atomValue = \"@bob\";\n    var cardOptions = { boo: 'baz' };\n    var atomName = 'test-atom';\n\n    var renderArg = undefined;\n\n    var atom = {\n      name: atomName,\n      type: 'dom',\n      render: function render(_renderArg) {\n        renderArg = _renderArg;\n      }\n    };\n\n    var mobiledoc = build(function (_ref) {\n      var markupSection = _ref.markupSection;\n      var post = _ref.post;\n      var atom = _ref.atom;\n      return post([markupSection('p', [atom(atomName, atomValue, atomPayload)])]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom], cardOptions: cardOptions });\n    editor.render(editorElement);\n\n    var expected = {\n      name: atomName,\n      payload: atomPayload,\n      options: cardOptions\n    };\n    assertRenderArguments(assert, renderArg, expected);\n  });\n\n  test('rendering a mobiledoc with atom appends result of atom#render', function (assert) {\n    var atomName = 'test-atom';\n\n    var atom = {\n      name: atomName,\n      type: 'dom',\n      render: function render() {\n        return makeEl('the-atom');\n      }\n    };\n\n    var mobiledoc = build(function (_ref2) {\n      var markupSection = _ref2.markupSection;\n      var post = _ref2.post;\n      var atom = _ref2.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom] });\n    assert.hasNoElement('#editor #the-atom', 'precond - atom not rendered');\n    editor.render(editorElement);\n    assert.hasElement('#editor #the-atom');\n  });\n\n  test('returning wrong type from render throws', function (assert) {\n    var atomName = 'test-atom';\n\n    var atom = {\n      name: atomName,\n      type: 'dom',\n      render: function render() {\n        return 'string';\n      }\n    };\n\n    var mobiledoc = build(function (_ref3) {\n      var markupSection = _ref3.markupSection;\n      var post = _ref3.post;\n      var atom = _ref3.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom] });\n\n    assert.throws(function () {\n      editor.render(editorElement);\n    }, new RegExp('Atom \"' + atomName + '\" must return a DOM node'));\n  });\n\n  test('returning undefined from render is ok', function (assert) {\n    var atomName = 'test-atom';\n\n    var atom = {\n      name: atomName,\n      type: 'dom',\n      render: function render() {}\n    };\n\n    var mobiledoc = build(function (_ref4) {\n      var markupSection = _ref4.markupSection;\n      var post = _ref4.post;\n      var atom = _ref4.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom] });\n    editor.render(editorElement);\n    assert.ok(true, 'no errors are thrown');\n  });\n\n  test('rendering atom with wrong type throws', function (assert) {\n    var atomName = 'test-atom';\n    var atom = {\n      name: atomName,\n      type: 'other',\n      render: function render() {}\n    };\n    var mobiledoc = build(function (_ref5) {\n      var markupSection = _ref5.markupSection;\n      var post = _ref5.post;\n      var atom = _ref5.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n\n    assert.throws(function () {\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom] });\n      editor.render(editorElement);\n    }, new RegExp('Atom \"' + atomName + '.* must define type'));\n  });\n\n  test('rendering atom without render method throws', function (assert) {\n    var atomName = 'test-atom';\n    var atom = {\n      name: atomName,\n      type: 'dom'\n    };\n    var mobiledoc = build(function (_ref6) {\n      var markupSection = _ref6.markupSection;\n      var post = _ref6.post;\n      var atom = _ref6.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n\n    assert.throws(function () {\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom] });\n      editor.render(editorElement);\n    }, new RegExp('Atom \"' + atomName + '.* must define.*render'));\n  });\n\n  test('rendering unknown atom calls #unknownAtomHandler', function (assert) {\n    var payload = { foo: 'bar' };\n    var cardOptions = { boo: 'baz' };\n    var atomName = 'test-atom';\n    var atomValue = '@bob';\n\n    var unknownArg = undefined;\n    var unknownAtomHandler = function unknownAtomHandler(_unknownArg) {\n      unknownArg = _unknownArg;\n    };\n\n    var mobiledoc = build(function (_ref7) {\n      var markupSection = _ref7.markupSection;\n      var post = _ref7.post;\n      var atom = _ref7.atom;\n      return post([markupSection('p', [atom(atomName, atomValue, payload)])]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, unknownAtomHandler: unknownAtomHandler, cardOptions: cardOptions });\n    editor.render(editorElement);\n\n    var expected = {\n      name: atomName,\n      value: atomValue,\n      options: cardOptions,\n      payload: payload\n    };\n    assertRenderArguments(assert, unknownArg, expected);\n  });\n\n  test('rendering unknown atom without unknownAtomHandler throws', function (assert) {\n    var atomName = 'test-atom';\n\n    var mobiledoc = build(function (_ref8) {\n      var markupSection = _ref8.markupSection;\n      var post = _ref8.post;\n      var atom = _ref8.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, unknownAtomHandler: undefined });\n\n    assert.throws(function () {\n      editor.render(editorElement);\n    }, new RegExp('Unknown atom \"' + atomName + '\".*no unknownAtomHandler'));\n  });\n\n  test('onTeardown hook is called when editor is destroyed', function (assert) {\n    var atomName = 'test-atom';\n\n    var teardown = undefined;\n\n    var atom = {\n      name: atomName,\n      type: 'dom',\n      render: function render(_ref9) {\n        var env = _ref9.env;\n\n        env.onTeardown(function () {\n          return teardown = true;\n        });\n      }\n    };\n\n    var mobiledoc = build(function (_ref10) {\n      var markupSection = _ref10.markupSection;\n      var post = _ref10.post;\n      var atom = _ref10.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom] });\n    editor.render(editorElement);\n\n    assert.ok(!teardown, 'nothing torn down yet');\n\n    editor.destroy();\n\n    assert.ok(teardown, 'onTeardown hook called');\n  });\n\n  test('onTeardown hook is called when atom is destroyed', function (assert) {\n    var teardown = undefined;\n\n    var atom = {\n      name: DEFAULT_ATOM_NAME,\n      type: 'dom',\n      render: function render(_ref11) {\n        var env = _ref11.env;\n\n        env.onTeardown(function () {\n          return teardown = true;\n        });\n        return makeEl('atom-id', 'atom-text');\n      }\n    };\n    editor = _testHelpers['default'].editor.buildFromText('abc@d|ef', { autofocus: true, atoms: [atom], element: editorElement });\n    assert.hasElement('#editor #atom-id:contains(atom-text)', 'precond - shows atom');\n    assert.ok(!teardown, 'precond - no teardown yet');\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasElement('#editor #atom-id:contains(atom-text)', 'precond - still shows atom');\n    assert.ok(!teardown, 'precond - no teardown yet');\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.hasNoElement('*:contains(atom-text)', 'atom destroyed');\n    assert.ok(teardown, 'calls teardown');\n  });\n\n  // See https://github.com/bustle/mobiledoc-kit/issues/421\n  test('render is not called again when modifying other parts of the section', function (assert) {\n    var renderCount = 0;\n    var atom = {\n      name: DEFAULT_ATOM_NAME,\n      type: 'dom',\n      render: function render() {\n        renderCount++;\n        return makeEl('the-atom');\n      }\n    };\n    editor = _testHelpers['default'].editor.buildFromText('abc|@def', { autofocus: true, atoms: [atom], element: editorElement });\n    assert.equal(renderCount, 1, 'renders the atom initially');\n    editor.insertText('123');\n    assert.hasElement('#editor *:contains(abc123)', 'precond - inserts text');\n    assert.equal(renderCount, 1, 'does not rerender the atom');\n  });\n\n  test('mutating the content of an atom does not trigger an update', function (assert) {\n    assert.expect(5);\n    var done = assert.async();\n\n    var atomName = 'test-atom';\n\n    var renderCount = 0;\n    var teardown = undefined;\n\n    var atom = {\n      name: atomName,\n      type: 'dom',\n      render: function render(_ref12) {\n        var env = _ref12.env;\n\n        renderCount++;\n        env.onTeardown(function () {\n          return teardown = true;\n        });\n        return makeEl('the-atom');\n      }\n    };\n\n    var mobiledoc = build(function (_ref13) {\n      var markupSection = _ref13.markupSection;\n      var post = _ref13.post;\n      var atom = _ref13.atom;\n      return post([markupSection('p', [atom(atomName, '@bob', {})])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, atoms: [atom] });\n\n    var updateTriggered = false;\n    editor.postDidChange(function () {\n      return updateTriggered = true;\n    });\n\n    assert.hasNoElement('#editor #the-atom', 'precond - atom not rendered');\n    editor.render(editorElement);\n    assert.equal(renderCount, 1, 'renders atom');\n\n    $(\"#the-atom\").html(\"updated\");\n\n    // ensure the mutations have had time to trigger\n    _testHelpers['default'].wait(function () {\n      assert.ok(!updateTriggered);\n      assert.equal(renderCount, 1, 'does not rerender atom');\n      assert.ok(!teardown, 'does not teardown atom');\n      done();\n    });\n  });\n\n  test('atom env has \"save\" method, rerenders atom', function (assert) {\n    var atomArgs = {};\n    var _render = 0;\n    var teardown = 0;\n    var postDidChange = 0;\n    var save = undefined;\n\n    var atom = {\n      name: DEFAULT_ATOM_NAME,\n      type: 'dom',\n      render: function render(_ref14) {\n        var env = _ref14.env;\n        var value = _ref14.value;\n        var payload = _ref14.payload;\n\n        _render++;\n        atomArgs.value = value;\n        atomArgs.payload = payload;\n        save = env.save;\n\n        env.onTeardown(function () {\n          return teardown++;\n        });\n\n        return makeEl('the-atom', value);\n      }\n    };\n\n    editor = _testHelpers['default'].editor.buildFromText('abc|@(\"value\": \"initial-value\", \"payload\": {\"foo\": \"bar\"})def', { autofocus: true, atoms: [atom], element: editorElement });\n    editor.postDidChange(function () {\n      return postDidChange++;\n    });\n\n    assert.equal(_render, 1, 'precond - renders atom');\n    assert.equal(teardown, 0, 'precond - did not teardown');\n    assert.ok(!!save, 'precond - save hook');\n    assert.deepEqual(atomArgs, { value: 'initial-value', payload: { foo: \"bar\" } }, 'args initially empty');\n    assert.hasElement('#the-atom', 'precond - displays atom');\n\n    var value = 'new-value';\n    var payload = { foo: 'baz' };\n    postDidChange = 0;\n\n    save(value, payload);\n\n    assert.equal(_render, 2, 'rerenders atom');\n    assert.equal(teardown, 1, 'tears down atom');\n    assert.deepEqual(atomArgs, { value: value, payload: payload }, 'updates atom values');\n    assert.ok(postDidChange, 'post changed when saving atom');\n    assert.hasElement('#the-atom:contains(' + value + ')');\n  });\n});","define('tests/unit/editor/card-lifecycle-test', ['exports', '../../test-helpers', 'mobiledoc-kit'], function (exports, _testHelpers, _mobiledocKit) {\n  'use strict';\n\n  var editorElement = undefined,\n      editor = undefined;\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Editor: Card Lifecycle', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor && !editor.isDestroyed) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  function makeEl(id) {\n    var el = document.createElement('div');\n    el.id = id;\n    return el;\n  }\n\n  function assertRenderArguments(assert, args, expected) {\n    var env = args.env;\n    var options = args.options;\n    var payload = args.payload;\n\n    assert.deepEqual(payload, expected.payload, 'correct payload');\n    assert.deepEqual(options, expected.options, 'correct options');\n\n    // basic env\n    var name = env.name;\n    var isInEditor = env.isInEditor;\n    var onTeardown = env.onTeardown;\n    var didRender = env.didRender;\n\n    assert.equal(name, expected.name, 'correct name');\n    assert.equal(isInEditor, expected.isInEditor, 'correct isInEditor');\n    assert.ok(!!onTeardown, 'has onTeardown');\n    assert.ok(!!didRender, 'has didRender');\n\n    // editor env hooks\n    var save = env.save;\n    var cancel = env.cancel;\n    var edit = env.edit;\n    var remove = env.remove;\n\n    assert.ok(!!save && !!cancel && !!edit && !!remove, 'has save, cancel, edit, remove hooks');\n\n    // postModel\n    var postModel = env.postModel;\n\n    assert.ok(postModel && postModel === expected.postModel, 'correct postModel');\n  }\n\n  test('rendering a mobiledoc with card calls card#render', function (assert) {\n    var payload = { foo: 'bar' };\n    var cardOptions = { boo: 'baz' };\n    var cardName = 'test-card';\n\n    var renderArg = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_renderArg) {\n        renderArg = _renderArg;\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var cardSection = _ref.cardSection;\n      return post([cardSection('test-card', payload)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card], cardOptions: cardOptions });\n    editor.render(editorElement);\n\n    var expected = {\n      name: cardName,\n      payload: payload,\n      options: cardOptions,\n      isInEditor: true,\n      postModel: editor.post.sections.head\n    };\n    assertRenderArguments(assert, renderArg, expected);\n  });\n\n  test('rendering a mobiledoc with card appends result of card#render', function (assert) {\n    var cardName = 'test-card';\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render() {\n        return makeEl('the-card');\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var cardSection = _ref2.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    assert.hasNoElement('#editor #the-card', 'precond - card not rendered');\n    editor.render(editorElement);\n    assert.hasElement('#editor #the-card');\n  });\n\n  test('returning wrong type from render throws', function (assert) {\n    var cardName = 'test-card';\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render() {\n        return 'string';\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref3) {\n      var post = _ref3.post;\n      var cardSection = _ref3.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n\n    assert.throws(function () {\n      editor.render(editorElement);\n    }, new RegExp('Card \"' + cardName + '\" must render dom'));\n  });\n\n  test('returning undefined from render is ok', function (assert) {\n    var cardName = 'test-card';\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render() {}\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref4) {\n      var post = _ref4.post;\n      var cardSection = _ref4.cardSection;\n      return post([cardSection('test-card')]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n    assert.ok(true, 'no errors are thrown');\n  });\n\n  test('returning undefined from render is ok', function (assert) {\n    var cardName = 'test-card';\n    var currentMode = undefined;\n    var editHook = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref5) {\n        var env = _ref5.env;\n\n        currentMode = 'display';\n        editHook = env.edit;\n      },\n      edit: function edit() {\n        currentMode = 'edit';\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref6) {\n      var post = _ref6.post;\n      var cardSection = _ref6.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.equal(currentMode, 'display', 'precond - display');\n    editHook();\n    assert.equal(currentMode, 'edit', 'edit mode, no errors when returning undefined');\n  });\n\n  test('rendering card with wrong type throws', function (assert) {\n    var cardName = 'test-card';\n    var card = {\n      name: cardName,\n      type: 'other',\n      render: function render() {}\n    };\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref7) {\n      var post = _ref7.post;\n      var cardSection = _ref7.cardSection;\n      return post([cardSection(cardName)]);\n    });\n\n    assert.throws(function () {\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n      editor.render(editorElement);\n    }, new RegExp('Card \"' + cardName + '.* must define type'));\n  });\n\n  test('rendering card without render method throws', function (assert) {\n    var cardName = 'test-card';\n    var card = {\n      name: cardName,\n      type: 'dom'\n    };\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref8) {\n      var post = _ref8.post;\n      var cardSection = _ref8.cardSection;\n      return post([cardSection(cardName)]);\n    });\n\n    assert.throws(function () {\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n      editor.render(editorElement);\n    }, new RegExp('Card \"' + cardName + '.* must define.*render'));\n  });\n\n  test('card can call `env.edit` to render in edit mode', function (assert) {\n    var payload = { foo: 'bar' };\n    var cardOptions = { boo: 'baz' };\n    var cardName = 'test-card';\n\n    var editArg = undefined;\n    var editHook = undefined;\n    var currentMode = undefined;\n    var displayId = 'the-display-card';\n    var editId = 'the-edit-card';\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_renderArg) {\n        currentMode = 'display';\n        editHook = _renderArg.env.edit;\n        return makeEl(displayId);\n      },\n      edit: function edit(_editArg) {\n        currentMode = 'edit';\n        editArg = _editArg;\n        return makeEl(editId);\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref9) {\n      var post = _ref9.post;\n      var cardSection = _ref9.cardSection;\n      return post([cardSection(cardName, payload)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card], cardOptions: cardOptions });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor #' + displayId, 'precond - display card');\n    assert.hasNoElement('#editor #' + editId, 'precond - no edit card');\n    assert.equal(currentMode, 'display');\n\n    editHook();\n\n    assert.equal(currentMode, 'edit');\n    assert.hasNoElement('#editor #' + displayId, 'no display card');\n    assert.hasElement('#editor #' + editId, 'renders edit card');\n\n    var expected = {\n      name: cardName,\n      payload: payload,\n      options: cardOptions,\n      isInEditor: true,\n      postModel: editor.post.sections.head\n    };\n    assertRenderArguments(assert, editArg, expected);\n  });\n\n  test('save hook updates payload when in display mode', function (assert) {\n    var cardName = 'test-card';\n    var saveHook = undefined;\n    var postModel = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref10) {\n        var env = _ref10.env;\n\n        saveHook = env.save;\n        postModel = env.postModel;\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref11) {\n      var post = _ref11.post;\n      var cardSection = _ref11.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    var newPayload = { newPayload: true };\n    saveHook(newPayload);\n    assert.deepEqual(postModel.payload, newPayload, 'save updates payload when called without transition param');\n\n    var otherNewPayload = { otherNewPayload: true };\n    saveHook(otherNewPayload, false);\n    assert.deepEqual(postModel.payload, otherNewPayload, 'save updates payload when called with transition=false');\n  });\n\n  test('save hook updates payload when in edit mode', function (assert) {\n    var cardName = 'test-card';\n    var saveHook = undefined;\n    var editHook = undefined;\n    var postModel = undefined;\n    var currentMode = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref12) {\n        var env = _ref12.env;\n\n        currentMode = 'display';\n        editHook = env.edit;\n        postModel = env.postModel;\n      },\n      edit: function edit(_ref13) {\n        var env = _ref13.env;\n\n        currentMode = 'edit';\n        saveHook = env.save;\n        postModel = env.postModel;\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref14) {\n      var post = _ref14.post;\n      var cardSection = _ref14.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.equal(currentMode, 'display', 'precond - display mode');\n\n    editHook();\n\n    assert.equal(currentMode, 'edit', 'precond - edit mode');\n    var newPayload = { newPayload: true };\n    saveHook(newPayload, false);\n\n    assert.equal(currentMode, 'edit', 'save with false does not transition');\n    assert.deepEqual(postModel.payload, newPayload, 'updates payload');\n\n    var otherNewPayload = { otherNewPayload: true };\n    saveHook(otherNewPayload);\n    assert.equal(currentMode, 'display', 'save hook transitions');\n    assert.deepEqual(postModel.payload, otherNewPayload, 'updates payload');\n  });\n\n  test('#cancel hook changes from edit->display, does not change payload', function (assert) {\n    var cardName = 'test-card';\n    var cancelHook = undefined;\n    var editHook = undefined;\n    var postModel = undefined;\n    var currentMode = undefined;\n    var currentPayload = undefined;\n    var originalPayload = { foo: 'bar' };\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref15) {\n        var env = _ref15.env;\n        var payload = _ref15.payload;\n\n        currentMode = 'display';\n        editHook = env.edit;\n        postModel = env.postModel;\n        currentPayload = payload;\n      },\n      edit: function edit(_ref16) {\n        var env = _ref16.env;\n\n        currentMode = 'edit';\n        cancelHook = env.cancel;\n        postModel = env.postModel;\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref17) {\n      var post = _ref17.post;\n      var cardSection = _ref17.cardSection;\n      return post([cardSection(cardName, originalPayload)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.equal(currentMode, 'display', 'precond - display mode');\n\n    editHook();\n\n    assert.equal(currentMode, 'edit', 'precond - edit mode');\n\n    cancelHook();\n\n    assert.equal(currentMode, 'display', 'cancel hook transitions');\n    assert.deepEqual(currentPayload, originalPayload, 'payload is the same');\n  });\n\n  test('#remove hook destroys card when in display mode, removes it from DOM and AT', function (assert) {\n    var cardName = 'test-card';\n    var removeHook = undefined;\n    var elId = 'the-card';\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref18) {\n        var env = _ref18.env;\n\n        removeHook = env.remove;\n        return makeEl(elId);\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref19) {\n      var post = _ref19.post;\n      var cardSection = _ref19.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.hasElement('#editor #' + elId, 'precond - renders card');\n    assert.ok(!!editor.post.sections.head, 'post has head section');\n\n    removeHook();\n\n    assert.hasNoElement('#editor #' + elId, 'removes rendered card');\n    assert.ok(!editor.post.sections.head, 'post has no head section');\n  });\n\n  test('#remove hook destroys card when in edit mode, removes it from DOM and AT', function (assert) {\n    var cardName = 'test-card';\n    var removeHook = undefined;\n    var editHook = undefined;\n    var currentMode = undefined;\n    var displayId = 'the-display-card';\n    var editId = 'the-edit-card';\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref20) {\n        var env = _ref20.env;\n\n        currentMode = 'display';\n        editHook = env.edit;\n        return makeEl(displayId);\n      },\n      edit: function edit(_ref21) {\n        var env = _ref21.env;\n\n        currentMode = 'edit';\n        removeHook = env.remove;\n        return makeEl(editId);\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref22) {\n      var post = _ref22.post;\n      var cardSection = _ref22.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.equal(currentMode, 'display', 'precond - display mode');\n    assert.hasElement('#editor #' + displayId, 'precond - renders card in display');\n\n    editHook();\n\n    assert.equal(currentMode, 'edit', 'precond - edit mode');\n\n    assert.hasElement('#editor #' + editId, 'precond - renders card in edit');\n    assert.hasNoElement('#editor #' + displayId, 'display card is removed');\n    assert.ok(!!editor.post.sections.head, 'post has head section');\n\n    removeHook();\n\n    assert.hasNoElement('#editor #' + editId, 'removes rendered card');\n    assert.hasNoElement('#editor #' + displayId, 'display card is not present');\n    assert.ok(!editor.post.sections.head, 'post has no head section');\n  });\n\n  test('rendering unknown card calls #unknownCardHandler', function (assert) {\n    var payload = { foo: 'bar' };\n    var cardOptions = { boo: 'baz' };\n    var cardName = 'test-card';\n\n    var unknownArg = undefined;\n    var unknownCardHandler = function unknownCardHandler(_unknownArg) {\n      unknownArg = _unknownArg;\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref23) {\n      var post = _ref23.post;\n      var cardSection = _ref23.cardSection;\n      return post([cardSection(cardName, payload)]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, unknownCardHandler: unknownCardHandler, cardOptions: cardOptions });\n    editor.render(editorElement);\n\n    var expected = {\n      name: cardName,\n      payload: payload,\n      options: cardOptions,\n      isInEditor: true,\n      postModel: editor.post.sections.head\n    };\n    assertRenderArguments(assert, unknownArg, expected);\n  });\n\n  test('rendering unknown card without unknownCardHandler throws', function (assert) {\n    var cardName = 'test-card';\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref24) {\n      var post = _ref24.post;\n      var cardSection = _ref24.cardSection;\n      return post([cardSection(cardName)]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, unknownCardHandler: undefined });\n\n    assert.throws(function () {\n      editor.render(editorElement);\n    }, new RegExp('Unknown card \"' + cardName + '\".*no unknownCardHandler'));\n  });\n\n  test('onTeardown hook is called when moving from display->edit and back', function (assert) {\n    var cardName = 'test-card';\n\n    var editHook = undefined;\n    var saveHook = undefined;\n    var currentMode = undefined;\n    var teardown = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref25) {\n        var env = _ref25.env;\n\n        currentMode = 'display';\n        editHook = env.edit;\n        env.onTeardown(function () {\n          return teardown = 'display';\n        });\n      },\n      edit: function edit(_ref26) {\n        var env = _ref26.env;\n\n        currentMode = 'edit';\n        saveHook = env.save;\n        env.onTeardown(function () {\n          return teardown = 'edit';\n        });\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref27) {\n      var post = _ref27.post;\n      var cardSection = _ref27.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.equal(currentMode, 'display', 'precond - display mode');\n    assert.ok(!teardown, 'no teardown called yet');\n\n    editHook();\n\n    assert.equal(currentMode, 'edit', 'edit mode');\n    assert.equal(teardown, 'display', 'display onTeardown hook called');\n\n    saveHook();\n\n    assert.equal(currentMode, 'display', 'display mode');\n    assert.equal(teardown, 'edit', 'edit onTeardown hook called');\n  });\n\n  test('onTeardown hook is called when card removes itself', function (assert) {\n    var cardName = 'test-card';\n\n    var removeHook = undefined;\n    var teardown = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref28) {\n        var env = _ref28.env;\n\n        removeHook = env.remove;\n        env.onTeardown(function () {\n          return teardown = true;\n        });\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref29) {\n      var post = _ref29.post;\n      var cardSection = _ref29.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.ok(!teardown, 'nothing torn down yet');\n\n    removeHook();\n\n    assert.ok(teardown, 'onTeardown hook called');\n  });\n\n  test('onTeardown hook is called when editor is destroyed', function (assert) {\n    var cardName = 'test-card';\n\n    var teardown = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref30) {\n        var env = _ref30.env;\n\n        env.onTeardown(function () {\n          return teardown = true;\n        });\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref31) {\n      var post = _ref31.post;\n      var cardSection = _ref31.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.ok(!teardown, 'nothing torn down yet');\n\n    editor.destroy();\n\n    assert.ok(teardown, 'onTeardown hook called');\n  });\n\n  test('didRender hook is called when moving from display->edit and back', function (assert) {\n    var cardName = 'test-card';\n\n    var editHook = undefined;\n    var saveHook = undefined;\n    var currentMode = undefined;\n    var rendered = undefined;\n\n    var card = {\n      name: cardName,\n      type: 'dom',\n      render: function render(_ref32) {\n        var env = _ref32.env;\n\n        currentMode = 'display';\n        editHook = env.edit;\n        env.didRender(function () {\n          return rendered = 'display';\n        });\n        return makeEl('display-card');\n      },\n      edit: function edit(_ref33) {\n        var env = _ref33.env;\n\n        currentMode = 'edit';\n        saveHook = env.save;\n        env.didRender(function () {\n          return rendered = 'edit';\n        });\n        return makeEl('edit-card');\n      }\n    };\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref34) {\n      var post = _ref34.post;\n      var cardSection = _ref34.cardSection;\n      return post([cardSection(cardName)]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, cards: [card] });\n    editor.render(editorElement);\n\n    assert.equal(currentMode, 'display', 'precond - display mode');\n    assert.ok(rendered, 'didRender called on instantiation');\n\n    editHook();\n\n    assert.equal(currentMode, 'edit', 'edit mode');\n    assert.equal(rendered, 'edit', 'display didRender hook called');\n\n    saveHook();\n\n    assert.equal(currentMode, 'display', 'display mode');\n    assert.equal(rendered, 'display', 'edit didRender hook called');\n  });\n});","define('tests/unit/editor/editor-events-test', ['exports', '../../test-helpers', 'mobiledoc-kit', 'mobiledoc-kit/utils/cursor/range'], function (exports, _testHelpers, _mobiledocKit, _mobiledocKitUtilsCursorRange) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n    var post = _ref.post;\n    var markupSection = _ref.markupSection;\n    var marker = _ref.marker;\n\n    return post([markupSection('p', [marker('this is the editor')])]);\n  });\n\n  _module('Unit: Editor: events and lifecycle callbacks', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n      editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n      editor.render(editorElement);\n\n      // Tests in FF can fail if the window is not front-most and\n      // we don't explicitly render the range\n      editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n    },\n\n    afterEach: function afterEach() {\n      if (editor && !editor.isDestroyed) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('cursorDidChange callback does not fire when selection is set to the same value', function (assert) {\n    assert.expect(1);\n    var done = assert.async();\n\n    var cursorChanged = 0;\n    editor.cursorDidChange(function () {\n      return cursorChanged++;\n    });\n\n    var node = _testHelpers['default'].dom.findTextNode(editorElement, 'this is the editor');\n    _testHelpers['default'].dom.selectRange(node, 0, node, 0);\n\n    _testHelpers['default'].wait(function () {\n      cursorChanged = 0;\n\n      _testHelpers['default'].dom.selectRange(node, 0, node, 0);\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(cursorChanged, 0, 'cursor did not change when selection is set to same value');\n\n        done();\n      });\n    });\n  });\n\n  test('cursorDidChange callback fires when editor loses focus', function (assert) {\n    assert.expect(1);\n    var done = assert.async();\n\n    _testHelpers['default'].wait(function () {\n      // Tests in FF can fail if the window is not front-most and\n      // we don't explicitly render the range\n      var node = _testHelpers['default'].dom.findTextNode(editor.element, 'this is the editor');\n      _testHelpers['default'].dom.selectRange(node, 0, node, 0);\n\n      _testHelpers['default'].wait(function () {\n        var cursorChanged = 0;\n        editor.cursorDidChange(function () {\n          return cursorChanged++;\n        });\n\n        _testHelpers['default'].dom.clearSelection();\n\n        _testHelpers['default'].wait(function () {\n          assert.equal(cursorChanged, 1, 'cursor changed after clearing selection');\n\n          done();\n        });\n      });\n    });\n  });\n\n  test('cursorDidChange callback not fired if editor is destroyed', function (assert) {\n    assert.expect(2);\n    var done = assert.async();\n\n    var cursorChanged = 0;\n    editor.cursorDidChange(function () {\n      return cursorChanged++;\n    });\n\n    _testHelpers['default'].dom.clearSelection();\n\n    _testHelpers['default'].wait(function () {\n      cursorChanged = 0;\n      var node = _testHelpers['default'].dom.findTextNode(editor.element, 'this is the editor');\n      _testHelpers['default'].dom.selectRange(node, 0, node, 0);\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(cursorChanged, 1, 'precond - cursor change fires');\n\n        cursorChanged = 0;\n        editor.destroy();\n        _testHelpers['default'].dom.clearSelection();\n\n        _testHelpers['default'].wait(function () {\n          assert.equal(cursorChanged, 0, 'callback not fired');\n\n          done();\n        });\n      });\n    });\n  });\n\n  test('cursorChanged callback fired after editor.run sets range', function (assert) {\n    assert.expect(2);\n    var done = assert.async();\n\n    var cursorChanged = 0;\n    editor.cursorDidChange(function () {\n      return cursorChanged++;\n    });\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(cursorChanged, 0, 'precond - no cursor change');\n\n      editor.run(function (postEditor) {\n        var position = editor.post.headPosition();\n        postEditor.insertText(position, 'blah');\n        postEditor.setRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n      });\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(cursorChanged, 1, 'cursor changes after editor.run sets position');\n\n        done();\n      });\n    });\n  });\n\n  test('postDidChange callback fired when post is programmatically modified', function (assert) {\n    assert.expect(1);\n\n    var postChanged = 0;\n    editor.postDidChange(function () {\n      return postChanged++;\n    });\n    editor.run(function (postEditor) {\n      var position = editor.post.headPosition();\n      postEditor.insertText(position, 'blah');\n    });\n\n    assert.equal(postChanged, 1, 'postDidChange fired once');\n  });\n\n  test('postDidChange callback fired when post is modified via user input', function (assert) {\n    assert.expect(1);\n\n    var postChanged = 0;\n    editor.postDidChange(function () {\n      return postChanged++;\n    });\n\n    _testHelpers['default'].dom.selectText(editor, \"this is the editor\", editorElement);\n    _testHelpers['default'].dom.triggerDelete(editor);\n\n    assert.equal(postChanged, 1, 'postDidChange fired once');\n  });\n\n  test('postDidChange callback fired when card payload changes', function (assert) {\n    var env = undefined;\n    var cards = [{\n      name: 'simple-card',\n      type: 'dom',\n      render: function render(_ref2) {\n        var _env = _ref2.env;\n\n        env = _env;\n        return $('<div id=\"my-simple-card\">simple-card (display)</div>')[0];\n      },\n      edit: function edit(_ref3) {\n        var _env = _ref3.env;\n\n        env = _env;\n        return $('<div id=\"my-simple-card\">simple-card (edit)</div>')[0];\n      }\n    }];\n    var editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref4) {\n      var post = _ref4.post;\n      var cardSection = _ref4.cardSection;\n\n      return post([cardSection('simple-card')]);\n    }, { cards: cards });\n\n    var postDidChange = 0;\n    editor.postDidChange(function () {\n      return postDidChange++;\n    });\n\n    env.save({});\n    assert.equal(postDidChange, 1, 'postDidChange called after save');\n\n    postDidChange = 0;\n    env.edit();\n    assert.equal(postDidChange, 0, 'postDidChange not called after edit');\n\n    postDidChange = 0;\n    env.cancel();\n    assert.equal(postDidChange, 0, 'postDidChange not called after cancel');\n\n    postDidChange = 0;\n    env.remove();\n    assert.equal(postDidChange, 1, 'postDidChange called after remove');\n\n    editor.destroy();\n  });\n\n  test('inputModeDidChange callback fired when markup is toggled and there is a selection', function (assert) {\n    var done = assert.async();\n    assert.expect(1);\n\n    _testHelpers['default'].dom.selectText(editor, \"this is the editor\", editorElement);\n\n    _testHelpers['default'].wait(function () {\n      var inputChanged = 0;\n      editor.inputModeDidChange(function () {\n        return inputChanged++;\n      });\n\n      editor.toggleMarkup('b');\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(inputChanged, 1, 'inputModeDidChange fired once');\n        done();\n      });\n    });\n  });\n\n  test('inputModeDidChange callback fired when markup is toggled and selection is collapsed', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition()));\n\n    assert.ok(editor.range.isCollapsed, 'precond - range is collapsed');\n\n    _testHelpers['default'].wait(function () {\n      var inputChanged = 0;\n      editor.inputModeDidChange(function () {\n        return inputChanged++;\n      });\n\n      editor.toggleMarkup('b');\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(inputChanged, 1, 'inputModeDidChange fired once');\n        done();\n      });\n    });\n  });\n\n  test('inputModeDidChange callback fired when moving cursor into markup', function (assert) {\n    var done = assert.async();\n    assert.expect(1);\n\n    // setup - turn text bold\n    _testHelpers['default'].dom.selectText(editor, 'this is', editorElement);\n    editor.toggleMarkup('b');\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(editor.post.sections.head, 'this is'.length));\n\n    _testHelpers['default'].wait(function () {\n      var inputChanged = 0;\n      editor.inputModeDidChange(function () {\n        return inputChanged++;\n      });\n\n      editor.selectRange(editor.range.move(1));\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(inputChanged, 1, 'inputModeDidChange fired once');\n        done();\n      });\n    });\n  });\n\n  test('after #toggleMarkup, editor refocuses if it had selection', function (assert) {\n    var done = assert.async();\n    assert.expect(3);\n\n    var button = $('<button>BOLD</button>').appendTo('#qunit-fixture').click(function () {\n      _testHelpers['default'].dom.selectText(editor, 'this', editorElement); // necessary for Safari to detect a selection in the editor\n      button.focus();\n\n      assert.ok(document.activeElement !== editor.element, 'precond - editor element is not focused');\n      editor.toggleMarkup('b');\n    });\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition()));\n\n    _testHelpers['default'].wait(function () {\n      var inputChanged = 0;\n      editor.inputModeDidChange(function () {\n        return inputChanged++;\n      });\n\n      button.click();\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(inputChanged, 1, 'inputModeDidChange fired once');\n        assert.ok(document.activeElement === editor.element, 'editor element is focused');\n\n        done();\n      });\n    });\n  });\n\n  test('inputModeDidChange callback fired when toggling section', function (assert) {\n    var done = assert.async();\n    assert.expect(1);\n\n    _testHelpers['default'].dom.selectText(editor, 'this is', editorElement);\n\n    var inputChanged = 0;\n    editor.inputModeDidChange(function () {\n      return inputChanged++;\n    });\n\n    editor.toggleSection('h2');\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(inputChanged, 1, 'inputModeDidChange fired once');\n      done();\n    });\n  });\n\n  test('inputModeDidChange callback not fired when toggle is no-op', function (assert) {\n    var done = assert.async();\n    assert.expect(1);\n\n    _testHelpers['default'].dom.selectText(editor, 'this is', editorElement);\n\n    var inputChanged = 0;\n    editor.inputModeDidChange(function () {\n      return inputChanged++;\n    });\n\n    editor.toggleSection('p'); // toggling to same section is no-op\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(inputChanged, 0, 'inputModeDidChange not fired');\n      done();\n    });\n  });\n\n  test('inputModeDidChange callback fired when moving cursor into section', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n\n    editor.run(function (postEditor) {\n      var marker = postEditor.builder.createMarker('abc');\n      var newSection = postEditor.builder.createMarkupSection('h2', [marker]);\n      postEditor.insertSectionAtEnd(newSection);\n    });\n\n    var inputChanged = 0;\n    editor.inputModeDidChange(function () {\n      inputChanged++;\n    });\n\n    assert.hasElement('h2:contains(abc)', 'precond - inserted h2');\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.sections.tail.headPosition()));\n\n    _testHelpers['default'].wait(function () {\n      inputChanged = 0;\n\n      editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.sections.head.tailPosition()));\n\n      _testHelpers['default'].wait(function () {\n        assert.equal(inputChanged, 1, 'inputModeDidChange fired once');\n        done();\n      });\n    });\n  });\n\n  test('inputModeDidChange callback not fired when moving cursor into same section', function (assert) {\n    var done = assert.async();\n    assert.expect(2);\n\n    editor.run(function (postEditor) {\n      var marker = postEditor.builder.createMarker('abc');\n      var newSection = postEditor.builder.createMarkupSection('p', [marker]);\n      postEditor.insertSectionAtEnd(newSection);\n    });\n\n    assert.hasElement('p:contains(abc)', 'precond - inserted p');\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.sections.tail.headPosition()));\n\n    var inputChanged = 0;\n    editor.inputModeDidChange(function () {\n      return inputChanged++;\n    });\n\n    _testHelpers['default'].dom.triggerLeftArrowKey(editor);\n\n    _testHelpers['default'].wait(function () {\n      assert.equal(inputChanged, 0, 'inputModeDidChange not fired');\n      done();\n    });\n  });\n\n  test('inputModeDidChange called when changing from ul to ol', function (assert) {\n    assert.expect(4);\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition(), editor.post.tailPosition()));\n\n    var inputChanged = 0;\n    editor.inputModeDidChange(function () {\n      return inputChanged++;\n    });\n\n    editor.toggleSection('ul');\n\n    assert.hasElement('#editor ul li', 'created ul');\n    assert.equal(inputChanged, 1, 'precond - changed to ul');\n\n    editor.toggleSection('ol');\n\n    assert.hasElement('#editor ol li', 'created ol');\n    assert.equal(inputChanged, 2, 'inputModeDidChange fired after ul->ol');\n  });\n});","define('tests/unit/editor/editor-test', ['exports', 'mobiledoc-kit/editor/editor', 'mobiledoc-kit/renderers/editor-dom', 'mobiledoc-kit/utils/dom-utils', 'mobiledoc-kit/renderers/mobiledoc/0-2', 'mobiledoc-kit/utils/cursor/range', '../../test-helpers'], function (exports, _mobiledocKitEditorEditor, _mobiledocKitRenderersEditorDom, _mobiledocKitUtilsDomUtils, _mobiledocKitRenderersMobiledoc02, _mobiledocKitUtilsCursorRange, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editorElement = undefined,\n      editor = undefined;\n\n  _module('Unit: Editor', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor && !editor.isDestroyed) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('can render an editor via dom node reference', function (assert) {\n    editor = new _mobiledocKitEditorEditor['default']();\n    editor.render(editorElement);\n    assert.equal(editor.element, editorElement);\n    assert.ok(editor.post);\n  });\n\n  test('autofocused editor hasCursor and has non-blank range after rendering', function (assert) {\n    var done = assert.async();\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n\n      return post([markupSection('p')]);\n    });\n    editor = new _mobiledocKitEditorEditor['default']({ autofocus: true, mobiledoc: mobiledoc });\n    assert.ok(!editor.hasCursor(), 'precond - editor has no cursor');\n    assert.ok(editor.range.isBlank, 'precond - editor has blank range');\n\n    editor.render(editorElement);\n\n    _testHelpers['default'].wait(function () {\n      assert.ok(editor.hasCursor(), 'editor has cursor');\n      assert.ok(!editor.range.isBlank, 'editor has non-blank range');\n      done();\n    });\n  });\n\n  test('creating an editor with DOM node throws', function (assert) {\n    assert.throws(function () {\n      editor = new _mobiledocKitEditorEditor['default'](document.createElement('div'));\n    }, /accepts an options object/);\n  });\n\n  test('rendering an editor without a class name adds appropriate class', function (assert) {\n    editorElement.className = '';\n\n    editor = new _mobiledocKitEditorEditor['default']();\n    editor.render(editorElement);\n    assert.hasClass(editor.element, _mobiledocKitRenderersEditorDom.EDITOR_ELEMENT_CLASS_NAME);\n  });\n\n  test('rendering an editor adds EDITOR_ELEMENT_CLASS_NAME if not there', function (assert) {\n    editorElement.className = 'abc def';\n\n    editor = new _mobiledocKitEditorEditor['default']();\n    editor.render(editorElement);\n\n    assert.hasClass(editor.element, _mobiledocKitRenderersEditorDom.EDITOR_ELEMENT_CLASS_NAME, 'adds ' + _mobiledocKitRenderersEditorDom.EDITOR_ELEMENT_CLASS_NAME);\n    assert.hasClass(editor.element, 'abc', 'preserves existing classnames');\n    assert.hasClass(editor.element, 'def', 'preserves existing classnames');\n  });\n\n  test('rendering an editor adds EDITOR_HAS_NO_CONTENT_CLASS_NAME if post has no content', function (assert) {\n    editor = new _mobiledocKitEditorEditor['default']();\n    assert.ok(!editor.post.hasContent, 'precond - post has no content');\n    editor.render(editorElement);\n\n    assert.hasClass(editorElement, _mobiledocKitRenderersEditorDom.EDITOR_HAS_NO_CONTENT_CLASS_NAME);\n\n    // Firefox requires that the cursor be placed explicitly for this test to pass,\n    // `editor.focus()` won't work when running this test on CI in Firefox\n    _testHelpers['default'].dom.moveCursorTo(editor, editor.element, 0);\n\n    editor.insertText('abc');\n    assert.ok(editor.post.hasContent, 'editor has content');\n    assert.notHasClass(editorElement, _mobiledocKitRenderersEditorDom.EDITOR_HAS_NO_CONTENT_CLASS_NAME, 'removes \"' + _mobiledocKitRenderersEditorDom.EDITOR_HAS_NO_CONTENT_CLASS_NAME + '\" when editor has content');\n\n    editor.deleteRange(editor.post.toRange());\n    assert.hasClass(editorElement, _mobiledocKitRenderersEditorDom.EDITOR_HAS_NO_CONTENT_CLASS_NAME, 'adds \"' + _mobiledocKitRenderersEditorDom.EDITOR_HAS_NO_CONTENT_CLASS_NAME + '\" after editor content is all deleted');\n  });\n\n  test('editor fires lifecycle hooks', function (assert) {\n    assert.expect(4);\n    var didCallUpdatePost = undefined,\n        didCallWillRender = undefined,\n        didCallDidRender = undefined;\n    editor = new _mobiledocKitEditorEditor['default']();\n    editor.didUpdatePost(function (postEditor) {\n      assert.ok(postEditor, 'Post editor provided');\n      assert.ok(!didCallWillRender && !didCallDidRender, 'didUpdatePost called before render hooks');\n      didCallUpdatePost = true;\n    });\n    editor.willRender(function () {\n      assert.ok(didCallUpdatePost && !didCallDidRender, 'willRender called between didUpdatePost, didRender');\n      didCallWillRender = true;\n    });\n    editor.didRender(function () {\n      assert.ok(didCallUpdatePost && didCallWillRender, 'didRender called last');\n      didCallDidRender = true;\n    });\n    editor.render(editorElement);\n  });\n\n  test('editor fires lifecycle hooks for edit', function (assert) {\n    assert.expect(4);\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n\n      return post([markupSection()]);\n    });\n    editor = new _mobiledocKitEditorEditor['default']({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var didCallUpdatePost = undefined,\n        didCallWillRender = undefined,\n        didCallDidRender = undefined;\n    editor.didUpdatePost(function (postEditor) {\n      assert.ok(postEditor, 'Post editor provided');\n      assert.ok(!didCallWillRender && !didCallDidRender, 'didUpdatePost called before render hooks');\n      didCallUpdatePost = true;\n    });\n    editor.willRender(function () {\n      assert.ok(didCallUpdatePost && !didCallDidRender, 'willRender called between didUpdatePost, didRender');\n      didCallWillRender = true;\n    });\n    editor.didRender(function () {\n      assert.ok(didCallUpdatePost && didCallWillRender, 'didRender called last');\n      didCallDidRender = true;\n    });\n\n    editor.run(function (postEditor) {\n      postEditor.removeSection(editor.post.sections.head);\n    });\n  });\n\n  test('editor fires lifecycle hooks for noop edit', function (assert) {\n    assert.expect(1);\n    editor = new _mobiledocKitEditorEditor['default']();\n    editor.render(editorElement);\n\n    editor.didUpdatePost(function (postEditor) {\n      assert.ok(postEditor, 'Post editor provided');\n    });\n    editor.willRender(function () {\n      assert.ok(false, 'willRender should not be called');\n    });\n    editor.didRender(function () {\n      assert.ok(false, 'didRender should not be called');\n    });\n\n    editor.run(function () {});\n  });\n\n  test('editor parses and renders mobiledoc format', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      return post([markupSection('p', [marker('hello world')])]);\n    });\n    editorElement.innerHTML = '<p>something here</p>';\n    editor = new _mobiledocKitEditorEditor['default']({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    assert.ok(editor.mobiledoc, 'editor has mobiledoc');\n    assert.equal(editorElement.innerHTML, '<p>hello world</p>');\n\n    assert.deepEqual(editor.serialize(), mobiledoc, 'serialized editor === mobiledoc');\n  });\n\n  test('#serialize serializes to MOBILEDOC_VERSION by default', function (assert) {\n    var mobiledoc2 = _testHelpers['default'].mobiledoc.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    }, '0.2.0');\n    var mobiledoc3 = _testHelpers['default'].mobiledoc.build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    }, '0.3.0');\n    var mobiledoc3_1 = _testHelpers['default'].mobiledoc.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    }, '0.3.1');\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    assert.deepEqual(editor.serialize('0.2.0'), mobiledoc2, 'serializes 0.2.0');\n    assert.deepEqual(editor.serialize('0.3.0'), mobiledoc3, 'serializes 0.3.0');\n    assert.deepEqual(editor.serialize('0.3.1'), mobiledoc3_1, 'serializes 0.3.1');\n    assert.deepEqual(editor.serialize(), mobiledoc3_1, 'serializes 0.3.1 by default');\n\n    assert.throws(function () {\n      return editor.serialize('unknown');\n    }, /Unknown version/);\n  });\n\n  test('editor parses and renders html', function (assert) {\n    editorElement.innerHTML = '<p>something here</p>';\n    editor = new _mobiledocKitEditorEditor['default']({ html: '<p>hello world</p>' });\n    editor.render(editorElement);\n\n    assert.equal(editorElement.innerHTML, '<p>hello world</p>');\n  });\n\n  test('editor parses and renders DOM', function (assert) {\n    editorElement.innerHTML = '<p>something here</p>';\n    editor = new _mobiledocKitEditorEditor['default']({ html: $('<p>hello world</p>')[0] });\n    editor.render(editorElement);\n\n    assert.equal(editorElement.innerHTML, '<p>hello world</p>');\n  });\n\n  test('#detectMarkupInRange not found', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('p'), [[[], 0, 'hello world']]]]]\n    };\n    editor = new _mobiledocKitEditorEditor['default']({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var section = editor.post.sections.head;\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, section.text.length);\n    var markup = editor.detectMarkupInRange(range, 'strong');\n    assert.ok(!markup, 'selection is not strong');\n  });\n\n  test('#detectMarkupInRange matching bounds of marker', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[['strong']], [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('p'), [[[0], 1, 'hello world']]]]]\n    };\n    editor = new _mobiledocKitEditorEditor['default']({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    var section = editor.post.sections.head;\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, section.text.length);\n    var markup = editor.detectMarkupInRange(range, 'strong');\n    assert.ok(markup, 'selection has markup');\n    assert.equal(markup.tagName, 'strong', 'detected markup is strong');\n  });\n\n  test('useful error message when given invalid mobiledoc', function (assert) {\n    var badMobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [\"incorrect\"]]\n    };\n    assert.throws(function () {\n      new _mobiledocKitEditorEditor['default']({ mobiledoc: badMobiledoc });\n    }, /unable to parse.*mobiledoc/i);\n  });\n\n  test('useful error message when given bad version of mobiledoc', function (assert) {\n    var verybadMobiledoc = \"not mobiledoc\";\n    assert.throws(function () {\n      new _mobiledocKitEditorEditor['default']({ mobiledoc: verybadMobiledoc });\n    }, /Unknown version of mobiledoc parser requested/i);\n  });\n\n  test('activeSections of a rendered blank mobiledoc is an empty array', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref8) {\n      var post = _ref8.post;\n\n      return post();\n    });\n\n    assert.ok(editor.hasRendered, 'editor has rendered');\n    assert.equal(editor.activeSections.length, 0, 'empty activeSections');\n  });\n\n  test('activeSections is empty when the editor has no cursor', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    }, { autofocus: false });\n\n    assert.ok(!editor.hasCursor(), 'precond - no cursor');\n    assert.equal(editor.activeSections.length, 0, 'empty activeSections');\n  });\n\n  test('editor.cursor.hasCursor() is false before rendering', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref10) {\n      var post = _ref10.post;\n      return post();\n    });\n    editor = new _mobiledocKitEditorEditor['default']({ mobiledoc: mobiledoc });\n\n    assert.ok(!editor.cursor.hasCursor(), 'no cursor before rendering');\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement, 0);\n\n    assert.ok(!editor.cursor.hasCursor(), 'no cursor before rendering, even when selection exists');\n  });\n\n  test('#destroy clears selection if it has one', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref11) {\n      var post = _ref11.post;\n      return post();\n    });\n    editor = new _mobiledocKitEditorEditor['default']({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, editorElement, 0);\n    assert.ok(editor.cursor.hasCursor(), 'precond - has cursor');\n\n    editor.destroy();\n\n    assert.equal(window.getSelection().rangeCount, 0, 'selection is cleared');\n  });\n\n  test('#destroy does not clear selection if it is outside the editor element', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref12) {\n      var post = _ref12.post;\n      return post();\n    });\n    editor = new _mobiledocKitEditorEditor['default']({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n\n    _testHelpers['default'].dom.moveCursorTo(editor, $('#qunit-fixture')[0], 0);\n    assert.ok(!editor.cursor.hasCursor(), 'precond - has no cursor');\n    assert.equal(window.getSelection().rangeCount, 1, 'precond - has selection');\n\n    editor.destroy();\n\n    assert.equal(window.getSelection().rangeCount, 1, 'selection is not cleared');\n  });\n\n  test('editor parses HTML post using parser plugins', function (assert) {\n    var seenTagNames = [];\n    var parserPlugin = function parserPlugin(element) {\n      seenTagNames.push(element.tagName);\n    };\n    var html = '<p><textarea></textarea><img></p>';\n    editor = new _mobiledocKitEditorEditor['default']({ html: html, parserPlugins: [parserPlugin] });\n    assert.ok(!!editor.post, 'editor loads post');\n\n    assert.deepEqual(seenTagNames, ['P', 'TEXTAREA', 'IMG']);\n  });\n\n  test('#activeMarkups returns the markups at cursor when range is collapsed', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref13) {\n      var post = _ref13.post;\n      var markupSection = _ref13.markupSection;\n      var marker = _ref13.marker;\n      var markup = _ref13.markup;\n\n      return post([markupSection('p', [marker('abc'), marker('def', [markup('b')]), marker('ghi')])]);\n    });\n\n    var head = editor.post.sections.head;\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abc'.length));\n    assert.equal(editor.activeMarkups.length, 0, 'no active markups at left of bold text');\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abcd'.length));\n    assert.equal(editor.activeMarkups.length, 1, 'active markups in bold text');\n    assert.ok(editor.hasActiveMarkup('b'), 'has bold active markup');\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abcdef'.length));\n    assert.equal(editor.activeMarkups.length, 1, 'active markups at end of bold text');\n    assert.ok(editor.hasActiveMarkup('b'), 'has bold active markup');\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abcdefg'.length));\n    assert.equal(editor.activeMarkups.length, 0, 'no active markups after end of bold text');\n  });\n\n  test('#hasActiveMarkup returns true for complex markups', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref14) {\n      var post = _ref14.post;\n      var markupSection = _ref14.markupSection;\n      var marker = _ref14.marker;\n      var markup = _ref14.markup;\n\n      return post([markupSection('p', [marker('abc '), marker('def', [markup('a', { href: 'http://bustle.com' })]), marker(' ghi')])]);\n    });\n\n    var head = editor.post.sections.head;\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abc '.length));\n    assert.equal(editor.activeMarkups.length, 0, 'no active markups at left of linked text');\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abc d'.length));\n    assert.equal(editor.activeMarkups.length, 1, 'active markups in linked text');\n    assert.ok(editor.hasActiveMarkup('a'), 'has A active markup');\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abc def'.length));\n    assert.equal(editor.activeMarkups.length, 0, 'active markups at end of linked text');\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(head, 'abc def '.length));\n    assert.equal(editor.activeMarkups.length, 0, 'no active markups after end of linked text');\n  });\n\n  test('#insertText inserts text at cursor position, replacing existing range if non-collapsed', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref15) {\n      var post = _ref15.post;\n      var markupSection = _ref15.markupSection;\n      var marker = _ref15.marker;\n\n      return post([markupSection('p', [marker('b')])]);\n    });\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n    editor.insertText('Z');\n    assert.equal(editor.post.sections.head.text, 'bZ');\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition()));\n    editor.insertText('A');\n    assert.equal(editor.post.sections.head.text, 'AbZ');\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(editor.post.sections.head, 'A'.length));\n    editor.insertText('B');\n    assert.equal(editor.post.sections.head.text, 'ABbZ');\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition(), editor.post.tailPosition()));\n    editor.insertText('new stuff');\n    assert.equal(editor.post.sections.head.text, 'new stuff');\n  });\n\n  test('#insertText inserts text at cursor position, inheriting active markups', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref16) {\n      var post = _ref16.post;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n      var markup = _ref16.markup;\n\n      return post([markupSection('p', [marker('a'), marker('b', [markup('b')])])]);\n    });\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n    assert.equal(editor.activeMarkups.length, 1, 'precond - 1 active markup');\n    editor.insertText('Z');\n    assert.hasElement('#editor b:contains(bZ)');\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition()));\n    assert.equal(editor.activeMarkups.length, 0, 'precond - 0 active markups at start');\n    editor.toggleMarkup('b');\n    editor.insertText('A');\n\n    assert.hasElement('#editor b:contains(A)');\n  });\n\n  test('#insertText is no-op when editor does not have cursor', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var marker = _ref17.marker;\n\n      expected = post([markupSection('p', [marker('abc')])]);\n      return post([markupSection('p', [marker('abc')])]);\n    }, { autofocus: false });\n\n    assert.ok(!editor.hasCursor(), 'precond - editor has no cursor');\n    editor.insertText('blah blah blah');\n\n    assert.postIsSimilar(editor.post, expected, 'post is not changed');\n  });\n\n  test('#insertText when post is blank', function (assert) {\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref18) {\n      var post = _ref18.post;\n      var markupSection = _ref18.markupSection;\n      var marker = _ref18.marker;\n\n      expected = post([markupSection('p', [marker('blah blah')])]);\n      return post();\n    });\n\n    // Necessary to ensure tests pass on FF when the window is not active\n    _testHelpers['default'].dom.selectRange(editorElement, 0, editorElement, 0);\n\n    assert.ok(editor.hasCursor(), 'precond - editor has cursor');\n    assert.ok(editor.post.isBlank, 'precond - editor has blank post');\n    editor.insertText('blah blah');\n\n    assert.postIsSimilar(editor.post, expected, 'text is added to post');\n  });\n\n  test('#insertAtom inserts atom at cursor position, replacing range if non-collapsed', function (assert) {\n    var atom = {\n      name: 'the-atom',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref19) {\n      var post = _ref19.post;\n      var markupSection = _ref19.markupSection;\n      var marker = _ref19.marker;\n\n      return post([markupSection('p', [marker('b')])]);\n    }, { atoms: [atom] });\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n    editor.insertAtom('the-atom', 'END');\n\n    assert.equal(editor.post.sections.head.text, 'bEND');\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition()));\n    editor.insertAtom('the-atom', 'START');\n    assert.equal(editor.post.sections.head.text, 'STARTbEND');\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition(), editor.post.tailPosition()));\n    editor.insertAtom('the-atom', 'REPLACE-ALL');\n    assert.equal(editor.post.sections.head.text, 'REPLACE-ALL');\n  });\n\n  test('#insertAtom is no-op when editor does not have cursor', function (assert) {\n    var atom = {\n      name: 'the-atom',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref20) {\n      var post = _ref20.post;\n      var markupSection = _ref20.markupSection;\n      var marker = _ref20.marker;\n\n      expected = post([markupSection('p', [marker('abc')])]);\n      return post([markupSection('p', [marker('abc')])]);\n    }, { atoms: [atom], autofocus: false });\n\n    assert.ok(!editor.hasCursor(), 'precond - editor has no cursor');\n    editor.insertAtom('the-atom');\n\n    assert.postIsSimilar(editor.post, expected, 'post is not changed');\n  });\n\n  test('#insertAtom when post is blank', function (assert) {\n    var atom = {\n      name: 'the-atom',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref21) {\n      var post = _ref21.post;\n      var atom = _ref21.atom;\n      var markupSection = _ref21.markupSection;\n\n      expected = post([markupSection('p', [atom('the-atom', 'THEATOMTEXT')])]);\n      return post();\n    }, { atoms: [atom] });\n\n    _testHelpers['default'].dom.selectRange(editorElement, 0, editorElement, 0);\n\n    assert.ok(editor.hasCursor(), 'precond - editor has cursor');\n    assert.ok(editor.post.isBlank, 'precond - post is blank');\n    editor.insertAtom('the-atom', 'THEATOMTEXT');\n\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  test('#insertAtom returns the inserted atom', function (assert) {\n    var atom = {\n      name: 'the-atom',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref22) {\n      var post = _ref22.post;\n\n      return post();\n    }, { atoms: [atom] });\n\n    // Force the selection -- this is necessary for tests in Firefox at\n    // SauceLabs.\n    _testHelpers['default'].dom.selectRange(editorElement, 0, editorElement, 0);\n\n    assert.ok(editor.hasCursor(), 'precond - editor has cursor');\n\n    var insertedAtom = editor.insertAtom('the-atom', 'THEATOMTEXT');\n\n    assert.equal(insertedAtom.value, 'THEATOMTEXT', 'return value is the inserted atom');\n  });\n\n  test('#insertCard inserts card at section after cursor position, replacing range if non-collapsed', function (assert) {\n    var card = {\n      name: 'the-card',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref23) {\n      var post = _ref23.post;\n      var markupSection = _ref23.markupSection;\n      var marker = _ref23.marker;\n\n      return post([markupSection('p', [marker('b')])]);\n    }, { cards: [card] });\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.tailPosition()));\n    editor.insertCard('the-card');\n\n    assert.equal(editor.post.sections.length, 2, 'adds a section at end');\n    assert.ok(editor.post.sections.tail.isCardSection, 'added section is card section');\n\n    editor.run(function (postEditor) {\n      var blankSection = postEditor.builder.createMarkupSection();\n\n      var firstSection = editor.post.sections.head;\n      var collection = editor.post.sections;\n      postEditor.insertSectionBefore(collection, blankSection, firstSection);\n    });\n\n    assert.equal(editor.post.sections.length, 3, 'precond - adds blank section at start');\n    assert.ok(!editor.post.sections.head.isCardSection, 'precond - initial section is not card section');\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition()));\n    editor.insertCard('the-card');\n\n    assert.equal(editor.post.sections.length, 3, 'replaced initial blank section with card');\n    assert.ok(editor.post.sections.head.isCardSection, 'initial section is card section');\n\n    editor.selectRange(new _mobiledocKitUtilsCursorRange['default'](editor.post.headPosition(), editor.post.tailPosition()));\n    editor.insertCard('the-card');\n    assert.equal(editor.post.sections.length, 1, 'replaces range with card section');\n    assert.ok(editor.post.sections.head.isCardSection, 'initial section is card section');\n  });\n\n  test('#insertCard when cursor is in list item', function (assert) {\n    var card = {\n      name: 'the-card',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref24) {\n      var post = _ref24.post;\n      var markupSection = _ref24.markupSection;\n      var marker = _ref24.marker;\n      var listItem = _ref24.listItem;\n      var listSection = _ref24.listSection;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')])])]);\n    }, { cards: [card] });\n\n    editor.selectRange(_mobiledocKitUtilsCursorRange['default'].create(editor.post.sections.head.items.head, 'ab'.length));\n    editor.insertCard('the-card');\n\n    assert.equal(editor.post.sections.length, 2, 'adds a second section');\n    assert.ok(editor.post.sections.tail.isCardSection, 'tail section is card section');\n  });\n\n  test('#insertCard is no-op when editor does not have cursor', function (assert) {\n    var card = {\n      name: 'the-card',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref25) {\n      var post = _ref25.post;\n      var markupSection = _ref25.markupSection;\n      var marker = _ref25.marker;\n\n      expected = post([markupSection('p', [marker('abc')])]);\n      return post([markupSection('p', [marker('abc')])]);\n    }, { cards: [card], autofocus: false });\n\n    assert.ok(!editor.hasCursor(), 'precond - editor has no cursor');\n    editor.insertCard('the-card');\n\n    assert.postIsSimilar(editor.post, expected, 'post is not changed');\n  });\n\n  test('#insertCard when post is blank', function (assert) {\n    var card = {\n      name: 'the-card',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    var expected = undefined;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref26) {\n      var post = _ref26.post;\n      var cardSection = _ref26.cardSection;\n\n      expected = post([cardSection('the-card')]);\n      return post();\n    }, { cards: [card] });\n\n    _testHelpers['default'].dom.selectRange(editorElement, 0, editorElement, 0);\n\n    assert.ok(editor.hasCursor(), 'precond - editor has cursor');\n    assert.ok(editor.post.isBlank, 'precond - post is blank');\n\n    editor.insertCard('the-card');\n\n    assert.postIsSimilar(editor.post, expected, 'adds card section');\n  });\n\n  test('#insertCard returns card object', function (assert) {\n    var card = {\n      name: 'the-card',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref27) {\n      var post = _ref27.post;\n\n      return post();\n    }, { cards: [card] });\n\n    _testHelpers['default'].dom.selectRange(editorElement, 0, editorElement, 0);\n\n    assert.ok(editor.hasCursor(), 'precond - editor has cursor');\n    assert.ok(editor.post.isBlank, 'precond - post is blank');\n\n    var insertedCard = editor.insertCard('the-card');\n\n    assert.ok(!!insertedCard, 'insertedCard is present');\n    assert.equal(editor.post.sections.tail, insertedCard, 'returned card is the inserted card');\n  });\n\n  test('#insertCard focuses the cursor at the end of the card', function (assert) {\n    var card = {\n      name: 'the-card',\n      type: 'dom',\n      render: function render() {}\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref28) {\n      var post = _ref28.post;\n\n      return post();\n    }, { cards: [card] });\n\n    _testHelpers['default'].dom.selectRange(editorElement, 0, editorElement, 0);\n\n    var insertedCard = editor.insertCard('the-card');\n\n    var range = editor.range;\n    assert.positionIsEqual(range.head, insertedCard.tailPosition(), 'range head on card tail');\n    assert.positionIsEqual(range.tail, insertedCard.tailPosition(), 'range tail on card tail');\n    assert.ok(document.activeElement === editorElement, 'editor element retains focus');\n  });\n\n  test('#toggleMarkup removes A tag when no attributes given', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref29) {\n      var post = _ref29.post;\n      var markupSection = _ref29.markupSection;\n      var marker = _ref29.marker;\n      var markup = _ref29.markup;\n\n      return post([markupSection('p', [marker('^'), marker('link', [markup('a', { href: 'google.com' })]), marker('$')])]);\n    });\n    _testHelpers['default'].dom.selectText(editor, 'link');\n    editor.toggleMarkup('a');\n\n    assert.selectedText('link', 'text \"link\" still selected');\n    assert.ok(editor.hasCursor(), 'editor has cursor');\n    assert.hasElement('#editor p:contains(^link$)');\n    assert.hasNoElement('#editor a', 'a tag is removed');\n  });\n\n  test('#toggleMarkup adds A tag with attributes', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref30) {\n      var post = _ref30.post;\n      var markupSection = _ref30.markupSection;\n      var marker = _ref30.marker;\n      var markup = _ref30.markup;\n\n      return post([markupSection('p', [marker('^link$')])]);\n    });\n    _testHelpers['default'].dom.selectText(editor, 'link');\n    editor.toggleMarkup('a', { href: 'google.com' });\n\n    assert.selectedText('link', 'text \"link\" still selected');\n    assert.ok(editor.hasCursor(), 'editor has cursor');\n    assert.hasElement('#editor a:contains(link)');\n    assert.hasElement('#editor a[href=\"google.com\"]:contains(link)');\n  });\n\n  test('#toggleMarkup calls #beforeToggleMarkup hooks', function (assert) {\n    assert.expect(5 * 3 + 2);\n\n    var callbackCount = 0;\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref31) {\n      var post = _ref31.post;\n      var markupSection = _ref31.markupSection;\n      var marker = _ref31.marker;\n      var markup = _ref31.markup;\n\n      return post([markupSection('p', [marker('^link$')])]);\n    });\n    _testHelpers['default'].dom.selectText(editor, 'link');\n    var callback = function callback(_ref32) {\n      var markup = _ref32.markup;\n      var range = _ref32.range;\n      var willAdd = _ref32.willAdd;\n\n      assert.ok(true, 'calls #beforeToggleMarkup');\n      assert.equal(markup.tagName, 'a', 'passes markup');\n      assert.equal(markup.getAttribute('href'), 'google.com', 'passes markup with attrs');\n      assert.ok(!!range, 'passes a range');\n      assert.ok(willAdd, 'correct value for willAdd');\n      callbackCount++;\n    };\n\n    // 3 times\n    editor.beforeToggleMarkup(callback);\n    editor.beforeToggleMarkup(callback);\n    editor.beforeToggleMarkup(callback);\n\n    editor.toggleMarkup('a', { href: 'google.com' });\n    assert.equal(callbackCount, 3, 'calls once for each callback');\n    assert.hasElement('#editor a[href=\"google.com\"]:contains(link)', 'adds link');\n  });\n\n  test('#toggleMarkup is canceled if #beforeToggleMarkup hook returns false', function (assert) {\n    assert.expect(2);\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref33) {\n      var post = _ref33.post;\n      var markupSection = _ref33.markupSection;\n      var marker = _ref33.marker;\n      var markup = _ref33.markup;\n\n      return post([markupSection('p', [marker('^link$')])]);\n    });\n    _testHelpers['default'].dom.selectText(editor, 'link');\n    var callback = function callback(_ref34) {\n      var markup = _ref34.markup;\n      var range = _ref34.range;\n      var willAdd = _ref34.willAdd;\n\n      assert.ok(true, 'calls #beforeToggleMarkup');\n      return false;\n    };\n\n    editor.beforeToggleMarkup(callback);\n\n    editor.toggleMarkup('a', { href: 'google.com' });\n    assert.hasNoElement('#editor a', 'not adds link');\n  });\n});","define('tests/unit/editor/key-commands-test', ['exports', 'mobiledoc-kit/editor/key-commands', 'mobiledoc-kit/utils/key', 'mobiledoc-kit/utils/keycodes', '../../test-helpers'], function (exports, _mobiledocKitEditorKeyCommands, _mobiledocKitUtilsKey, _mobiledocKitUtilsKeycodes, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var SPECIAL_KEYS = {\n    BACKSPACE: _mobiledocKitUtilsKeycodes['default'].BACKSPACE,\n    TAB: _mobiledocKitUtilsKeycodes['default'].TAB,\n    ENTER: _mobiledocKitUtilsKeycodes['default'].ENTER,\n    ESC: _mobiledocKitUtilsKeycodes['default'].ESC,\n    SPACE: _mobiledocKitUtilsKeycodes['default'].SPACE,\n    PAGEUP: _mobiledocKitUtilsKeycodes['default'].PAGEUP,\n    PAGEDOWN: _mobiledocKitUtilsKeycodes['default'].PAGEDOWN,\n    END: _mobiledocKitUtilsKeycodes['default'].END,\n    HOME: _mobiledocKitUtilsKeycodes['default'].HOME,\n    LEFT: _mobiledocKitUtilsKeycodes['default'].LEFT,\n    UP: _mobiledocKitUtilsKeycodes['default'].UP,\n    RIGHT: _mobiledocKitUtilsKeycodes['default'].RIGHT,\n    DOWN: _mobiledocKitUtilsKeycodes['default'].DOWN,\n    INS: _mobiledocKitUtilsKeycodes['default'].INS,\n    DEL: _mobiledocKitUtilsKeycodes['default'].DELETE\n  };\n\n  _module('Unit: Editor key commands');\n\n  test('leaves modifier, code and run in place if they exist', function (assert) {\n    var fn = function fn() {};\n\n    var _buildKeyCommand = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({\n      code: _mobiledocKitUtilsKeycodes['default'].ENTER,\n      modifier: _mobiledocKitUtilsKey.MODIFIERS.META,\n      run: fn\n    });\n\n    var modifier = _buildKeyCommand.modifier;\n    var code = _buildKeyCommand.code;\n    var run = _buildKeyCommand.run;\n\n    assert.equal(modifier, _mobiledocKitUtilsKey.MODIFIERS.META, 'keeps modifier');\n    assert.equal(code, _mobiledocKitUtilsKeycodes['default'].ENTER, 'keeps code');\n    assert.equal(run, fn, 'keeps run');\n  });\n\n  test('translates MODIFIER+CHARACTER string to modifierMask and code', function (assert) {\n    var _buildKeyCommand2 = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'meta+k' });\n\n    var modifierMask = _buildKeyCommand2.modifierMask;\n    var code = _buildKeyCommand2.code;\n\n    assert.equal(modifierMask, (0, _mobiledocKitUtilsKey.modifierMask)({ metaKey: true }), 'calculates correct modifierMask');\n    assert.equal(code, 75, 'translates string to code');\n  });\n\n  test('translates modifier+character string to modifierMask and code', function (assert) {\n    var _buildKeyCommand3 = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'META+K' });\n\n    var modifierMask = _buildKeyCommand3.modifierMask;\n    var code = _buildKeyCommand3.code;\n\n    assert.equal(modifierMask, (0, _mobiledocKitUtilsKey.modifierMask)({ metaKey: true }), 'calculates correct modifierMask');\n    assert.equal(code, 75, 'translates string to code');\n  });\n\n  test('translates multiple modifiers to modifierMask', function (assert) {\n    var _buildKeyCommand4 = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'META+SHIFT+K' });\n\n    var modifierMask = _buildKeyCommand4.modifierMask;\n    var code = _buildKeyCommand4.code;\n\n    assert.equal(modifierMask, (0, _mobiledocKitUtilsKey.modifierMask)({ metaKey: true, shiftKey: true }), 'calculates correct modifierMask');\n    assert.equal(code, 75, 'translates string to code');\n  });\n\n  test('translates uppercase character string to code', function (assert) {\n    var _buildKeyCommand5 = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'K' });\n\n    var modifierMask = _buildKeyCommand5.modifierMask;\n    var code = _buildKeyCommand5.code;\n\n    assert.equal(modifierMask, 0, 'no modifier given');\n    assert.equal(code, 75, 'translates string to code');\n  });\n\n  test('translates lowercase character string to code', function (assert) {\n    var _buildKeyCommand6 = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'k' });\n\n    var modifier = _buildKeyCommand6.modifier;\n    var code = _buildKeyCommand6.code;\n\n    assert.equal(modifier, undefined, 'no modifier given');\n    assert.equal(code, 75, 'translates string to code');\n  });\n\n  test('throws when given invalid modifier', function (assert) {\n    assert.throws(function () {\n      (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'MEAT+K' });\n    }, /No modifier named.*MEAT.*/);\n  });\n\n  test('throws when given `modifier` property (deprecation)', function (assert) {\n    assert.throws(function () {\n      (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'K', modifier: _mobiledocKitUtilsKey.MODIFIERS.META });\n    }, /Key commands no longer use.*modifier.* property/);\n  });\n\n  test('throws when given str with too many characters', function (assert) {\n    assert.throws(function () {\n      (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: 'abc' });\n    }, /Only 1 character/);\n  });\n\n  test('translates uppercase special key names to codes', function (assert) {\n    Object.keys(SPECIAL_KEYS).forEach(function (name) {\n      var _buildKeyCommand7 = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: name.toUpperCase() });\n\n      var code = _buildKeyCommand7.code;\n\n      assert.equal(code, SPECIAL_KEYS[name], 'translates ' + name + ' string to code');\n    });\n  });\n\n  test('translates lowercase special key names to codes', function (assert) {\n    Object.keys(SPECIAL_KEYS).forEach(function (name) {\n      var _buildKeyCommand8 = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({ str: name.toLowerCase() });\n\n      var code = _buildKeyCommand8.code;\n\n      assert.equal(code, SPECIAL_KEYS[name], 'translates ' + name + ' string to code');\n    });\n  });\n\n  test('`findKeyCommands` matches modifiers exactly', function (assert) {\n    var cmdK = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({\n      str: 'META+K'\n    });\n    var cmdShiftK = (0, _mobiledocKitEditorKeyCommands.buildKeyCommand)({\n      str: 'META+SHIFT+K'\n    });\n    var commands = [cmdK, cmdShiftK];\n\n    var element = null;\n    var cmdKEvent = _testHelpers['default'].dom.createMockEvent('keydown', element, {\n      keyCode: 75,\n      metaKey: true\n    });\n    var cmdShiftKEvent = _testHelpers['default'].dom.createMockEvent('keydown', element, {\n      keyCode: 75,\n      metaKey: true,\n      shiftKey: true\n    });\n\n    var found = (0, _mobiledocKitEditorKeyCommands.findKeyCommands)(commands, cmdKEvent);\n    assert.ok(found.length && found[0] === cmdK, 'finds cmd-K command from cmd-k event');\n\n    found = (0, _mobiledocKitEditorKeyCommands.findKeyCommands)(commands, cmdShiftKEvent);\n    assert.ok(found.length && found[0] === cmdShiftK, 'finds cmd-shift-K command from cmd-shift-k event');\n  });\n});","define('tests/unit/editor/post-delete-at-position-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/key'], function (exports, _testHelpers, _mobiledocKitUtilsKey) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var FORWARD = _mobiledocKitUtilsKey.DIRECTION.FORWARD;\n  var BACKWARD = _mobiledocKitUtilsKey.DIRECTION.BACKWARD;\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n  var run = _testHelpers['default'].postEditor.run;\n  var buildFromText = _testHelpers['default'].postAbstract.buildFromText;\n  var retargetPosition = _testHelpers['default'].editor.retargetPosition;\n\n  _module('Unit: PostEditor: #deleteAtPosition');\n\n  var expectationGroups = [{\n    name: 'single markup section',\n    direction: BACKWARD,\n    expectations: [['abc|def', 'ab|def', 'middle'], ['abcdef|', 'abcde|', 'end'], ['|abcdef', '|abcdef', 'start'], ['ab *cd*| ef', 'ab *c*| ef', 'markup (right side)'], ['ab |*cd* ef', 'ab|*cd* ef', 'markup (left side)'], ['ab @| ef', 'ab | ef', 'atom (right side)'], ['ab |@ ef', 'ab|@ ef', 'atom (left side)']]\n  }, {\n    name: 'single markup section',\n    direction: FORWARD,\n    expectations: [['abc|def', 'abc|ef', 'middle'], ['abcdef|', 'abcdef|', 'end'], ['|abcdef', '|bcdef', 'start'], ['ab *cd*| ef', 'ab *cd*|ef', 'markup (right side)'], ['ab |*cd* ef', 'ab |*d* ef', 'markup (left side)'], ['ab @| ef', 'ab @|ef', 'atom (right side)'], ['ab |@ ef', 'ab | ef', 'atom (left side)']]\n  }, {\n    name: 'across section boundary',\n    direction: BACKWARD,\n    expectations: [[['abc', '|def'], 'abc|def', 'markup sections'], [['*abc*', '|def'], '*abc*|def', 'markup sections with markup'], [['[abc]', '|def'], ['[abc]|', 'def'], 'prev section is card'], [['abc', '|[def]'], ['abc|', '[def]'], 'cur section is card'], [['', '|abc'], ['|abc'], 'prev section is blank']]\n  }, {\n    name: 'across section boundary',\n    direction: FORWARD,\n    expectations: [[['abc|', 'def'], 'abc|def', 'markup sections'], [['*abc*|', 'def'], '*abc*|def', 'markup sections with markup'], [['[abc]|', 'def'], ['[abc]|', 'def'], 'cur section is card'], [['abc|', '[def]'], ['abc|', '[def]'], 'next section is card'], [['abc|', ''], ['abc|'], 'next section is blank']]\n  }, {\n    name: 'across list item boundary',\n    direction: BACKWARD,\n    expectations: [[['* abc', '* |def'], ['* abc', '|def'], 'start of list item'], [['* abc', '|def'], ['* abc|def'], 'into list item'], [['', '* |abc'], ['', '|abc'], 'prev blank section']]\n  }, {\n    name: 'across list item boundary',\n    direction: FORWARD,\n    expectations: [[['* abc|', '* def'], ['* abc|def'], 'item into item'], [['* abc|', 'def'], ['* abc|def'], 'item into markup'], [['abc|', '* def'], ['abc|def'], 'markup into markup']]\n  }];\n\n  expectationGroups.forEach(function (_ref) {\n    var name = _ref.name;\n    var expectations = _ref.expectations;\n    var direction = _ref.direction;\n\n    expectations.forEach(function (_ref2) {\n      var _ref22 = _slicedToArray(_ref2, 3);\n\n      var before = _ref22[0];\n      var after = _ref22[1];\n      var msg = _ref22[2];\n\n      var dir = direction === FORWARD ? 'forward' : 'backward';\n      test(dir + ': ' + name + ', \"' + before + '\" -> \"' + after + '\" (' + msg + ')', function (assert) {\n        var _buildFromText = buildFromText(before);\n\n        var post = _buildFromText.post;\n        var position = _buildFromText.range.head;\n\n        var _buildFromText2 = buildFromText(after);\n\n        var expectedPost = _buildFromText2.post;\n        var expectedPosition = _buildFromText2.range.head;\n\n        position = run(post, function (postEditor) {\n          return postEditor.deleteAtPosition(position, direction);\n        });\n        expectedPosition = retargetPosition(expectedPosition, post);\n\n        assert.postIsSimilar(post, expectedPost);\n        assert.positionIsEqual(position, expectedPosition);\n      });\n    });\n  });\n});","define('tests/unit/editor/post-delete-range-test', ['exports', '../../test-helpers'], function (exports, _testHelpers) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n  var run = _testHelpers['default'].postEditor.run;\n  var buildFromText = _testHelpers['default'].postAbstract.buildFromText;\n  var retargetRange = _testHelpers['default'].editor.retargetRange;\n\n  _module('Unit: PostEditor: #deleteRange');\n\n  test('with collapsed range is no-op', function (assert) {\n    var _buildFromText = buildFromText('abc|def');\n\n    var post = _buildFromText.post;\n    var range = _buildFromText.range;\n\n    var _buildFromText2 = buildFromText('abc|def');\n\n    var expectedPost = _buildFromText2.post;\n    var expectedRange = _buildFromText2.range;\n\n    var position = run(post, function (postEditor) {\n      return postEditor.deleteRange(range);\n    });\n\n    expectedRange = retargetRange(expectedRange, post);\n\n    assert.postIsSimilar(post, expectedPost);\n    assert.rangeIsEqual(position.toRange(), expectedRange);\n  });\n\n  var expectationGroups = [{\n    name: 'within a section (single section)',\n    expectations: [['ab<c>', 'ab|', 'at tail'], ['<a>bc', '|bc', 'at head'], ['a<b>c', 'a|c', 'middle']]\n  }, {\n    name: 'within a section with markup (single section)',\n    expectations: [['abc <*def*> ghi', 'abc | ghi', 'entire markup in middle'], ['abc *de<f* ghi>', 'abc *de|*', 'partial markup at end'], ['abc *de<f* g>hi', 'abc *de|*hi', 'partial markup in middle (right)'], ['ab<c *de>f* ghi', 'ab*|f* ghi', 'partial markup in middle (left)'], ['<abc *de>f* ghi', '*|f* ghi', 'partial markup at start']]\n  }, {\n    name: 'across markup section boundaries',\n    expectations: [[['abc<', '>def'], 'abc|def', 'at boundary'], [['abc<', 'd>ef'], 'abc|ef', 'boundary into next section'], [['ab<c', '>def'], 'ab|def', 'section into boundary'], [['ab<c', 'd>ef'], 'ab|ef', 'containing boundary'], [['abc<', 'def', '>ghi'], 'abc|ghi', 'across section at boundary'], [['abc<', 'def', 'g>hi'], 'abc|hi', 'across section boundary containing next section'], [['ab<c', 'def', '>ghi'], 'ab|ghi', 'across section boundary containing before section'], [['ab<c', 'def', 'g>hi'], 'ab|hi', 'across section boundary containing before and after section']]\n  }, {\n    name: 'across markup section boundaries including markups',\n    expectations: [[['*abc*<', '>def'], '*abc*|def', 'at boundary (left markup)'], [['*abc*<', 'd>ef'], '*abc*|ef', 'boundary into next section (left markup)'], [['*ab<c*', '>def'], '*ab*|def', 'section into boundary (left markup)'], [['*ab<c*', 'd>ef'], '*ab*|ef', 'containing boundary (left markup)'], [['abc<', '*>def*'], 'abc|*def*', 'at boundary (right markup)'], [['abc<', '*d>ef*'], 'abc|*ef*', 'boundary into next section (right markup)'], [['ab<c', '*>def*'], 'ab|*def*', 'section into boundary (right markup)'], [['ab<c', '*d>ef*'], 'ab|*ef*', 'containing boundary (right markup)'], [['abc<', '*def*', '>ghi'], 'abc|ghi', 'across section at boundary (containing markup)'], [['abc<', '*def*', 'g>hi'], 'abc|hi', 'across section boundary containing next section (containing markup)'], [['ab<c', '*def*', '>ghi'], 'ab|ghi', 'across section boundary containing before section (containing markup)'], [['ab<c', '*def*', 'g>hi'], 'ab|hi', 'across section boundary containing before and after section (containing markup)'], [['abc<', '*def*', '>*g*hi'], 'abc|*g*hi', 'across section at boundary (into markup)'], [['abc<', '*def*', '*g*>hi'], 'abc|hi', 'across section boundary containing next section (into markup)'], [['ab<c', '*def*', '>*g*hi'], 'ab|*g*hi', 'across section boundary containing before section (into markup)'], [['ab<c', '*def*', '*g*>hi'], 'ab|hi', 'across section boundary containing before and after section (into markup)']]\n  }, {\n    name: 'across markup/non-markup section boundaries',\n    expectations: [[['[some-card]<', '>abc'], ['[some-card]|', 'abc'], 'card->markup start'], [['[some-card]<', '>'], ['[some-card]|'], 'card->blank-markup'], [['<[some-card]', 'a>bc'], ['|bc'], 'card->markup inner'], [['abc<', '>[some-card]'], ['abc|', '[some-card]'], 'markup->card'], [['abc<', '[some-card]', '>def'], ['abc|def'], 'containing card, boundaries in outer sections'], [['abc', '<[some-card]>', 'def'], ['abc', '|', 'def'], 'containing card, boundaries in card section'], [['<', '>[some-card]'], ['|[some-card]'], 'blank section into card']]\n  }, {\n    name: 'across list items',\n    expectations: [[['* item 1<', '* >item 2'], ['* item 1|item 2'], 'at boundary'], [['* item <1', '* i>tem 2'], ['* item |tem 2'], 'surrounding boundary'], [['* item 1<', '* i>tem 2'], ['* item 1|tem 2'], 'boundary to next'], [['* item <1', '* >item 2'], ['* item |item 2'], 'prev to boundary'], [['* item 1<', '* middle', '* >item 2'], ['* item 1|item 2'], 'across item at boundary'], [['* item <1', '* middle', '* i>tem 2'], ['* item |tem 2'], 'across item surrounding boundary'], [['* item <1', '* middle', '* >item 2'], ['* item |item 2'], 'across item prev to boundary'], [['* item 1<', '* middle', '* i>tem 2'], ['* item 1|tem 2'], 'across item boundary to next'], [['* item 1<', 'middle', '* >item 2'], ['* item 1|item 2'], 'across markup at boundary'], [['* item <1', 'middle', '* i>tem 2'], ['* item |tem 2'], 'across markup surrounding boundary'], [['* item 1', '<middle', '* i>tem 2'], ['* item 1', '|tem 2'], 'across markup into next'], [['* item 1<', '>middle'], ['* item 1|middle'], 'item tail to markup head'], [['start<', '* >middle'], ['start|middle'], 'markup tail to item head'], [['* <', '>abc'], ['* |abc'], 'empty li into markup start'], [['* <', 'a>bc'], ['* |bc'], 'empty li into markup middle'], [['* <', 'abc>'], ['* |'], 'empty li into markup end'], [['* abc<', '>'], ['* abc|'], 'li into empty markup'], [['* <', '>'], ['* |'], 'empty li into empty markup']]\n  }, {\n    name: 'with atoms',\n    expectations: [['abc<@>def', 'abc|def', 'surrounding'], ['abc<@d>ef', 'abc|ef', 'into atom into next marker'], ['ab<c@>def', 'ab|def', 'into marker into atom'], ['ab<c>@def', 'ab|@def', 'prev boundary'], ['abc@<d>ef', 'abc@|ef', 'next boundary']]\n  }];\n\n  expectationGroups.forEach(function (_ref) {\n    var name = _ref.name;\n    var expectations = _ref.expectations;\n\n    expectations.forEach(function (_ref2) {\n      var _ref22 = _slicedToArray(_ref2, 3);\n\n      var before = _ref22[0];\n      var after = _ref22[1];\n      var msg = _ref22[2];\n\n      test(name + ', \"' + before + '\" -> \"' + after + '\" (' + msg + ')', function (assert) {\n        var _buildFromText3 = buildFromText(before);\n\n        var post = _buildFromText3.post;\n        var range = _buildFromText3.range;\n\n        var _buildFromText4 = buildFromText(after);\n\n        var expectedPost = _buildFromText4.post;\n        var expectedRange = _buildFromText4.range;\n\n        var position = run(post, function (postEditor) {\n          return postEditor.deleteRange(range);\n        });\n\n        expectedRange = retargetRange(expectedRange, post);\n\n        assert.postIsSimilar(post, expectedPost);\n        assert.rangeIsEqual(position.toRange(), expectedRange);\n      });\n    });\n  });\n\n  var entirePostExpectations = [[['<abc>'], 'single section'], [['<[some-card]>'], 'single card'], [['<abc', 'def', 'ghi>'], 'multiple sections'], [['<>'], 'single blank section'], [['<', '', '>'], 'multiple blank sections'], [['<[some-card]', 'abc', '[some-card]>'], 'cards at head/tail, containing markup section'], [['<abc', '[some-card]', 'def>'], 'markup sections containing card'], [['<[some-card]', 'abc>'], 'card->markup'], [['<abc', '[some-card]>'], 'markup->card']];\n\n  entirePostExpectations.forEach(function (_ref3) {\n    var _ref32 = _slicedToArray(_ref3, 2);\n\n    var text = _ref32[0];\n    var msg = _ref32[1];\n\n    test('entire post \"' + text + '\" (' + msg + ')', function (assert) {\n      var _buildFromText5 = buildFromText(text);\n\n      var post = _buildFromText5.post;\n      var range = _buildFromText5.range;\n\n      var position = run(post, function (postEditor) {\n        return postEditor.deleteRange(range);\n      });\n\n      assert.ok(post.sections.length === 1 && post.sections.head.isBlank, 'post has single blank section after deleteRange (' + msg + ')');\n      assert.ok(position.section === post.sections.head, 'position#section is correct (' + msg + ')');\n      assert.equal(position.offset, 0, 'position#offset is correct (' + msg + ')');\n    });\n  });\n});","define('tests/unit/editor/post-test', ['exports', 'mobiledoc-kit/editor/post', 'mobiledoc-kit', '../../test-helpers', 'mobiledoc-kit/models/post-node-builder', 'mobiledoc-kit/utils/cursor/range'], function (exports, _mobiledocKitEditorPost, _mobiledocKit, _testHelpers, _mobiledocKitModelsPostNodeBuilder, _mobiledocKitUtilsCursorRange) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  var builder = undefined,\n      postEditor = undefined,\n      mockEditor = undefined;\n\n  var _Helpers$postEditor = _testHelpers['default'].postEditor;\n  var MockEditor = _Helpers$postEditor.MockEditor;\n  var renderBuiltAbstract = _Helpers$postEditor.renderBuiltAbstract;\n\n  function buildEditorWithMobiledoc(builderFn) {\n    var autofocus = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(builderFn);\n    var unknownCardHandler = function unknownCardHandler() {};\n    var unknownAtomHandler = function unknownAtomHandler() {};\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc, unknownCardHandler: unknownCardHandler, unknownAtomHandler: unknownAtomHandler, autofocus: autofocus });\n    editor.render(editorElement);\n    var selectRange = editor.selectRange;\n    editor.selectRange = function (range) {\n      selectRange.call(editor, range);\n      // Store the rendered range so the test can make assertions with it\n      editor._renderedRange = range;\n    };\n    return editor;\n  }\n\n  _module('Unit: PostEditor', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      mockEditor = new MockEditor(builder);\n      postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('#splitMarkers when headMarker = tailMarker', function (assert) {\n    var post = undefined,\n        section = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref) {\n      var marker = _ref.marker;\n      var markupSection = _ref.markupSection;\n      var buildPost = _ref.post;\n\n      section = markupSection('p', [marker('abcd')]);\n      post = buildPost([section]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n\n    var postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 3);\n    var markers = postEditor.splitMarkers(range);\n    postEditor.complete();\n\n    assert.equal(markers.length, 1, 'markers');\n    assert.equal(markers[0].value, 'bc', 'marker 0');\n  });\n\n  test('#splitMarkers when head section = tail section, but different markers', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var marker = _ref2.marker;\n      var markupSection = _ref2.markupSection;\n      var post = _ref2.post;\n      return post([markupSection('p', [marker('abc'), marker('def')])]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n\n    var section = post.sections.head;\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 2, section, 5);\n    var postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    var markers = postEditor.splitMarkers(range);\n    postEditor.complete();\n\n    assert.equal(markers.length, 2, 'markers');\n    assert.equal(markers[0].value, 'c', 'marker 0');\n    assert.equal(markers[1].value, 'de', 'marker 1');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/121\n  test('#splitMarkers when single-character marker at start', function (assert) {\n    var post = undefined,\n        section = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var marker = _ref3.marker;\n      var markupSection = _ref3.markupSection;\n      var buildPost = _ref3.post;\n\n      section = markupSection('p', [marker('a'), marker('b'), marker('c')]);\n      post = buildPost([section]);\n    });\n\n    renderBuiltAbstract(post, mockEditor);\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 3);\n    var markers = postEditor.splitMarkers(range);\n    postEditor.complete();\n\n    assert.equal(markers.length, 2, 'markers');\n    assert.equal(markers[0].value, 'b', 'marker 0');\n    assert.equal(markers[1].value, 'c', 'marker 1');\n  });\n\n  test('#replaceSection one markup section with another', function (assert) {\n    var _section1 = undefined,\n        _section2 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      _section1 = markupSection('p', [marker('abc')]);\n      _section2 = markupSection('p', [marker('123')]);\n      return post([_section1]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    assert.equal(post.sections.head.text, 'abc', 'precond - section text');\n    assert.equal(post.sections.length, 1, 'precond - only 1 section');\n    postEditor.replaceSection(_section1, _section2);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.text, '123', 'section replaced');\n    assert.equal(post.sections.length, 1, 'only 1 section');\n  });\n\n  test('#replaceSection markup section with list section', function (assert) {\n    var _section1 = undefined,\n        _section2 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var listSection = _ref5.listSection;\n      var listItem = _ref5.listItem;\n      var marker = _ref5.marker;\n\n      _section1 = markupSection('p', [marker('abc')]);\n      _section2 = listSection('ul', [listItem([marker('123')])]);\n      return post([_section1]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    assert.equal(post.sections.head.text, 'abc', 'precond - section text');\n    assert.equal(post.sections.length, 1, 'precond - only 1 section');\n    postEditor.replaceSection(_section1, _section2);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.items.head.text, '123', 'section replaced');\n    assert.equal(post.sections.length, 1, 'only 1 section');\n  });\n\n  test('#replaceSection solo list item with markup section removes list section', function (assert) {\n    var _section1 = undefined,\n        _section2 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var listSection = _ref6.listSection;\n      var listItem = _ref6.listItem;\n      var marker = _ref6.marker;\n\n      _section1 = listItem([marker('abc')]);\n      _section2 = markupSection('p', [marker('123')]);\n      return post([listSection('ul', [_section1])]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    assert.equal(post.sections.head.items.head.text, 'abc', 'precond - list item text');\n    assert.equal(post.sections.length, 1, 'precond - only 1 section');\n    postEditor.replaceSection(_section1, _section2);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.text, '123', 'section replaced');\n    assert.equal(post.sections.length, 1, 'only 1 section');\n  });\n\n  /*\n   * FIXME, this test should be made to pass, but it is not a situation that we\n   * run into in the actual life of the editor right now.\n  \n  test('#replaceSection middle list item with markup section cuts list into two', (assert) => {\n    let _section1, _section2;\n    const post = Helpers.postAbstract.build(\n      ({post, markupSection, listSection, listItem, marker}) => {\n      _section1 = listItem([marker('li 2')]);\n      _section2 = markupSection('p', [marker('123')]);\n      return post([listSection('ul', [\n        listItem([marker('li 1')]),\n        _section1,\n        listItem([marker('li 3')])\n      ])]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n  \n    assert.equal(post.sections.head.items.length, 3, 'precond - 3 lis');\n    assert.equal(post.sections.head.items.objectAt(1).text, 'li 2', 'precond - list item text');\n    assert.equal(post.sections.length, 1, 'precond - only 1 section');\n    postEditor.replaceSection(_section1, _section2);\n    postEditor.complete();\n  \n    assert.equal(post.sections.length, 3, '3 sections');\n    assert.equal(post.sections.head.items.length, 1, '1 li in 1st ul');\n    assert.equal(post.sections.objectAt(1).text, '123', 'new section text is there');\n    assert.equal(post.sections.tail.items.length, 1, '1 li in last ul');\n  });\n  \n  */\n\n  test('#replaceSection last list item with markup section when multiple list items appends after list section', function (assert) {\n    var _section1 = undefined,\n        _section2 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var listSection = _ref7.listSection;\n      var listItem = _ref7.listItem;\n      var marker = _ref7.marker;\n\n      _section1 = listItem([marker('abc')]);\n      _section2 = markupSection('p', [marker('123')]);\n      return post([listSection('ul', [listItem([marker('before li')]), _section1])]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    assert.equal(post.sections.head.items.length, 2, 'precond - 2 lis');\n    assert.equal(post.sections.head.items.tail.text, 'abc', 'precond - list item text');\n    assert.equal(post.sections.length, 1, 'precond - only 1 section');\n    postEditor.replaceSection(_section1, _section2);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.items.length, 1, 'only 1 li');\n    assert.equal(post.sections.head.items.head.text, 'before li', 'first li remains');\n    assert.equal(post.sections.length, 2, '2 sections');\n    assert.equal(post.sections.tail.text, '123', 'new section text is there');\n  });\n\n  test('#replaceSection when section is null appends new section', function (assert) {\n    var newEmptySection = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n\n      newEmptySection = markupSection('p');\n      return post();\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    assert.equal(post.sections.length, 0, 'precond - no sections');\n    postEditor.replaceSection(null, newEmptySection);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1, 'has 1 section');\n    assert.equal(post.sections.head.text, '', 'no text in new section');\n  });\n\n  test('#insertSectionAtEnd inserts the section at the end of the mobiledoc', function (assert) {\n    var newSection = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      newSection = markupSection('p', [marker('123')]);\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    postEditor.insertSectionAtEnd(newSection);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 2, 'new section added');\n    assert.equal(post.sections.tail.text, '123', 'new section added at end');\n  });\n\n  test('markers with identical non-attribute markups get coalesced after applying or removing markup', function (assert) {\n    var strong = undefined,\n        section = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n      var markup = _ref10.markup;\n\n      strong = markup('strong');\n      section = markupSection('p', [marker('a'), marker('b', [strong]), marker('c')]);\n      return post([section]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    // removing the strong from the \"b\"\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 2);\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.removeMarkupFromRange(range, strong);\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 1, 'similar markers are coalesced');\n    assert.equal(section.markers.head.value, 'abc', 'marker value is correct');\n    assert.ok(!section.markers.head.hasMarkup(strong), 'marker has no bold');\n\n    // adding strong to each of the characters individually\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    for (var i = 0; i < section.length; i++) {\n      range = _mobiledocKitUtilsCursorRange['default'].create(section, i, section, i + 1);\n      postEditor.addMarkupToRange(range, strong);\n    }\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 1, 'bold markers coalesced');\n    assert.equal(section.markers.head.value, 'abc', 'bold marker value is correct');\n    assert.ok(section.markers.head.hasMarkup(strong), 'bold marker has bold');\n  });\n\n  test('markers do not get coalesced with atoms', function (assert) {\n    var strong = undefined,\n        section = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref11) {\n      var post = _ref11.post;\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n      var atom = _ref11.atom;\n      var markup = _ref11.markup;\n\n      strong = markup('strong');\n      section = markupSection('p', [atom('the-atom', 'A'), marker('b', [strong])]);\n      return post([section]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    // removing the strong from the \"b\"\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, 2);\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.removeMarkupFromRange(range, strong);\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 2, 'still 2 markers');\n    assert.equal(section.markers.head.value, 'A', 'head marker value is correct');\n    assert.ok(section.markers.head.isAtom, 'head marker is atom');\n    assert.equal(section.markers.tail.value, 'b', 'tail marker value is correct');\n    assert.ok(section.markers.tail.isMarker, 'tail marker is marker');\n\n    assert.ok(!section.markers.head.hasMarkup(strong), 'head marker has no bold');\n    assert.ok(!section.markers.tail.hasMarkup(strong), 'tail marker has no bold');\n  });\n\n  test('neighboring atoms do not get coalesced', function (assert) {\n    var strong = undefined,\n        section = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref12) {\n      var post = _ref12.post;\n      var markupSection = _ref12.markupSection;\n      var marker = _ref12.marker;\n      var atom = _ref12.atom;\n      var markup = _ref12.markup;\n\n      strong = markup('strong');\n      section = markupSection('p', [atom('the-atom', 'A', {}, [strong]), atom('the-atom', 'A', {}, [strong])]);\n      return post([section]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, 2);\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.removeMarkupFromRange(range, strong);\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 2, 'atoms not coalesced');\n    assert.ok(!section.markers.head.hasMarkup(strong));\n    assert.ok(!section.markers.tail.hasMarkup(strong));\n  });\n\n  test('#removeMarkupFromRange is no-op with collapsed range', function (assert) {\n    var section = undefined,\n        markup = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref13) {\n      var post = _ref13.post;\n      var markupSection = _ref13.markupSection;\n      var marker = _ref13.marker;\n      var buildMarkup = _ref13.markup;\n\n      markup = buildMarkup('strong');\n      section = markupSection('p', [marker('abc')]);\n      return post([section]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 1);\n    postEditor.removeMarkupFromRange(range, markup);\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 1, 'similar markers are coalesced');\n    assert.equal(section.markers.head.value, 'abc', 'marker value is correct');\n    assert.ok(!section.markers.head.hasMarkup(markup), 'marker has no markup');\n  });\n\n  test('#removeMarkupFromRange splits markers when necessary', function (assert) {\n    var bold = undefined,\n        section = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref14) {\n      var post = _ref14.post;\n      var marker = _ref14.marker;\n      var markup = _ref14.markup;\n      var markupSection = _ref14.markupSection;\n\n      bold = markup('b');\n      section = markupSection('p', [marker('abc', [bold]), marker('def')]);\n      return post([section]);\n    });\n\n    renderBuiltAbstract(post, mockEditor);\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 'a'.length, section, 'abcd'.length);\n\n    postEditor.removeMarkupFromRange(range, bold);\n    postEditor.complete();\n\n    assert.equal(section.text, 'abcdef', 'text still correct');\n    assert.equal(section.markers.length, 2, '2 markers');\n\n    var _section$markers$toArray = section.markers.toArray();\n\n    var _section$markers$toArray2 = _slicedToArray(_section$markers$toArray, 2);\n\n    var head = _section$markers$toArray2[0];\n    var tail = _section$markers$toArray2[1];\n\n    assert.equal(head.value, 'a', 'head marker value');\n    assert.ok(head.hasMarkup(bold), 'head has bold');\n    assert.equal(tail.value, 'bcdef', 'tail marker value');\n    assert.ok(!tail.hasMarkup(bold), 'tail has no bold');\n  });\n\n  test('#removeMarkupFromRange handles atoms correctly', function (assert) {\n    var bold = undefined,\n        section = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref15) {\n      var post = _ref15.post;\n      var marker = _ref15.marker;\n      var markup = _ref15.markup;\n      var atom = _ref15.atom;\n      var markupSection = _ref15.markupSection;\n\n      bold = markup('b');\n      section = markupSection('p', [atom('the-atom', 'n/a', {}, [bold]), marker('X')]);\n      return post([section]);\n    });\n\n    renderBuiltAbstract(post, mockEditor);\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, 2);\n\n    postEditor.removeMarkupFromRange(range, bold);\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 2, '2 markers');\n\n    var _section$markers$toArray3 = section.markers.toArray();\n\n    var _section$markers$toArray32 = _slicedToArray(_section$markers$toArray3, 2);\n\n    var head = _section$markers$toArray32[0];\n    var tail = _section$markers$toArray32[1];\n\n    assert.ok(head.isAtom, 'head is atom');\n    assert.ok(!head.hasMarkup(bold), 'head has no bold');\n\n    assert.equal(tail.value, 'X', 'tail marker value');\n    assert.ok(!tail.hasMarkup(bold), 'tail has no bold');\n  });\n\n  test('#addMarkupToRange is no-op with collapsed range', function (assert) {\n    var section = undefined,\n        markup = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref16) {\n      var post = _ref16.post;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n      var buildMarkup = _ref16.markup;\n\n      markup = buildMarkup('strong');\n      section = markupSection('p', [marker('abc')]);\n      return post([section]);\n    });\n    renderBuiltAbstract(post, mockEditor);\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 1);\n    postEditor.addMarkupToRange(range, markup);\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 1, 'similar markers are coalesced');\n    assert.equal(section.markers.head.value, 'abc', 'marker value is correct');\n    assert.ok(!section.markers.head.hasMarkup(markup), 'marker has no markup');\n  });\n\n  test(\"#addMarkupToRange around a markup pushes the new markup below existing ones\", function (assert) {\n    var em = undefined;\n    var editor = buildEditorWithMobiledoc(function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var marker = _ref17.marker;\n      var markup = _ref17.markup;\n\n      em = markup('em');\n      return post([markupSection('p', [marker('one '), marker('BOLD', [markup('b')]), marker(' two')])]);\n    });\n\n    var section = editor.post.sections.head;\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, 'one BOLD two'.length);\n    editor.run(function (postEditor) {\n      postEditor.addMarkupToRange(range, em);\n    });\n\n    var markers = section.markers.toArray();\n    assert.equal(markers[0].closedMarkups.length, 0, 'Existing markup is not closed');\n\n    assert.equal(editor.element.innerHTML, '<p><em>one <b>BOLD</b> two</em></p>');\n  });\n\n  test(\"#addMarkupToRange within a markup puts the new markup on top of the stack\", function (assert) {\n    var b = undefined;\n    var editor = buildEditorWithMobiledoc(function (_ref18) {\n      var post = _ref18.post;\n      var markupSection = _ref18.markupSection;\n      var marker = _ref18.marker;\n      var markup = _ref18.markup;\n\n      b = markup('b');\n      return post([markupSection('p', [marker('one BOLD two', [markup('em')])])]);\n    });\n\n    var section = editor.post.sections.head;\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 'one '.length, section, 'one BOLD'.length);\n    editor.run(function (postEditor) {\n      postEditor.addMarkupToRange(range, b);\n    });\n\n    var markers = section.markers.toArray();\n    assert.equal(markers[0].closedMarkups.length, 0, 'Existing markup is not closed');\n\n    assert.equal(editor.element.innerHTML, '<p><em>one <b>BOLD</b> two</em></p>');\n  });\n\n  test(\"#addMarkupToRange straddling the open tag of an existing markup, closes and reopens the existing markup\", function (assert) {\n    var em = undefined;\n    var editor = buildEditorWithMobiledoc(function (_ref19) {\n      var post = _ref19.post;\n      var markupSection = _ref19.markupSection;\n      var marker = _ref19.marker;\n      var markup = _ref19.markup;\n\n      em = markup('em');\n      return post([markupSection('p', [marker('_one '), marker('TWO_ THREE', [markup('b')])])]);\n    });\n\n    var section = editor.post.sections.head;\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, '_one TWO_'.length);\n\n    editor.run(function (postEditor) {\n      postEditor.addMarkupToRange(range, em);\n    });\n\n    assert.equal(editor.element.innerHTML, '<p><em>_one <b>TWO_</b></em><b> THREE</b></p>');\n  });\n\n  test(\"#addMarkupToRange straddling the closing tag of an existing markup, closes and reopens the existing markup\", function (assert) {\n    var em = undefined;\n    var editor = buildEditorWithMobiledoc(function (_ref20) {\n      var post = _ref20.post;\n      var markupSection = _ref20.markupSection;\n      var marker = _ref20.marker;\n      var markup = _ref20.markup;\n\n      em = markup('em');\n      return post([markupSection('p', [marker('ONE _TWO', [markup('b')]), marker(' three_')])]);\n    });\n\n    var section = editor.post.sections.head;\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 'ONE '.length, section, 'ONE _TWO three_'.length);\n\n    editor.run(function (postEditor) {\n      postEditor.addMarkupToRange(range, em);\n    });\n\n    assert.equal(editor.element.innerHTML, '<p><b>ONE </b><em><b>_TWO</b> three_</em></p>');\n  });\n\n  test('markers with identical markups get coalesced after deletion', function (assert) {\n    var strong = undefined,\n        section = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref21) {\n      var post = _ref21.post;\n      var markupSection = _ref21.markupSection;\n      var marker = _ref21.marker;\n      var markup = _ref21.markup;\n\n      strong = markup('strong');\n      section = markupSection('p', [marker('a'), marker('b', [strong]), marker('c')]);\n      return post([section]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 2);\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.deleteRange(range);\n    postEditor.complete();\n\n    assert.equal(section.markers.length, 1, 'similar markers are coalesced');\n    assert.equal(section.markers.head.value, 'ac', 'marker value is correct');\n  });\n\n  test('#moveSectionBefore moves the section as expected', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref22) {\n      var post = _ref22.post;\n      var markupSection = _ref22.markupSection;\n      var marker = _ref22.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('123')])]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n\n    var _post$sections$toArray = post.sections.toArray();\n\n    var _post$sections$toArray2 = _slicedToArray(_post$sections$toArray, 2);\n\n    var headSection = _post$sections$toArray2[0];\n    var tailSection = _post$sections$toArray2[1];\n\n    var collection = post.sections;\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    var movedSection = postEditor.moveSectionBefore(collection, tailSection, headSection);\n    postEditor.complete();\n\n    assert.equal(post.sections.head, movedSection, 'movedSection is returned');\n    assert.equal(post.sections.head.text, '123', 'tail section is now head');\n    assert.equal(post.sections.tail.text, 'abc', 'head section is now tail');\n  });\n\n  test('#moveSectionBefore moves card sections', function (assert) {\n    var listiclePayload = { some: 'thing' };\n    var otherPayload = { some: 'other thing' };\n    var post = _testHelpers['default'].postAbstract.build(function (_ref23) {\n      var post = _ref23.post;\n      var cardSection = _ref23.cardSection;\n\n      return post([cardSection('listicle-card', listiclePayload), cardSection('other-card', otherPayload)]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n\n    var collection = post.sections;\n\n    var _post$sections$toArray3 = post.sections.toArray();\n\n    var _post$sections$toArray32 = _slicedToArray(_post$sections$toArray3, 2);\n\n    var headSection = _post$sections$toArray32[0];\n    var tailSection = _post$sections$toArray32[1];\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.moveSectionBefore(collection, tailSection, headSection);\n    postEditor.complete();\n\n    var _post$sections$toArray4 = post.sections.toArray();\n\n    var _post$sections$toArray42 = _slicedToArray(_post$sections$toArray4, 2);\n\n    headSection = _post$sections$toArray42[0];\n    tailSection = _post$sections$toArray42[1];\n\n    assert.equal(headSection.name, 'other-card', 'other-card moved to first spot');\n    assert.equal(tailSection.name, 'listicle-card', 'listicle-card moved to last spot');\n    assert.deepEqual(headSection.payload, otherPayload, 'payload is correct for other-card');\n    assert.deepEqual(tailSection.payload, listiclePayload, 'payload is correct for listicle-card');\n  });\n\n  test('#moveSectionUp moves it up', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref24) {\n      var post = _ref24.post;\n      var cardSection = _ref24.cardSection;\n\n      return post([cardSection('listicle-card'), cardSection('other-card')]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n\n    var _post$sections$toArray5 = post.sections.toArray();\n\n    var _post$sections$toArray52 = _slicedToArray(_post$sections$toArray5, 2);\n\n    var headSection = _post$sections$toArray52[0];\n    var tailSection = _post$sections$toArray52[1];\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.moveSectionUp(tailSection);\n    postEditor.complete();\n\n    var _post$sections$toArray6 = post.sections.toArray();\n\n    var _post$sections$toArray62 = _slicedToArray(_post$sections$toArray6, 2);\n\n    headSection = _post$sections$toArray62[0];\n    tailSection = _post$sections$toArray62[1];\n\n    assert.equal(headSection.name, 'other-card', 'other-card moved to first spot');\n    assert.equal(tailSection.name, 'listicle-card', 'listicle-card moved to last spot');\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    var movedSection = postEditor.moveSectionUp(headSection);\n    postEditor.complete();\n\n    var _post$sections$toArray7 = post.sections.toArray();\n\n    var _post$sections$toArray72 = _slicedToArray(_post$sections$toArray7, 2);\n\n    headSection = _post$sections$toArray72[0];\n    tailSection = _post$sections$toArray72[1];\n\n    assert.equal(post.sections.head, movedSection, 'movedSection is returned');\n    assert.equal(headSection.name, 'other-card', 'moveSectionUp is no-op when card is at top');\n  });\n\n  test('moveSectionDown moves it down', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref25) {\n      var post = _ref25.post;\n      var cardSection = _ref25.cardSection;\n\n      return post([cardSection('listicle-card'), cardSection('other-card')]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n\n    var _post$sections$toArray8 = post.sections.toArray();\n\n    var _post$sections$toArray82 = _slicedToArray(_post$sections$toArray8, 2);\n\n    var headSection = _post$sections$toArray82[0];\n    var tailSection = _post$sections$toArray82[1];\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.moveSectionDown(headSection);\n    postEditor.complete();\n\n    var _post$sections$toArray9 = post.sections.toArray();\n\n    var _post$sections$toArray92 = _slicedToArray(_post$sections$toArray9, 2);\n\n    headSection = _post$sections$toArray92[0];\n    tailSection = _post$sections$toArray92[1];\n\n    assert.equal(headSection.name, 'other-card', 'other-card moved to first spot');\n    assert.equal(tailSection.name, 'listicle-card', 'listicle-card moved to last spot');\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    var movedSection = postEditor.moveSectionDown(tailSection);\n    postEditor.complete();\n\n    var _post$sections$toArray10 = post.sections.toArray();\n\n    var _post$sections$toArray102 = _slicedToArray(_post$sections$toArray10, 2);\n\n    headSection = _post$sections$toArray102[0];\n    tailSection = _post$sections$toArray102[1];\n\n    assert.equal(post.sections.tail, movedSection, 'movedSection is returned');\n    assert.equal(tailSection.name, 'listicle-card', 'moveSectionDown is no-op when card is at bottom');\n  });\n\n  test('#toggleSection changes single section to and from tag name', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref26) {\n      var post = _ref26.post;\n      var markupSection = _ref26.markupSection;\n\n      return post([markupSection('p')]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('blockquote', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.tagName, 'blockquote');\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('blockquote', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.tagName, 'p');\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());\n  });\n\n  test('#toggleSection changes multiple sections to and from tag name', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref27) {\n      var post = _ref27.post;\n      var markupSection = _ref27.markupSection;\n      var marker = _ref27.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('123')])]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 2, post.sections.tail, 2);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('blockquote', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.tagName, 'blockquote');\n    assert.equal(post.sections.tail.tagName, 'blockquote');\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('blockquote', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.tagName, 'p');\n    assert.equal(post.sections.tail.tagName, 'p');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());\n  });\n\n  test('#toggleSection skips over non-markerable sections', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref28) {\n      var post = _ref28.post;\n      var markupSection = _ref28.markupSection;\n      var marker = _ref28.marker;\n      var cardSection = _ref28.cardSection;\n\n      return post([markupSection('p', [marker('abc')]), cardSection('my-card'), markupSection('p', [marker('123')])]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 0, post.sections.tail, 2);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('blockquote', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.head.tagName, 'blockquote');\n    assert.ok(post.sections.objectAt(1).isCardSection);\n    assert.equal(post.sections.tail.tagName, 'blockquote');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());\n  });\n\n  test('#toggleSection when cursor is in non-markerable section changes nothing', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref29) {\n      var post = _ref29.post;\n      var markupSection = _ref29.markupSection;\n      var marker = _ref29.marker;\n      var cardSection = _ref29.cardSection;\n\n      return post([cardSection('my-card')]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = post.sections.head.headPosition().toRange();\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('blockquote', range);\n    postEditor.complete();\n\n    assert.ok(post.sections.head.isCardSection, 'card section not changed');\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());\n  });\n\n  test('#toggleSection when editor has no cursor does nothing', function (assert) {\n    assert.expect(6);\n    var done = assert.async();\n\n    editor = buildEditorWithMobiledoc(function (_ref30) {\n      var post = _ref30.post;\n      var markupSection = _ref30.markupSection;\n      var marker = _ref30.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    }, false);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref31) {\n      var post = _ref31.post;\n      var markupSection = _ref31.markupSection;\n      var marker = _ref31.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    assert.ok(!editor.hasCursor(), 'editor has no cursor');\n    assert.ok(editor.range.isBlank, 'editor has blank range');\n\n    editor.run(function (postEditor) {\n      return postEditor.toggleSection('blockquote');\n    });\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.ok(document.activeElement !== editorElement, 'editor element is not active');\n      assert.ok(editor.range.isBlank, 'rendered range is blank');\n      assert.equal(window.getSelection().rangeCount, 0, 'nothing selected');\n\n      done();\n    });\n  });\n\n  test('#toggleSection toggle single p -> list item', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref32) {\n      var post = _ref32.post;\n      var markupSection = _ref32.markupSection;\n      var marker = _ref32.marker;\n      var markup = _ref32.markup;\n\n      return post([markupSection('p', [marker('a'), marker('b', [markup('b')]), marker('c')])]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1);\n    var listSection = post.sections.head;\n    assert.ok(listSection.isListSection);\n    assert.equal(listSection.tagName, 'ul');\n    assert.equal(listSection.items.length, 1);\n    assert.equal(listSection.items.head.text, 'abc');\n    var item = listSection.items.head;\n    assert.equal(item.markers.length, 3);\n    assert.equal(item.markers.objectAt(0).value, 'a');\n    assert.equal(item.markers.objectAt(1).value, 'b');\n    assert.ok(item.markers.objectAt(1).hasMarkup('b'), 'b has b markup');\n    assert.equal(item.markers.objectAt(2).value, 'c');\n  });\n\n  test('#toggleSection toggle single list item -> p', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref33) {\n      var post = _ref33.post;\n      var listSection = _ref33.listSection;\n      var listItem = _ref33.listItem;\n      var marker = _ref33.marker;\n      var markup = _ref33.markup;\n\n      return post([listSection('ul', [listItem([marker('a'), marker('b', [markup('b')]), marker('c')])])]);\n    });\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.head, 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1);\n    assert.equal(post.sections.head.tagName, 'p');\n    assert.equal(post.sections.head.text, 'abc');\n    assert.equal(post.sections.head.markers.length, 3);\n    assert.equal(post.sections.head.markers.objectAt(0).value, 'a');\n    assert.equal(post.sections.head.markers.objectAt(1).value, 'b');\n    assert.ok(post.sections.head.markers.objectAt(1).hasMarkup('b'), 'b has b markup');\n    assert.equal(post.sections.head.markers.objectAt(2).value, 'c');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());\n  });\n\n  test('#toggleSection toggle multiple ps -> list and list -> multiple ps', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref34) {\n      var post = _ref34.post;\n      var markupSection = _ref34.markupSection;\n      var marker = _ref34.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('123')])]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    var _editor = editor;\n    var post = _editor.post;\n\n    editor.render(editorElement);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 0, post.sections.tail, 2);\n\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    var listSection = post.sections.head;\n    assert.equal(post.sections.length, 1, 'post has 1 list section after toggle');\n    assert.ok(listSection.isListSection);\n    assert.equal(listSection.tagName, 'ul');\n    assert.equal(listSection.items.length, 2, '2 list items');\n    assert.equal(listSection.items.head.text, 'abc');\n    assert.equal(listSection.items.tail.text, '123');\n\n    range = _mobiledocKitUtilsCursorRange['default'].create(listSection.items.head, 0, listSection.items.tail, 0);\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 2, 'post has 2 sections after toggle');\n    assert.equal(post.sections.head.tagName, 'p');\n    assert.equal(post.sections.tail.tagName, 'p');\n    assert.equal(post.sections.head.text, 'abc');\n    assert.equal(post.sections.tail.text, '123');\n\n    assert.ok(editor.range.head.section === post.sections.head, 'selected head correct');\n    assert.equal(editor.range.head.offset, 0);\n  });\n\n  test('#toggleSection untoggle first list item changes it to markup section, retains markup', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref35) {\n      var post = _ref35.post;\n      var listSection = _ref35.listSection;\n      var listItem = _ref35.listItem;\n      var marker = _ref35.marker;\n      var markup = _ref35.markup;\n\n      return post([listSection('ul', [listItem([marker('a'), marker('b', [markup('b')]), marker('c')]), listItem([marker('def')]), listItem([marker('ghi')])])]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.head, 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 2, '2 sections');\n    assert.equal(post.sections.head.tagName, 'p', 'head section is p');\n    assert.equal(post.sections.head.text, 'abc');\n    var section = post.sections.head;\n    assert.equal(section.markers.length, 3);\n    assert.equal(section.markers.objectAt(0).value, 'a');\n    assert.ok(section.markers.objectAt(1).hasMarkup('b'), 'b has b markup');\n    assert.equal(section.markers.objectAt(2).value, 'c');\n    assert.ok(post.sections.tail.isListSection, 'tail is list section');\n    assert.equal(post.sections.tail.items.length, 2, '2 items in list');\n    assert.equal(post.sections.tail.items.head.text, 'def');\n    assert.equal(post.sections.tail.items.tail.text, 'ghi');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());\n  });\n\n  test('#toggleSection untoggle middle list item changes it to markup section, retaining markup', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref36) {\n      var post = _ref36.post;\n      var listSection = _ref36.listSection;\n      var listItem = _ref36.listItem;\n      var marker = _ref36.marker;\n      var markup = _ref36.markup;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('d'), marker('e', [markup('b')]), marker('f')]), listItem([marker('ghi')])])]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.objectAt(1), 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 3, '3 sections');\n    var section = post.sections.objectAt(1);\n    assert.equal(section.tagName, 'p', 'middle section is p');\n    assert.equal(section.text, 'def');\n    assert.equal(section.markers.length, 3);\n    assert.equal(section.markers.objectAt(0).value, 'd');\n    assert.equal(section.markers.objectAt(1).value, 'e');\n    assert.ok(section.markers.objectAt(1).hasMarkup('b'), 'e has b markup');\n    assert.equal(section.markers.objectAt(2).value, 'f');\n    assert.positionIsEqual(mockEditor._renderedRange.head, section.headPosition());\n\n    assert.ok(post.sections.head.isListSection, 'head section is list');\n    assert.ok(post.sections.tail.isListSection, 'tail section is list');\n    assert.equal(post.sections.head.items.length, 1, '1 item in first list');\n    assert.equal(post.sections.tail.items.length, 1, '1 item in last list');\n    assert.equal(post.sections.head.items.head.text, 'abc');\n    assert.equal(post.sections.tail.items.head.text, 'ghi');\n  });\n\n  test('#toggleSection toggle markup section -> ul between lists joins the lists', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref37) {\n      var post = _ref37.post;\n      var listSection = _ref37.listSection;\n      var listItem = _ref37.listItem;\n      var marker = _ref37.marker;\n      var markupSection = _ref37.markupSection;\n\n      return post([listSection('ul', [listItem([marker('abc')])]), markupSection('p', [marker('123')]), listSection('ul', [listItem([marker('def')])])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    var _editor2 = editor;\n    var post = _editor2.post;\n\n    editor.render(editorElement);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.objectAt(1), 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1, '1 sections');\n    var section = post.sections.head;\n    assert.ok(section.isListSection, 'list section');\n    assert.equal(section.items.length, 3, '3 items');\n    assert.deepEqual(section.items.map(function (i) {\n      return i.text;\n    }), ['abc', '123', 'def']);\n\n    var listItem = section.items.objectAt(1);\n    assert.ok(editor.range.head.section === listItem, 'correct head selection');\n    assert.equal(editor.range.head.offset, 0);\n  });\n\n  test('#toggleSection untoggle multiple items at end of list changes them to markup sections', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref38) {\n      var post = _ref38.post;\n      var listSection = _ref38.listSection;\n      var listItem = _ref38.listItem;\n      var marker = _ref38.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')]), listItem([marker('ghi')])])]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.objectAt(1), 0, post.sections.head.items.tail, 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 3, '3 sections');\n    assert.ok(post.sections.head.isListSection, 'head section is list');\n    assert.equal(post.sections.head.items.length, 1, 'head section has 1 item');\n    assert.equal(post.sections.head.items.head.text, 'abc');\n\n    assert.equal(post.sections.objectAt(1).tagName, 'p', 'middle is p');\n    assert.equal(post.sections.objectAt(1).text, 'def');\n    assert.equal(post.sections.tail.tagName, 'p', 'tail is p');\n    assert.equal(post.sections.tail.text, 'ghi');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.objectAt(1).headPosition());\n  });\n\n  test('#toggleSection untoggle multiple items at start of list changes them to markup sections', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref39) {\n      var post = _ref39.post;\n      var listSection = _ref39.listSection;\n      var listItem = _ref39.listItem;\n      var marker = _ref39.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')]), listItem([marker('ghi')])])]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.head, 0, post.sections.head.items.objectAt(1), 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 3, '3 sections');\n    assert.equal(post.sections.head.tagName, 'p', 'head section is p');\n    assert.equal(post.sections.head.text, 'abc');\n\n    assert.equal(post.sections.objectAt(1).tagName, 'p', '2nd section is p');\n    assert.equal(post.sections.objectAt(1).text, 'def');\n\n    assert.ok(post.sections.objectAt(2).isListSection, '3rd section is list');\n    assert.equal(post.sections.objectAt(2).items.length, 1, 'list has 1 item');\n    assert.equal(post.sections.objectAt(2).items.head.text, 'ghi');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());\n  });\n\n  test('#toggleSection untoggle items and overflowing markup sections changes the overflow to items', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref40) {\n      var post = _ref40.post;\n      var listSection = _ref40.listSection;\n      var listItem = _ref40.listItem;\n      var markupSection = _ref40.markupSection;\n      var marker = _ref40.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')]), listItem([marker('ghi')])]), markupSection('p', [marker('123')])]);\n    });\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n    var _editor3 = editor;\n    var post = _editor3.post;\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.objectAt(1), 0, post.sections.tail, 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1, '1 section');\n    assert.ok(post.sections.head.isListSection, 'head section is list');\n    assert.equal(post.sections.head.items.length, 4, 'list has 4 items');\n\n    var text = post.sections.head.items.toArray().map(function (i) {\n      return i.text;\n    });\n    assert.deepEqual(text, ['abc', 'def', 'ghi', '123']);\n\n    assert.ok(editor.range.head.section === post.sections.head.items.objectAt(1), 'selected head correct');\n    assert.equal(editor.range.head.offset, 0);\n  });\n\n  test('#toggleSection untoggle last list item changes it to markup section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref41) {\n      var post = _ref41.post;\n      var listSection = _ref41.listSection;\n      var listItem = _ref41.listItem;\n      var marker = _ref41.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')]), listItem([marker('ghi')])])]);\n    });\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.tail, 0);\n\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 2, '2 sections');\n    assert.ok(post.sections.head.isListSection, 'head section is list');\n    assert.equal(post.sections.tail.tagName, 'p', 'tail is p');\n    assert.equal(post.sections.tail.text, 'ghi');\n\n    assert.equal(post.sections.head.items.length, 2, '2 items in list');\n    assert.equal(post.sections.head.items.head.text, 'abc');\n    assert.equal(post.sections.head.items.tail.text, 'def');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.tail.headPosition());\n  });\n\n  test('#toggleSection toggle list item to different type of list item', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref42) {\n      var post = _ref42.post;\n      var listSection = _ref42.listSection;\n      var listItem = _ref42.listItem;\n      var marker = _ref42.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')])])]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.head, 0);\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ol', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1, '1 section');\n    assert.ok(post.sections.head.isListSection, 'section is list');\n    assert.equal(post.sections.head.tagName, 'ol', 'section is ol list');\n    assert.equal(post.sections.head.items.length, 1, '1 item');\n    assert.equal(post.sections.head.items.head.text, 'abc');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.items.head.headPosition());\n  });\n\n  test('#toggleSection toggle list item to different type of list item when other sections precede it', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref43) {\n      var post = _ref43.post;\n      var listSection = _ref43.listSection;\n      var listItem = _ref43.listItem;\n      var marker = _ref43.marker;\n      var markupSection = _ref43.markupSection;\n\n      return post([markupSection('p', [marker('123')]), listSection('ul', [listItem([marker('abc')])])]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.tail.items.head, 0);\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ol', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 2, '2 section');\n    assert.equal(post.sections.head.tagName, 'p', '1st section is p');\n    assert.equal(post.sections.head.text, '123');\n    assert.ok(post.sections.tail.isListSection, 'section is list');\n    assert.equal(post.sections.tail.tagName, 'ol', 'section is ol list');\n    assert.equal(post.sections.tail.items.length, 1, '1 item');\n    assert.equal(post.sections.tail.items.head.text, 'abc');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.tail.items.head.headPosition());\n  });\n\n  test('#toggleSection toggle when cursor on card section is no-op', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref44) {\n      var post = _ref44.post;\n      var cardSection = _ref44.cardSection;\n\n      return post([cardSection('my-card')]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 0);\n\n    mockEditor = renderBuiltAbstract(post, mockEditor);\n    postEditor = new _mobiledocKitEditorPost['default'](mockEditor);\n    postEditor.toggleSection('ol', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1, '1 section');\n    assert.ok(post.sections.head.isCardSection, 'still card section');\n\n    assert.positionIsEqual(mockEditor._renderedRange.head, range.head, 'range head is set to same');\n    assert.positionIsEqual(mockEditor._renderedRange.tail, range.tail, 'range tail is set to same');\n  });\n\n  test('#toggleSection joins contiguous list items', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref45) {\n      var post = _ref45.post;\n      var listSection = _ref45.listSection;\n      var listItem = _ref45.listItem;\n      var marker = _ref45.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')])]), listSection('ol', [listItem([marker('123')])]), listSection('ul', [listItem([marker('def')])])]);\n    });\n\n    editor = new _mobiledocKit.Editor({ mobiledoc: mobiledoc });\n    editor.render(editorElement);\n    var _editor4 = editor;\n    var post = _editor4.post;\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.objectAt(1).items.head, 0);\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleSection('ul', range);\n    postEditor.complete();\n\n    assert.equal(post.sections.length, 1, '1 section');\n    assert.ok(post.sections.head.isListSection, 'is list');\n    assert.equal(post.sections.head.items.length, 3, '3 items');\n    assert.deepEqual(post.sections.head.items.map(function (i) {\n      return i.text;\n    }), ['abc', '123', 'def']);\n  });\n\n  test('#toggleMarkup when cursor is in non-markerable does nothing', function (assert) {\n    editor = buildEditorWithMobiledoc(function (_ref46) {\n      var post = _ref46.post;\n      var markupSection = _ref46.markupSection;\n      var marker = _ref46.marker;\n      var cardSection = _ref46.cardSection;\n\n      return post([cardSection('my-card')]);\n    });\n\n    var range = editor.post.sections.head.headPosition().toRange();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleMarkup('b', range);\n    postEditor.complete();\n\n    assert.ok(editor.post.sections.head.isCardSection);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.headPosition());\n  });\n\n  test('#toggleMarkup when cursor surrounds non-markerable does nothing', function (assert) {\n    editor = buildEditorWithMobiledoc(function (_ref47) {\n      var post = _ref47.post;\n      var markupSection = _ref47.markupSection;\n      var marker = _ref47.marker;\n      var cardSection = _ref47.cardSection;\n\n      return post([cardSection('my-card')]);\n    });\n\n    var range = editor.post.sections.head.toRange();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleMarkup('b', range);\n    postEditor.complete();\n\n    assert.ok(editor.post.sections.head.isCardSection);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.headPosition());\n  });\n\n  test('#toggleMarkup when range has the markup removes it', function (assert) {\n    editor = buildEditorWithMobiledoc(function (_ref48) {\n      var post = _ref48.post;\n      var markupSection = _ref48.markupSection;\n      var marker = _ref48.marker;\n      var markup = _ref48.markup;\n\n      return post([markupSection('p', [marker('abc', [markup('b')])])]);\n    });\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref49) {\n      var post = _ref49.post;\n      var markupSection = _ref49.markupSection;\n      var marker = _ref49.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var range = editor.post.sections.head.toRange();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleMarkup('b', range);\n    postEditor.complete();\n\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.headPosition());\n    assert.positionIsEqual(editor._renderedRange.tail, editor.post.tailPosition());\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  test('#toggleMarkup when only some of the range has it removes it', function (assert) {\n    editor = buildEditorWithMobiledoc(function (_ref50) {\n      var post = _ref50.post;\n      var markupSection = _ref50.markupSection;\n      var marker = _ref50.marker;\n      var markup = _ref50.markup;\n\n      return post([markupSection('p', [marker('a'), marker('b', [markup('b')]), marker('c')])]);\n    });\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref51) {\n      var post = _ref51.post;\n      var markupSection = _ref51.markupSection;\n      var marker = _ref51.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var range = editor.post.sections.head.toRange();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleMarkup('b', range);\n    postEditor.complete();\n\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.headPosition());\n    assert.positionIsEqual(editor._renderedRange.tail, editor.post.sections.head.tailPosition());\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  test('#toggleMarkup when range does not have the markup adds it', function (assert) {\n    editor = buildEditorWithMobiledoc(function (_ref52) {\n      var post = _ref52.post;\n      var markupSection = _ref52.markupSection;\n      var marker = _ref52.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref53) {\n      var post = _ref53.post;\n      var markupSection = _ref53.markupSection;\n      var marker = _ref53.marker;\n      var markup = _ref53.markup;\n\n      return post([markupSection('p', [marker('abc', [markup('b')])])]);\n    });\n\n    var range = editor.post.sections.head.toRange();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.toggleMarkup('b', range);\n    postEditor.complete();\n\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.headPosition());\n    assert.positionIsEqual(editor._renderedRange.tail, editor.post.sections.head.tailPosition());\n    assert.postIsSimilar(editor.post, expected);\n  });\n\n  test('#toggleMarkup when the editor has no cursor', function (assert) {\n    var done = assert.async();\n\n    editor = buildEditorWithMobiledoc(function (_ref54) {\n      var post = _ref54.post;\n      var markupSection = _ref54.markupSection;\n      var marker = _ref54.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    }, false);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref55) {\n      var post = _ref55.post;\n      var markupSection = _ref55.markupSection;\n      var marker = _ref55.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    editor._renderedRange = null;\n    editor.run(function (postEditor) {\n      return postEditor.toggleMarkup('b');\n    });\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.equal(window.getSelection().rangeCount, 0, 'nothing is selected');\n      assert.ok(document.activeElement !== editorElement, 'active element is not editor element');\n      assert.ok(editor._renderedRange && editor._renderedRange.isBlank, 'rendered range is blank');\n\n      done();\n    });\n  });\n\n  test('#insertMarkers inserts an atom', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref56) {\n      var post = _ref56.post;\n      var markupSection = _ref56.markupSection;\n      var marker = _ref56.marker;\n      var markup = _ref56.markup;\n      var atom = _ref56.atom;\n\n      toInsert = [atom('simple-atom', '123', [markup('b')])];\n      expected = post([markupSection('p', [marker('abc'), atom('simple-atom', '123', [markup('b')]), marker('def')])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref57) {\n      var post = _ref57.post;\n      var markupSection = _ref57.markupSection;\n      var marker = _ref57.marker;\n\n      return post([markupSection('p', [marker('abcdef')])]);\n    });\n    var position = editor.post.sections.head.toPosition('abc'.length);\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertMarkers(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.toPosition(4));\n  });\n\n  test('#insertMarkers inserts the markers in middle, merging markups', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref58) {\n      var post = _ref58.post;\n      var markupSection = _ref58.markupSection;\n      var marker = _ref58.marker;\n      var markup = _ref58.markup;\n\n      toInsert = [marker('123', [markup('b')]), marker('456')];\n      expected = post([markupSection('p', [marker('abc'), marker('123', [markup('b')]), marker('456def')])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref59) {\n      var post = _ref59.post;\n      var markupSection = _ref59.markupSection;\n      var marker = _ref59.marker;\n\n      return post([markupSection('p', [marker('abcdef')])]);\n    });\n    var position = editor.post.sections.head.toPosition('abc'.length);\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertMarkers(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.toPosition('abc123456'.length));\n  });\n\n  test('#insertMarkers inserts the markers when the markerable has no markers', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref60) {\n      var post = _ref60.post;\n      var markupSection = _ref60.markupSection;\n      var marker = _ref60.marker;\n      var markup = _ref60.markup;\n\n      toInsert = [marker('123', [markup('b')]), marker('456')];\n      expected = post([markupSection('p', [marker('123', [markup('b')]), marker('456')])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref61) {\n      var post = _ref61.post;\n      var markupSection = _ref61.markupSection;\n\n      return post([markupSection()]);\n    });\n    var position = editor.post.sections.head.headPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertMarkers(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.toPosition('123456'.length));\n  });\n\n  test('#insertMarkers inserts the markers at start', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref62) {\n      var post = _ref62.post;\n      var markupSection = _ref62.markupSection;\n      var marker = _ref62.marker;\n      var markup = _ref62.markup;\n\n      toInsert = [marker('123', [markup('b')]), marker('456')];\n      expected = post([markupSection('p', [marker('123', [markup('b')]), marker('456abc')])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref63) {\n      var post = _ref63.post;\n      var markupSection = _ref63.markupSection;\n      var marker = _ref63.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    var position = editor.post.sections.head.headPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertMarkers(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.toPosition('123456'.length));\n  });\n\n  test('#insertMarkers inserts the markers at end', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref64) {\n      var post = _ref64.post;\n      var markupSection = _ref64.markupSection;\n      var marker = _ref64.marker;\n      var markup = _ref64.markup;\n\n      toInsert = [marker('123', [markup('b')]), marker('456')];\n      expected = post([markupSection('p', [marker('abc'), marker('123', [markup('b')]), marker('456')])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref65) {\n      var post = _ref65.post;\n      var markupSection = _ref65.markupSection;\n      var marker = _ref65.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    var position = editor.post.sections.head.tailPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertMarkers(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.tailPosition());\n  });\n\n  test('#insertMarkers throws if the position is not markerable', function (assert) {\n    var toInsert = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref66) {\n      var post = _ref66.post;\n      var markupSection = _ref66.markupSection;\n      var marker = _ref66.marker;\n      var markup = _ref66.markup;\n\n      toInsert = [marker('123', [markup('b')]), marker('456')];\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref67) {\n      var post = _ref67.post;\n      var cardSection = _ref67.cardSection;\n\n      return post([cardSection('some-card')]);\n    });\n    var position = editor.post.sections.head.tailPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n\n    assert.throws(function () {\n      postEditor.insertMarkers(position, toInsert);\n    }, /cannot insert.*non-markerable/i);\n  });\n\n  test('#insertText is no-op if the position section is not markerable', function (assert) {\n    var toInsert = '123';\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref68) {\n      var post = _ref68.post;\n      var cardSection = _ref68.cardSection;\n\n      return post([cardSection('test-card')]);\n    });\n    editor = buildEditorWithMobiledoc(function (_ref69) {\n      var post = _ref69.post;\n      var cardSection = _ref69.cardSection;\n\n      return post([cardSection('test-card')]);\n    });\n    var position = editor.post.sections.head.headPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertText(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.ok(!editor._renderedRange, 'no range is rendered since nothing happened');\n  });\n\n  test('#insertText inserts the text at start', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref70) {\n      var post = _ref70.post;\n      var markupSection = _ref70.markupSection;\n      var marker = _ref70.marker;\n      var markup = _ref70.markup;\n\n      toInsert = '123';\n      expected = post([markupSection('p', [marker('123abc', [markup('b')])])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref71) {\n      var post = _ref71.post;\n      var markupSection = _ref71.markupSection;\n      var marker = _ref71.marker;\n      var markup = _ref71.markup;\n\n      return post([markupSection('p', [marker('abc', [markup('b')])])]);\n    });\n    var position = editor.post.sections.head.headPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertText(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.toPosition('123'.length));\n  });\n\n  test('#insertText inserts text in the middle', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref72) {\n      var post = _ref72.post;\n      var markupSection = _ref72.markupSection;\n      var marker = _ref72.marker;\n      var markup = _ref72.markup;\n\n      toInsert = '123';\n      expected = post([markupSection('p', [marker('ab123c', [markup('b')])])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref73) {\n      var post = _ref73.post;\n      var markupSection = _ref73.markupSection;\n      var marker = _ref73.marker;\n      var markup = _ref73.markup;\n\n      return post([markupSection('p', [marker('abc', [markup('b')])])]);\n    });\n    var position = editor.post.sections.head.toPosition('ab'.length);\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertText(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.toPosition('ab123'.length));\n  });\n\n  test('#insertText inserts text at the end', function (assert) {\n    var toInsert = undefined,\n        expected = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref74) {\n      var post = _ref74.post;\n      var markupSection = _ref74.markupSection;\n      var marker = _ref74.marker;\n      var markup = _ref74.markup;\n\n      toInsert = '123';\n      expected = post([markupSection('p', [marker('abc123', [markup('b')])])]);\n    });\n\n    editor = buildEditorWithMobiledoc(function (_ref75) {\n      var post = _ref75.post;\n      var markupSection = _ref75.markupSection;\n      var marker = _ref75.marker;\n      var markup = _ref75.markup;\n\n      return post([markupSection('p', [marker('abc', [markup('b')])])]);\n    });\n    var position = editor.post.sections.head.tailPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor.insertText(position, toInsert);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n    assert.positionIsEqual(editor._renderedRange.head, editor.post.sections.head.tailPosition());\n  });\n\n  test('#_splitListItem creates two list items', function (assert) {\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref76) {\n      var post = _ref76.post;\n      var listSection = _ref76.listSection;\n      var listItem = _ref76.listItem;\n      var marker = _ref76.marker;\n      var markup = _ref76.markup;\n\n      return post([listSection('ul', [listItem([marker('abc'), marker('bo', [markup('b')])]), listItem([marker('ld', [markup('b')])])])]);\n    });\n    editor = buildEditorWithMobiledoc(function (_ref77) {\n      var post = _ref77.post;\n      var listSection = _ref77.listSection;\n      var listItem = _ref77.listItem;\n      var marker = _ref77.marker;\n      var markup = _ref77.markup;\n\n      return post([listSection('ul', [listItem([marker('abc'), marker('bold', [markup('b')])])])]);\n    });\n\n    var item = editor.post.sections.head.items.head;\n    var position = item.toPosition('abcbo'.length);\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor._splitListItem(item, position);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n    assert.renderTreeIsEqual(editor._renderTree, expected);\n  });\n\n  test('#_splitListItem when position is start creates blank list item', function (assert) {\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref78) {\n      var post = _ref78.post;\n      var listSection = _ref78.listSection;\n      var listItem = _ref78.listItem;\n      var marker = _ref78.marker;\n\n      return post([listSection('ul', [listItem([marker('')]), listItem([marker('abc')])])]);\n    });\n    editor = buildEditorWithMobiledoc(function (_ref79) {\n      var post = _ref79.post;\n      var listSection = _ref79.listSection;\n      var listItem = _ref79.listItem;\n      var marker = _ref79.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')])])]);\n    });\n\n    var item = editor.post.sections.head.items.head;\n    var position = item.headPosition();\n    postEditor = new _mobiledocKitEditorPost['default'](editor);\n    postEditor._splitListItem(item, position);\n    postEditor.complete();\n\n    assert.postIsSimilar(editor.post, expected);\n  });\n});","define('tests/unit/editor/post/insert-post-test', ['exports', '../../../test-helpers'], function (exports, _testHelpers) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n  var retargetRange = _testHelpers['default'].editor.retargetRange;\n\n  var editor = undefined,\n      editorElement = undefined;\n  // see https://github.com/bustle/mobiledoc-kit/issues/259\n  _module('Unit: PostEditor: #insertPost', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  var blankSectionExpecations = [['* abc'], // single list item\n  ['* abc', '* def'], // multiple list items\n  ['abc'], // single section\n  ['abc', 'def'], // multiple sections, see https://github.com/bustle/mobiledoc-kit/issues/462\n  ['*abc*'], // section with markup\n  ['[my-card]'], // single card\n  ['[my-card]', '[my-other-card]'], // multiple cards\n  ['abc', '* 123', '* 456', '[my-card]']];\n  // mixed\n  blankSectionExpecations.forEach(function (dsl) {\n    test('inserting \"' + dsl + '\" in blank section replaces it', function (assert) {\n      var _Helpers$postAbstract$buildFromText = _testHelpers['default'].postAbstract.buildFromText(dsl);\n\n      var toInsert = _Helpers$postAbstract$buildFromText.post;\n\n      var expected = toInsert;\n      editor = _testHelpers['default'].editor.buildFromText(['|'], { unknownCardHandler: function unknownCardHandler() {}, element: editorElement });\n\n      editor.run(function (postEditor) {\n        return postEditor.insertPost(editor.range.head, toInsert);\n      });\n\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      assert.postIsSimilar(editor.post, expected);\n\n      var expectedRange = editor.post.tailPosition().toRange();\n      assert.rangeIsEqual(editor.range, expectedRange);\n    });\n  });\n\n  var expectationGroups = [{\n    groupName: 'insert around card',\n    expectations: [\n    // insert 1 section\n    [['|[my-card]'], ['abc'], ['abc|', '[my-card]']], [['[my-card]|'], ['abc'], ['[my-card]', 'abc|']],\n\n    // insert multiple sections\n    [['|[my-card]'], ['abc', 'def'], ['abc', 'def|', '[my-card]']], [['[my-card]|'], ['abc', 'def'], ['[my-card]', 'abc', 'def|']],\n\n    // insert list with 1 item\n    [['|[my-card]'], ['* abc'], ['* abc|', '[my-card]']], [['[my-card]|'], ['* abc'], ['[my-card]', '* abc|']],\n\n    // insert list with multiple items\n    [['|[my-card]'], ['* abc', '* def'], ['* abc', '* def|', '[my-card]']], [['[my-card]|'], ['* abc', '* def'], ['[my-card]', '* abc', '* def|']]]\n  }, {\n    groupName: 'insert card around markerable',\n    expectations: [\n    // insert card only\n    [['|abc'], ['[my-card]'], ['[my-card]|', 'abc']], [['ab|c'], ['[my-card]'], ['ab', '[my-card]|', 'c']], [['abc|'], ['[my-card]'], ['abc', '[my-card]|']],\n\n    // insert card+section\n    [['|abc'], ['[my-card]', 'def'], ['[my-card]', 'def|', 'abc']], [['ab|c'], ['[my-card]', 'def'], ['ab', '[my-card]', 'def|', 'c']], [['abc|'], ['[my-card]', 'def'], ['abc', '[my-card]', 'def|']],\n\n    // insert section+card\n    [['|abc'], ['def', '[my-card]'], ['def', '[my-card]|', 'abc']], [['ab|c'], ['def', '[my-card]'], ['abdef', '[my-card]|', 'c']], [['abc|'], ['def', '[my-card]'], ['abcdef', '[my-card]|']]]\n  }, {\n    groupName: 'insert (non-list-item) markerable(s) around markerable',\n    expectations: [\n    // insert 1 section\n    [['|abc'], ['123'], ['123|abc']], [['ab|c'], ['123'], ['ab123|c']], [['abc|'], ['123'], ['abc123|']],\n\n    // insert multiple sections\n    [['|abc'], ['123', '456'], ['123', '456|', 'abc']], [['ab|c'], ['123', '456'], ['ab123', '456|', 'c']], [['abc|'], ['123', '456'], ['abc123', '456|']]]\n  }, {\n    groupName: 'insert list item(s) around markerable',\n    expectations: [\n    // insert 1 item\n    [['|abc'], ['* 123'], ['123|abc']], [['ab|c'], ['* 123'], ['ab123|c']], [['abc|'], ['* 123'], ['abc123|']],\n\n    // insert multiple items\n    [['|abc'], ['* 123', '* 456'], ['123', '* 456|', 'abc']], [['ab|c'], ['* 123', '* 456'], ['ab123', '* 456|', 'c']], [['abc|'], ['* 123', '* 456'], ['abc123', '* 456|']]]\n  }, {\n    groupName: 'insert list+markup-section around markerable',\n    expectations: [\n    // list + markup section\n    [['|abc'], ['* 123', 'def'], ['123', 'def|', 'abc']], [['ab|c'], ['* 123', 'def'], ['ab123', 'def|', 'c']], [['abc|'], ['* 123', 'def'], ['abc123', 'def|']],\n\n    // markup section + 1-item list\n    [['|abc'], ['def', '* 123'], ['def', '* 123|', 'abc']], [['ab|c'], ['def', '* 123'], ['abdef', '* 123|', 'c']], [['abc|'], ['def', '* 123'], ['abcdef', '* 123|']],\n\n    // markup section + multi-item list\n    [['|abc'], ['def', '* 123', '* 456'], ['def', '* 123', '* 456|', 'abc']], [['ab|c'], ['def', '* 123', '* 456'], ['abdef', '* 123', '* 456|', 'c']], [['abc|'], ['def', '* 123', '* 456'], ['abcdef', '* 123', '* 456|']]]\n  }, {\n    groupName: 'insert into list',\n    expectations: [\n    // insert 1 markup section\n    [['* |abc'], ['def'], ['* def|abc']], [['* ab|c'], ['def'], ['* abdef|c']], [['* abc|'], ['def'], ['* abcdef|']],\n\n    // insert multiple markup sections\n    [['* abc|'], ['def', 'ghi'], ['* abcdef', '* ghi|']],\n    // See https://github.com/bustle/mobiledoc-kit/issues/456\n    [['* abc', '* def|'], ['ghi', 'jkl'], ['* abc', '* defghi', '* jkl|']],\n\n    // insert markup sections + card\n    [['* abc', '* def|'], ['ghi', 'jkl', '[my-card]'], ['* abc', '* defghi', '* jkl', '[my-card]|']],\n\n    // insert list item\n    [['* |abc'], ['* def'], ['* def|abc']], [['* ab|c'], ['* def'], ['* abdef|c']], [['* abc|'], ['* def'], ['* abcdef|']],\n\n    // insert multiple list items\n    [['* |abc'], ['* def', '* ghi'], ['* def', '* ghi|', '* abc']], [['* ab|c'], ['* def', '* ghi'], ['* abdef', '* ghi|', '* c']], [['* abc|'], ['* def', '* ghi'], ['* abcdef', '* ghi|']],\n\n    // insert list + markup\n    [['* |abc'], ['* def', '123'], ['* def', '123|', '* abc']], [['* ab|c'], ['* def', '123'], ['* abdef', '123|', '* c']], [['* abc|'], ['* def', '123'], ['* abcdef', '123|']],\n\n    // insert into empty list\n    [['* |'], ['[my-card]'], ['* ', '[my-card]|']], [['* |'], ['abc'], ['* abc|']], [['* |'], ['abc', 'def'], ['* abc', '* def|']], [['* |'], ['* abc'], ['* abc|']], [['* |'], ['* abc', '* def'], ['* abc', '* def|']],\n\n    /// insert between list items ///\n\n    // insert card between list items\n    [['* abc|', '* def'], ['[my-card]'], ['* abc', '[my-card]|', '* def']], [['* ab|c', '* def'], ['[my-card]'], ['* ab', '[my-card]|', '* c', '* def']], [['* abc|', '* def'], ['[my-card]'], ['* abc', '[my-card]|', '* def']],\n    // See https://github.com/bustle/mobiledoc-kit/issues/467\n    [['* abc', '* |def'], ['[my-card]'], ['* abc', '[my-card]|', '* def']],\n\n    // insert markup section between list items\n    [['* abc|', '* def'], ['123'], ['* abc123|', '* def']], [['* abc', '* |def'], ['123'], ['* abc', '* 123|def']],\n\n    // insert 1 list item between list items\n    [['* abc|', '* def'], ['* 123'], ['* abc123|', '* def']], [['* abc', '* |def'], ['* 123'], ['* abc', '* 123|def']],\n\n    // insert multiple list items between list items\n    [['* abc|', '* def'], ['* 123', '* 456'], ['* abc123', '* 456|', '* def']], [['* abc', '* |def'], ['* 123', '* 456'], ['* abc', '* 123', '* 456|', '* def']]]\n  }];\n\n  expectationGroups.forEach(function (_ref) {\n    var groupName = _ref.groupName;\n    var expectations = _ref.expectations;\n\n    expectations.forEach(function (_ref2) {\n      var _ref22 = _slicedToArray(_ref2, 3);\n\n      var editorDSL = _ref22[0];\n      var toInsertDSL = _ref22[1];\n      var expectedDSL = _ref22[2];\n\n      test(groupName + ': inserting \"' + toInsertDSL + '\" in \"' + editorDSL + '\" -> \"' + expectedDSL + '\"', function (assert) {\n        editor = _testHelpers['default'].editor.buildFromText(editorDSL, { unknownCardHandler: function unknownCardHandler() {}, element: editorElement });\n\n        var _Helpers$postAbstract$buildFromText2 = _testHelpers['default'].postAbstract.buildFromText(toInsertDSL);\n\n        var toInsert = _Helpers$postAbstract$buildFromText2.post;\n\n        var _Helpers$postAbstract$buildFromText3 = _testHelpers['default'].postAbstract.buildFromText(expectedDSL);\n\n        var expectedPost = _Helpers$postAbstract$buildFromText3.post;\n        var expectedRange = _Helpers$postAbstract$buildFromText3.range;\n\n        editor.run(function (postEditor) {\n          return postEditor.insertPost(editor.range.head, toInsert);\n        });\n\n        assert.renderTreeIsEqual(editor._renderTree, expectedPost);\n        assert.postIsSimilar(editor.post, expectedPost);\n        assert.rangeIsEqual(editor.range, retargetRange(expectedRange, editor.post));\n      });\n    });\n  });\n});","define('tests/unit/editor/ui-test', ['exports', 'mobiledoc-kit/editor/ui', '../../test-helpers'], function (exports, _mobiledocKitEditorUi, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  _module('Unit: UI', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('toggleLink calls the default window prompt', function (assert) {\n    assert.expect(1);\n    window.prompt = function () {\n      return assert.ok(true, 'window.prompt called');\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    _testHelpers['default'].dom.selectText(editor, 'something', editorElement);\n\n    (0, _mobiledocKitEditorUi.toggleLink)(editor);\n  });\n\n  test('toggleLink accepts a custom prompt function', function (assert) {\n    assert.expect(1);\n\n    var prompt = function prompt() {\n      return assert.ok(true, 'custom prompt called');\n    };\n\n    editor = _testHelpers['default'].mobiledoc.renderIntoAndFocusTail(editorElement, function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n      return post([markupSection('p', [marker('something')])]);\n    });\n\n    _testHelpers['default'].dom.selectText(editor, 'something', editorElement);\n\n    (0, _mobiledocKitEditorUi.toggleLink)(editor, prompt);\n  });\n});","define('tests/unit/models/atom-test', ['exports', '../../test-helpers', 'mobiledoc-kit/models/post-node-builder'], function (exports, _testHelpers, _mobiledocKitModelsPostNodeBuilder) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined;\n  _module('Unit: Atom', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    },\n    afterEach: function afterEach() {\n      builder = null;\n    }\n  });\n\n  test('can create an atom with value and payload', function (assert) {\n    var payload = {};\n    var value = 'atom-value';\n    var name = 'atom-name';\n    var atom = builder.createAtom(name, value, payload);\n    assert.ok(!!atom, 'creates atom');\n    assert.ok(atom.name === name, 'has name');\n    assert.ok(atom.value === value, 'has value');\n    assert.ok(atom.payload === payload, 'has payload');\n    assert.ok(atom.length === 1, 'has length of 1');\n  });\n});","define('tests/unit/models/card-test', ['exports', '../../test-helpers', 'mobiledoc-kit/models/post-node-builder'], function (exports, _testHelpers, _mobiledocKitModelsPostNodeBuilder) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined;\n  _module('Unit: Card', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    },\n    afterEach: function afterEach() {\n      builder = null;\n    }\n  });\n\n  test('can create a card with payload', function (assert) {\n    var payload = {};\n    var card = builder.createCardSection('card-name', payload);\n    assert.ok(!!card, 'creates card');\n    assert.ok(card.payload === payload, 'has payload');\n  });\n\n  test('cloning a card copies payload', function (assert) {\n    var payload = { foo: 'bar' };\n\n    var card = builder.createCardSection('card-name', payload);\n    var card2 = card.clone();\n\n    assert.ok(card !== card2, 'card !== cloned');\n    assert.ok(card.payload !== card2.payload, 'payload is copied');\n\n    card.payload.foo = 'other foo';\n    assert.equal(card2.payload.foo, 'bar', 'card2 payload not updated');\n  });\n});","define('tests/unit/models/lifecycle-callbacks-test', ['exports', '../../test-helpers', 'mobiledoc-kit/models/lifecycle-callbacks'], function (exports, _testHelpers, _mobiledocKitModelsLifecycleCallbacks) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Models: LifecycleCallbacksMixin');\n\n  test('#addCallback permanently adds the callback', function (assert) {\n    var item = new _mobiledocKitModelsLifecycleCallbacks['default'](['test']);\n    var queueName = 'test';\n    var called = 0;\n    var callback = function callback() {\n      return called++;\n    };\n    item.addCallback(queueName, callback);\n\n    item.runCallbacks(queueName);\n    assert.equal(called, 1);\n\n    item.runCallbacks(queueName);\n    assert.equal(called, 2, 'callback is run a second time');\n  });\n\n  test('#addCallback callback only runs in its queue', function (assert) {\n    var item = new _mobiledocKitModelsLifecycleCallbacks['default'](['test', 'other']);\n    var queueName = 'test';\n    var called = 0;\n    var callback = function callback() {\n      return called++;\n    };\n    item.addCallback(queueName, callback);\n\n    var otherQueueName = 'other';\n    item.runCallbacks(otherQueueName);\n\n    assert.equal(called, 0);\n  });\n\n  test('callbacks run with arguments', function (assert) {\n    var item = new _mobiledocKitModelsLifecycleCallbacks['default'](['test']);\n    var queueName = 'test';\n    var arg1 = undefined,\n        arg2 = undefined;\n    var foo = {},\n        bar = {};\n    var callback = function callback(_arg1, _arg2) {\n      arg1 = _arg1;\n      arg2 = _arg2;\n    };\n    item.addCallback(queueName, callback);\n    item.runCallbacks(queueName, [foo, bar]);\n\n    assert.deepEqual(arg1, foo);\n    assert.deepEqual(arg2, bar);\n  });\n\n  test('#addCallbackOnce only runs the callback one time', function (assert) {\n    var item = new _mobiledocKitModelsLifecycleCallbacks['default'](['test']);\n    var queueName = 'test';\n    var called = 0;\n    var callback = function callback() {\n      return called++;\n    };\n    item.addCallbackOnce(queueName, callback);\n\n    item.runCallbacks(queueName);\n    assert.equal(called, 1, 'runs once');\n\n    item.runCallbacks(queueName);\n    assert.equal(called, 1, 'does not run twice');\n  });\n\n  test('#addCallback and #addCallbackOnce work correctly together', function (assert) {\n    var item = new _mobiledocKitModelsLifecycleCallbacks['default'](['test']);\n    var queueName = 'test';\n    var calledOnce = 0;\n    var callbackOnce = function callbackOnce() {\n      return calledOnce++;\n    };\n    var called = 0;\n    var callback = function callback() {\n      return called++;\n    };\n\n    item.addCallbackOnce(queueName, callbackOnce);\n    item.addCallback(queueName, callback);\n\n    item.runCallbacks(queueName);\n    assert.equal(called, 1, 'runs callback');\n    assert.equal(calledOnce, 1, 'runs one-time callback once');\n\n    item.runCallbacks(queueName);\n    assert.equal(called, 2, 'runs callback again');\n    assert.equal(calledOnce, 1, 'runs one-time callback only once');\n  });\n});","define('tests/unit/models/list-section-test', ['exports', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers'], function (exports, _mobiledocKitModelsPostNodeBuilder, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined;\n  _module('Unit: List Section', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    },\n    afterEach: function afterEach() {\n      builder = null;\n    }\n  });\n\n  test('cloning a list section creates the same type of list section', function (assert) {\n    var item = builder.createListItem([builder.createMarker('abc')]);\n    var list = builder.createListSection('ol', [item]);\n    var cloned = list.clone();\n\n    assert.equal(list.tagName, cloned.tagName);\n    assert.equal(list.items.length, cloned.items.length);\n    assert.equal(list.items.head.text, cloned.items.head.text);\n  });\n});","define('tests/unit/models/marker-test', ['exports', '../../test-helpers', 'mobiledoc-kit/models/post-node-builder'], function (exports, _testHelpers, _mobiledocKitModelsPostNodeBuilder) {\n  'use strict';\n\n  function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined;\n  _module('Unit: Marker', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    },\n    afterEach: function afterEach() {\n      builder = null;\n    }\n  });\n\n  test('a marker can have a markup applied to it', function (assert) {\n    var m1 = builder.createMarker('hi there!');\n    m1.addMarkup(builder.createMarkup('b'));\n\n    assert.ok(m1.hasMarkup('b'));\n  });\n\n  test('a marker can have the same markup tagName applied twice', function (assert) {\n    var m1 = builder.createMarker('hi there!');\n    m1.addMarkup(builder.createMarkup('b'));\n    m1.addMarkup(builder.createMarkup('b'));\n\n    assert.equal(m1.markups.length, 2, 'markup only applied once');\n  });\n\n  test('a marker can have a complex markup applied to it', function (assert) {\n    var m1 = builder.createMarker('hi there!');\n    var markup = builder.createMarkup('a', { href: 'blah' });\n    m1.addMarkup(markup);\n\n    assert.ok(m1.hasMarkup('a'));\n    assert.equal(m1.getMarkup('a').attributes.href, 'blah');\n  });\n\n  test('a marker can have the same complex markup tagName applied twice, even with different attributes', function (assert) {\n    var m1 = builder.createMarker('hi there!');\n    var markup1 = builder.createMarkup('a', { href: 'blah' });\n    var markup2 = builder.createMarkup('a', { href: 'blah2' });\n    m1.addMarkup(markup1);\n    m1.addMarkup(markup2);\n\n    assert.equal(m1.markups.length, 2, 'only one markup');\n    assert.equal(m1.getMarkup('a').attributes.href, 'blah', 'first markup is applied');\n  });\n\n  test('#split splits a marker in 3 with blank markers when no endOffset is passed', function (assert) {\n    var m1 = builder.createMarker('hi there!');\n    m1.addMarkup(builder.createMarkup('b'));\n\n    var _m1$split = m1.split(5);\n\n    var _m1$split2 = _toArray(_m1$split);\n\n    var beforeMarker = _m1$split2[0];\n\n    var afterMarkers = _m1$split2.slice(1);\n\n    assert.ok(beforeMarker.hasMarkup('b'));\n    afterMarkers.forEach(function (m) {\n      return assert.ok(m.hasMarkup('b'));\n    });\n\n    assert.equal(beforeMarker.value, 'hi th');\n    assert.equal(afterMarkers[0].value, 'ere!');\n    assert.ok(afterMarkers[1].isBlank, 'final split marker is empty');\n  });\n\n  test('#split splits a marker in 3 when endOffset is passed', function (assert) {\n    var m = builder.createMarker('hi there!');\n    m.addMarkup(builder.createMarkup('b'));\n\n    var _m$split = m.split(2, 4);\n\n    var _m$split2 = _toArray(_m$split);\n\n    var beforeMarker = _m$split2[0];\n\n    var afterMarkers = _m$split2.slice(1);\n\n    assert.equal(1 + afterMarkers.length, 3, 'creates 3 new markers');\n    assert.ok(beforeMarker.hasMarkup('b'), 'beforeMarker has markup');\n    afterMarkers.forEach(function (m) {\n      return assert.ok(m.hasMarkup('b'), 'afterMarker has markup');\n    });\n\n    assert.equal(beforeMarker.value, 'hi');\n    assert.equal(afterMarkers[0].value, ' t');\n    assert.equal(afterMarkers[1].value, 'here!');\n  });\n\n  test('#split creates an initial empty marker if the offset is 0', function (assert) {\n    var m = builder.createMarker('hi there!');\n\n    var _m$split3 = m.split(0);\n\n    var _m$split32 = _toArray(_m$split3);\n\n    var beforeMarker = _m$split32[0];\n\n    var afterMarkers = _m$split32.slice(1);\n\n    assert.equal(afterMarkers.length, 2, '2 after markers');\n    assert.ok(beforeMarker.isBlank, 'beforeMarker is empty');\n    assert.equal(afterMarkers[0].value, 'hi there!');\n    assert.ok(afterMarkers[1].isBlank, 'final afterMarker is empty');\n  });\n\n  test('#clone a marker', function (assert) {\n    var marker = builder.createMarker('hi there!');\n    var cloned = marker.clone();\n    assert.equal(marker.builder, cloned.builder, 'builder is present');\n    assert.equal(marker.value, cloned.value, 'value is present');\n    assert.equal(marker.markups.length, cloned.markups.length, 'markup length is the same');\n  });\n\n  // https://github.com/bustle/mobiledoc-kit/issues/274\n  test('#deleteValueAtOffset handles emoji', function (assert) {\n    var str = 'monkey 🙈';\n    assert.equal(str.length, 'monkey '.length + 2, 'string length reports monkey emoji as length 2');\n    var marker = builder.createMarker(str);\n    marker.deleteValueAtOffset(str.length - 1);\n    assert.equal(marker.value, 'monkey ', 'deletes correctly from low surrogate');\n\n    marker = builder.createMarker(str);\n    marker.deleteValueAtOffset(str.length - 2);\n    assert.equal(marker.value, 'monkey ', 'deletes correctly from high surrogate');\n  });\n});","define('tests/unit/models/markup-section-test', ['exports', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers', 'mobiledoc-kit/utils/cursor/position'], function (exports, _mobiledocKitModelsPostNodeBuilder, _testHelpers, _mobiledocKitUtilsCursorPosition) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined;\n  _module('Unit: Markup Section', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    },\n    afterEach: function afterEach() {\n      builder = null;\n    }\n  });\n\n  test('a section can append a marker', function (assert) {\n    var s1 = builder.createMarkupSection('P');\n    var m1 = builder.createMarker('hello');\n\n    s1.markers.append(m1);\n    assert.equal(s1.markers.length, 1);\n  });\n\n  test('#isBlank returns true if the text length is zero for two markers', function (assert) {\n    var m1 = builder.createMarker('');\n    var m2 = builder.createMarker('');\n    var s = builder.createMarkupSection('p', [m1, m2]);\n    assert.ok(s.isBlank, 'section with two blank markers is blank');\n  });\n\n  test('#isBlank returns true if there are no markers', function (assert) {\n    var s = builder.createMarkupSection('p');\n    assert.ok(s.isBlank, 'section with no markers is blank');\n  });\n\n  test('#isBlank returns false if there is a marker with length', function (assert) {\n    var m = builder.createMarker('a');\n    var s = builder.createMarkupSection('p', [m]);\n    assert.ok(!s.isBlank, 'section with marker is not blank');\n  });\n\n  test('#markersFor clones markers', function (assert) {\n    var m = builder.createMarker('a');\n    var s = builder.createMarkupSection('p', [m]);\n    var clones = s.markersFor(0, 1);\n    assert.equal(clones.length, 1, 'correct number of clones are created');\n    assert.ok(clones[0] !== m, 'marker is cloned');\n    assert.equal(clones[0].value, m.value, 'marker content is the same');\n  });\n\n  test('#markersFor clones markers, trimming at tailOffset', function (assert) {\n    var m1 = builder.createMarker('ab');\n    var m2 = builder.createMarker('cd');\n    var s = builder.createMarkupSection('p', [m1, m2]);\n    var clones = s.markersFor(0, 3);\n    assert.equal(clones.length, 2, 'correct number of clones are created');\n    assert.equal(clones[0].value, 'ab', 'marker content correct');\n    assert.equal(clones[1].value, 'c', 'marker content is correct');\n  });\n\n  test('#markersFor clones markers, trimming at headOffset', function (assert) {\n    var m1 = builder.createMarker('ab');\n    var m2 = builder.createMarker('cd');\n    var s = builder.createMarkupSection('p', [m1, m2]);\n    var clones = s.markersFor(1, 4);\n    assert.equal(clones.length, 2, 'correct number of clones are created');\n    assert.equal(clones[0].value, 'b', 'marker content correct');\n    assert.equal(clones[1].value, 'cd', 'marker content is correct');\n  });\n\n  test('#markersFor clones markers, trimming at offsets that do not trim', function (assert) {\n    var m1 = builder.createMarker('ab');\n    var m2 = builder.createMarker('cd');\n    var m3 = builder.createMarker('ef');\n    var s = builder.createMarkupSection('p', [m1, m2, m3]);\n    var clones = s.markersFor(2, 4);\n    assert.equal(clones.length, 1, 'correct number of clones are created');\n    assert.equal(clones[0].value, 'cd', 'marker content correct');\n  });\n\n  test('#markersFor clones markers when offset completely surrounds a marker', function (assert) {\n    var m1 = builder.createMarker('ab'); // 0-2\n    var m2 = builder.createMarker('cd1'); // 2-5\n    var m3 = builder.createMarker('cd2'); // 5-8\n    var m4 = builder.createMarker('ef'); // 8-10\n    var s = builder.createMarkupSection('p', [m1, m2, m3, m4]);\n    var clones = s.markersFor(3, 9);\n    assert.equal(clones.length, 3, 'correct number of clones are created');\n    assert.equal(clones[0].value, 'd1', 'marker content correct');\n    assert.equal(clones[1].value, 'cd2', 'marker content correct');\n    assert.equal(clones[2].value, 'e', 'marker content correct');\n  });\n\n  test('#markersFor clones a single marker with a tail offset', function (assert) {\n    var m1 = builder.createMarker(' def');\n    var s = builder.createMarkupSection('p', [m1]);\n    var clones = s.markersFor(0, 1);\n    assert.equal(clones.length, 1);\n    assert.equal(clones[0].value, ' ');\n  });\n\n  test('instantiating with invalid tagName throws', function (assert) {\n    assert.throws(function () {\n      builder.createMarkupSection('blah');\n    }, /Cannot set.*tagName.*blah/);\n  });\n\n  test('markerBeforeOffset returns marker the ends at offset', function (assert) {\n    var marker = builder.createMarker;\n    var section = builder.createMarkupSection('p', [marker('a'), marker('bc'), marker('def')]);\n\n    assert.ok(section.markerBeforeOffset(1) === section.markers.head);\n    assert.ok(section.markerBeforeOffset(3) === section.markers.objectAt(1));\n    assert.ok(section.markerBeforeOffset(6) === section.markers.tail);\n  });\n\n  test('markerBeforeOffset throws if offset is not between markers', function (assert) {\n    var marker = builder.createMarker;\n    var section = builder.createMarkupSection('p', [marker('a'), marker('bc'), marker('def')]);\n\n    assert.throws(function () {\n      return section.markerBeforeOffset(0);\n    }, /not between/);\n    assert.throws(function () {\n      return section.markerBeforeOffset(2);\n    }, /not between/);\n    assert.throws(function () {\n      return section.markerBeforeOffset(4);\n    }, /not between/);\n    assert.throws(function () {\n      return section.markerBeforeOffset(5);\n    }, /not between/);\n  });\n\n  test('markerBeforeOffset returns first marker if it is empty and offset is 0', function (assert) {\n    var marker = function marker(text) {\n      return builder.createMarker(text);\n    };\n    var section = builder.createMarkupSection('p', [marker(''), marker('bc'), marker('def')]);\n\n    assert.ok(section.markerBeforeOffset(0) === section.markers.head);\n  });\n\n  test('splitMarkerAtOffset inserts empty marker when offset is 0', function (assert) {\n    var section = builder.createMarkupSection('p', [builder.createMarker('abc')]);\n\n    section.splitMarkerAtOffset(0);\n\n    assert.equal(section.markers.length, 2);\n    assert.deepEqual(section.markers.map(function (m) {\n      return m.value;\n    }), ['', 'abc']);\n  });\n\n  test('splitMarkerAtOffset inserts empty marker if section is blank', function (assert) {\n    var section = builder.createMarkupSection('p');\n\n    section.splitMarkerAtOffset(0);\n\n    assert.equal(section.markers.length, 1);\n    assert.deepEqual(section.markers.map(function (m) {\n      return m.value;\n    }), ['']);\n  });\n\n  test('splitMarkerAtOffset splits marker if offset is contained by marker', function (assert) {\n    var section = builder.createMarkupSection('p', [builder.createMarker('abc')]);\n\n    section.splitMarkerAtOffset(1);\n\n    assert.equal(section.markers.length, 2);\n    assert.deepEqual(section.markers.map(function (m) {\n      return m.value;\n    }), ['a', 'bc']);\n  });\n\n  test('splitMarkerAtOffset is no-op when offset is at end of marker', function (assert) {\n    var section = builder.createMarkupSection('p', [builder.createMarker('abc')]);\n\n    section.splitMarkerAtOffset(3);\n\n    assert.equal(section.markers.length, 1);\n    assert.deepEqual(section.markers.map(function (m) {\n      return m.value;\n    }), ['abc']);\n  });\n\n  test('splitMarkerAtOffset does nothing if the is offset is at end', function (assert) {\n    var marker = function marker(text) {\n      return builder.createMarker(text);\n    };\n    var section = builder.createMarkupSection('p', [marker('a'), marker('bc')]);\n\n    section.splitMarkerAtOffset(3);\n\n    assert.equal(section.markers.length, 2);\n    assert.deepEqual(section.markers.map(function (m) {\n      return m.value;\n    }), ['a', 'bc']);\n  });\n\n  test('splitMarkerAtOffset splits a marker deep in the middle', function (assert) {\n    var marker = function marker(text) {\n      return builder.createMarker(text);\n    };\n    var section = builder.createMarkupSection('p', [marker('a'), marker('bc'), marker('def'), marker('ghi')]);\n\n    section.splitMarkerAtOffset(5);\n\n    assert.equal(section.markers.length, 5);\n    assert.deepEqual(section.markers.map(function (m) {\n      return m.value;\n    }), ['a', 'bc', 'de', 'f', 'ghi']);\n  });\n\n  test('a section has property `isSection`', function (assert) {\n    var section = builder.createMarkupSection();\n    assert.ok(section.isSection, 'section.isSection');\n  });\n\n  test('#length is correct', function (assert) {\n    var expectations = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref) {\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n      var atom = _ref.atom;\n\n      expectations = [{\n        name: 'blank section',\n        length: 0,\n        section: markupSection()\n      }, {\n        name: 'section with empty marker',\n        length: 0,\n        section: markupSection('p', [marker('')])\n      }, {\n        name: 'section with single marker',\n        length: 'abc'.length,\n        section: markupSection('p', [marker('abc')])\n      }, {\n        name: 'section with multiple markers',\n        length: 'abc'.length + 'defg'.length,\n        section: markupSection('p', [marker('abc'), marker('defg')])\n      }, {\n        name: 'section with atom',\n        length: 1,\n        section: markupSection('p', [atom('mention', 'bob')])\n      }, {\n        name: 'section with multiple atoms',\n        length: 2,\n        section: markupSection('p', [atom('mention', 'bob'), atom('mention', 'other')])\n      }, {\n        name: 'section with atom and markers',\n        length: 'abc'.length + 1,\n        section: markupSection('p', [marker('abc'), atom('mention', 'bob')])\n      }];\n    });\n\n    assert.expect(expectations.length);\n    expectations.forEach(function (_ref2) {\n      var name = _ref2.name;\n      var length = _ref2.length;\n      var section = _ref2.section;\n\n      assert.equal(section.length, length, name + ' has correct length');\n    });\n  });\n\n  test('#textUntil is correct', function (assert) {\n    var expectations = undefined;\n\n    _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n      var atom = _ref3.atom;\n\n      expectations = [{\n        name: 'blank section',\n        text: '',\n        section: markupSection(),\n        offset: 0\n      }, {\n        name: 'section with empty marker',\n        text: '',\n        section: markupSection('p', [marker('')]),\n        offset: 0\n      }, {\n        name: 'section with single marker end',\n        text: 'abc',\n        section: markupSection('p', [marker('abc')]),\n        offset: 'abc'.length\n      }, {\n        name: 'section with single marker middle',\n        text: 'ab',\n        section: markupSection('p', [marker('abc')]),\n        offset: 'ab'.length\n      }, {\n        name: 'section with single marker start',\n        text: '',\n        section: markupSection('p', [marker('abc')]),\n        offset: 0\n      }, {\n        name: 'section with multiple markers end',\n        text: 'abcdefg',\n        section: markupSection('p', [marker('abc'), marker('defg')]),\n        offset: 'abc'.length + 'defg'.length\n      }, {\n        name: 'section with multiple markers middle',\n        text: 'abcde',\n        section: markupSection('p', [marker('abc'), marker('defg')]),\n        offset: 'abc'.length + 'de'.length\n      }, {\n        name: 'section with atom has no text for atom',\n        text: '',\n        section: markupSection('p', [atom('mention', 'bob')]),\n        offset: 1\n      }, {\n        name: 'section with multiple atoms has no text for atoms',\n        text: '',\n        section: markupSection('p', [atom('mention', 'bob'), atom('mention', 'other')]),\n        offset: 2\n      }, {\n        name: 'section with atom and markers has text for markers only',\n        text: 'abc',\n        section: markupSection('p', [marker('abc'), atom('mention', 'bob')]),\n        offset: 'abc'.length + 1\n      }];\n    });\n\n    assert.expect(expectations.length);\n    expectations.forEach(function (_ref4) {\n      var name = _ref4.name;\n      var text = _ref4.text;\n      var section = _ref4.section;\n      var offset = _ref4.offset;\n\n      assert.equal(text, section.textUntil(new _mobiledocKitUtilsCursorPosition['default'](section, offset)), name);\n    });\n  });\n});","define('tests/unit/models/post-node-builder-test', ['exports', '../../test-helpers', 'mobiledoc-kit/models/post-node-builder'], function (exports, _testHelpers, _mobiledocKitModelsPostNodeBuilder) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: PostNodeBuilder');\n\n  test('#createMarkup returns singleton markup', function (assert) {\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    var m1 = builder.createMarkup('strong');\n    var m2 = builder.createMarkup('strong');\n\n    assert.ok(m1 === m2, 'markups are singletons');\n  });\n\n  test('#createMarkup returns singleton markup when has equal attributes', function (assert) {\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    var m1 = builder.createMarkup('a', { href: 'bustle.com' });\n    var m2 = builder.createMarkup('a', { href: 'bustle.com' });\n\n    assert.ok(m1 === m2, 'markups with attributes are singletons');\n  });\n\n  test('#createMarkup returns differents markups when has different attributes', function (assert) {\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    var m1 = builder.createMarkup('a', { href: 'bustle.com' });\n    var m2 = builder.createMarkup('a', { href: 'other.com' });\n\n    assert.ok(m1 !== m2, 'markups with different attributes are different');\n  });\n\n  test('#createMarkup normalizes tagName', function (assert) {\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    var m1 = builder.createMarkup('b');\n    var m2 = builder.createMarkup('B');\n    var m3 = builder.createMarkup('b', {});\n    var m4 = builder.createMarkup('B', {});\n\n    assert.ok(m1 === m2 && m2 === m3 && m3 === m4, 'all markups are the same');\n  });\n\n  test('#createCardSection creates card with builder', function (assert) {\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    var cardSection = builder.createCardSection('test-card');\n    assert.ok(cardSection.builder === builder, 'card section has builder');\n  });\n});","define('tests/unit/models/post-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/cursor/range', 'mobiledoc-kit/utils/cursor/position'], function (exports, _testHelpers, _mobiledocKitUtilsCursorRange, _mobiledocKitUtilsCursorPosition) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Post');\n\n  test('#walkMarkerableSections finds no section when range contains only a card', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (builder) {\n      var post = builder.post;\n      var cardSection = builder.cardSection;\n\n      return post([cardSection('simple-card')]);\n    });\n\n    var foundSections = [];\n\n    var card = post.sections.objectAt(0);\n    var range = _mobiledocKitUtilsCursorRange['default'].create(card, 0, card, 0);\n\n    post.walkMarkerableSections(range, function (s) {\n      return foundSections.push(s);\n    });\n    assert.equal(foundSections.length, 0, 'found no markerable sections');\n  });\n\n  test('#walkMarkerableSections skips non-markerable sections', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (builder) {\n      var post = builder.post;\n      var markupSection = builder.markupSection;\n      var marker = builder.marker;\n      var cardSection = builder.cardSection;\n\n      return post([markupSection('p', ['s1m1'].map(function (t) {\n        return marker(t);\n      })), markupSection('p', ['s2m1'].map(function (t) {\n        return marker(t);\n      })), cardSection('simple-card'), markupSection('p', ['s3m1'].map(function (t) {\n        return marker(t);\n      })), markupSection('p', ['s4m1'].map(function (t) {\n        return marker(t);\n      }))]);\n    });\n\n    var foundSections = [];\n\n    var s1 = post.sections.objectAt(0);\n    var s4 = post.sections.objectAt(4);\n\n    assert.equal(s1.text, 's1m1', 'precond - find s1');\n    assert.equal(s4.text, 's4m1', 'precond - find s4');\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(s1, 0, s4, 0);\n\n    post.walkMarkerableSections(range, function (s) {\n      return foundSections.push(s);\n    });\n\n    assert.deepEqual(foundSections.map(function (s) {\n      return s.text;\n    }), ['s1m1', 's2m1', 's3m1', 's4m1'], 'iterates correct sections');\n  });\n\n  test('#walkAllLeafSections returns markup section that follows a list section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n      var listSection = _ref.listSection;\n      var listItem = _ref.listItem;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('def')]), listSection('ul', [listItem([marker('123')])]), markupSection('p')]);\n    });\n\n    var sections = [];\n    post.walkAllLeafSections(function (s) {\n      return sections.push(s);\n    });\n\n    assert.equal(sections.length, 4);\n    assert.ok(sections[0] === post.sections.head, 'section 0');\n    assert.ok(sections[1] === post.sections.objectAt(1), 'section 1');\n    assert.ok(sections[2] === post.sections.objectAt(2).items.head, 'section 2');\n    assert.ok(sections[3] === post.sections.tail, 'section 3');\n  });\n\n  test('#markupsInRange returns all markups when range is not collapsed', function (assert) {\n    var b = undefined,\n        i = undefined,\n        a1 = undefined,\n        a2 = undefined,\n        found = undefined,\n        collapsedRange = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (builder) {\n      var post = builder.post;\n      var markupSection = builder.markupSection;\n      var cardSection = builder.cardSection;\n      var marker = builder.marker;\n      var markup = builder.markup;\n\n      b = markup('strong');\n      i = markup('em');\n      a1 = markup('a', { href: 'example.com' });\n      a2 = markup('a', { href: 'other-example.com' });\n\n      return post([markupSection('p', [marker('plain text'), marker('bold text', [b]), marker('i text', [i]), marker('bold+i text', [b, i])]), markupSection('p', [marker('link 1', [a1])]), cardSection('simple-card'), markupSection('p', [marker('link 2', [a2])])]);\n    });\n\n    var _post$sections$toArray = post.sections.toArray();\n\n    var _post$sections$toArray2 = _slicedToArray(_post$sections$toArray, 4);\n\n    var s1 = _post$sections$toArray2[0];\n    var s2 = _post$sections$toArray2[1];\n    var s3 = _post$sections$toArray2[3];\n\n    assert.equal(s1.text, 'plain textbold texti textbold+i text', 'precond s1');\n    assert.equal(s2.text, 'link 1', 'precond s2');\n    assert.equal(s3.text, 'link 2', 'precond s3');\n\n    collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 0);\n    assert.equal(post.markupsInRange(collapsedRange).length, 0, 'no markups in collapsed range at start');\n\n    collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 'plain text'.length);\n    assert.equal(post.markupsInRange(collapsedRange).length, 0, 'no markups in collapsed range at end of plain text');\n\n    collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 'plain textbold'.length);\n    found = post.markupsInRange(collapsedRange);\n    assert.equal(found.length, 1, 'markup in collapsed range in bold text');\n    assert.inArray(b, found, 'finds b in bold text');\n\n    collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 'plain textbold text'.length);\n    found = post.markupsInRange(collapsedRange);\n    assert.equal(found.length, 1, 'markup in collapsed range at end of bold text');\n    assert.inArray(b, found, 'finds b at end of bold text');\n\n    var simpleRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 0, s1, 'plain text'.length);\n    assert.equal(post.markupsInRange(simpleRange).length, 0, 'no markups in simple range');\n\n    var singleMarkerRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 'plain textb'.length, s1, 'plain textbold'.length);\n    found = post.markupsInRange(singleMarkerRange);\n    assert.equal(found.length, 1, 'finds markup in marker');\n    assert.inArray(b, found, 'finds b');\n\n    var singleSectionRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 0, s1, s1.length);\n    found = post.markupsInRange(singleSectionRange);\n    assert.equal(found.length, 2, 'finds both markups in section');\n    assert.inArray(b, found, 'finds b');\n    assert.inArray(i, found, 'finds i');\n\n    var multiSectionRange = _mobiledocKitUtilsCursorRange['default'].create(s1, 'plain textbold te'.length, s2, 'link'.length);\n    found = post.markupsInRange(multiSectionRange);\n    assert.equal(found.length, 3, 'finds all markups in multi-section range');\n    assert.inArray(b, found, 'finds b');\n    assert.inArray(i, found, 'finds i');\n    assert.inArray(a1, found, 'finds a1');\n\n    var rangeSpanningCard = _mobiledocKitUtilsCursorRange['default'].create(s1, 0, s3, 'link'.length);\n    found = post.markupsInRange(rangeSpanningCard);\n    assert.equal(found.length, 4, 'finds all markups in spanning section range');\n    assert.inArray(b, found, 'finds b');\n    assert.inArray(i, found, 'finds i');\n    assert.inArray(a1, found, 'finds a1');\n    assert.inArray(a2, found, 'finds a2');\n  });\n\n  test('#markupsInRange obeys left- and right-inclusive rules for \"A\" markups', function (assert) {\n    var a = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n      var markup = _ref2.markup;\n\n      a = markup('a', { href: 'example.com' });\n      return post([markupSection('p', [marker('123', [a]), marker(' abc '), marker('def', [a]), marker(' ghi '), marker('jkl', [a])])]);\n    });\n\n    var section = post.sections.head;\n    var start = _mobiledocKitUtilsCursorRange['default'].create(section, 0);\n    var left = _mobiledocKitUtilsCursorRange['default'].create(section, '123 abc '.length);\n    var inside = _mobiledocKitUtilsCursorRange['default'].create(section, '123 abc d'.length);\n    var right = _mobiledocKitUtilsCursorRange['default'].create(section, '123 abc def'.length);\n    var end = _mobiledocKitUtilsCursorRange['default'].create(section, '123 abc def ghi jkl'.length);\n\n    assert.deepEqual(post.markupsInRange(start), [], 'no markups at start');\n    assert.deepEqual(post.markupsInRange(left), [], 'no markups at left');\n    assert.deepEqual(post.markupsInRange(right), [], 'no markups at right');\n    assert.deepEqual(post.markupsInRange(inside), [a], '\"A\" markup inside range');\n    assert.deepEqual(post.markupsInRange(end), [], 'no markups at end');\n  });\n\n  test('#markersContainedByRange when range is single marker', function (assert) {\n    var found = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var post = _ref3.post;\n      var marker = _ref3.marker;\n      var markupSection = _ref3.markupSection;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var innerRange = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 1, post.sections.head, 2);\n    found = post.markersContainedByRange(innerRange);\n    assert.equal(found.length, 0, '0 markers in innerRange');\n\n    var outerRange = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 0, post.sections.head, 3);\n    found = post.markersContainedByRange(outerRange);\n    assert.equal(found.length, 1, '1 marker in outerRange');\n    assert.ok(found[0] === post.sections.head.markers.head, 'finds right marker');\n  });\n\n  test('#markersContainedByRange when range is single section', function (assert) {\n    var found = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var post = _ref4.post;\n      var marker = _ref4.marker;\n      var markupSection = _ref4.markupSection;\n\n      return post([markupSection('p', [marker('abc'), marker('def'), marker('ghi')])]);\n    });\n\n    var section = post.sections.head;\n\n    var innerRange = _mobiledocKitUtilsCursorRange['default'].create(section, 2, section, 4);\n    found = post.markersContainedByRange(innerRange);\n    assert.equal(found.length, 0, '0 markers in innerRange');\n\n    var middleRange = _mobiledocKitUtilsCursorRange['default'].create(section, 2, section, 7);\n    found = post.markersContainedByRange(middleRange);\n    assert.equal(found.length, 1, '1 markers in middleRange');\n    assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');\n\n    var middleRangeLeftFencepost = _mobiledocKitUtilsCursorRange['default'].create(section, 3, section, 7);\n    found = post.markersContainedByRange(middleRangeLeftFencepost);\n    assert.equal(found.length, 1, '1 markers in middleRangeLeftFencepost');\n    assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');\n\n    var middleRangeRightFencepost = _mobiledocKitUtilsCursorRange['default'].create(section, 2, section, 6);\n    found = post.markersContainedByRange(middleRangeRightFencepost);\n    assert.equal(found.length, 1, '1 markers in middleRangeRightFencepost');\n    assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');\n\n    var middleRangeBothFencepost = _mobiledocKitUtilsCursorRange['default'].create(section, 3, section, 6);\n    found = post.markersContainedByRange(middleRangeBothFencepost);\n    assert.equal(found.length, 1, '1 markers in middleRangeBothFencepost');\n    assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');\n\n    var outerRange = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, section.length);\n    found = post.markersContainedByRange(outerRange);\n    assert.equal(found.length, section.markers.length, 'all markers in outerRange');\n  });\n\n  test('#markersContainedByRange when range is contiguous sections', function (assert) {\n    var found = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref5) {\n      var post = _ref5.post;\n      var marker = _ref5.marker;\n      var markupSection = _ref5.markupSection;\n\n      return post([markupSection('p', [marker('abc'), marker('def'), marker('ghi')]), markupSection('p', [marker('123'), marker('456'), marker('789')])]);\n    });\n\n    var headSection = post.sections.head,\n        tailSection = post.sections.tail;\n\n    var innerRange = _mobiledocKitUtilsCursorRange['default'].create(headSection, 7, tailSection, 2);\n    found = post.markersContainedByRange(innerRange);\n    assert.equal(found.length, 0, '0 markers in innerRange');\n\n    var middleRange = _mobiledocKitUtilsCursorRange['default'].create(headSection, 5, tailSection, 4);\n    found = post.markersContainedByRange(middleRange);\n    assert.equal(found.length, 2, '2 markers in middleRange');\n    assert.ok(found[0] === headSection.markers.objectAt(2), 'finds right head marker');\n    assert.ok(found[1] === tailSection.markers.objectAt(0), 'finds right tail marker');\n\n    var middleRangeLeftFencepost = _mobiledocKitUtilsCursorRange['default'].create(headSection, 6, tailSection, 2);\n    found = post.markersContainedByRange(middleRangeLeftFencepost);\n    assert.equal(found.length, 1, '1 markers in middleRangeLeftFencepost');\n    assert.ok(found[0] === headSection.markers.objectAt(2), 'finds right head marker');\n\n    var middleRangeRightFencepost = _mobiledocKitUtilsCursorRange['default'].create(headSection, 7, tailSection, 3);\n    found = post.markersContainedByRange(middleRangeRightFencepost);\n    assert.equal(found.length, 1, '1 markers in middleRangeRightFencepost');\n    assert.ok(found[0] === tailSection.markers.objectAt(0), 'finds right marker');\n\n    var middleRangeBothFencepost = _mobiledocKitUtilsCursorRange['default'].create(headSection, 6, tailSection, 3);\n    found = post.markersContainedByRange(middleRangeBothFencepost);\n    assert.equal(found.length, 2, '2 markers in middleRangeBothFencepost');\n    assert.ok(found[0] === headSection.markers.objectAt(2), 'finds right head marker');\n    assert.ok(found[1] === tailSection.markers.objectAt(0), 'finds right tail marker');\n\n    var outerRange = _mobiledocKitUtilsCursorRange['default'].create(headSection, 0, tailSection, tailSection.length);\n    found = post.markersContainedByRange(outerRange);\n    assert.equal(found.length, headSection.markers.length + tailSection.markers.length, 'all markers in outerRange');\n  });\n\n  test('#isBlank is true when there are no sections', function (assert) {\n    var _post = undefined,\n        _section = undefined;\n    _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n\n      _post = post();\n      _section = markupSection();\n    });\n    assert.ok(_post.isBlank);\n    _post.sections.append(_section);\n    assert.ok(!_post.isBlank);\n  });\n\n  test('#trimTo creates a post from the given range', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n    var section = post.sections.head;\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 2); // \"b\"\n\n    post = post.trimTo(range);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref8) {\n      var post = _ref8.post;\n      var marker = _ref8.marker;\n      var markupSection = _ref8.markupSection;\n\n      return post([markupSection('p', [marker('b')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#trimTo copies card sections', function (assert) {\n    var cardPayload = { foo: 'bar' };\n\n    var buildPost = _testHelpers['default'].postAbstract.build;\n\n    var post = buildPost(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n      var cardSection = _ref9.cardSection;\n\n      return post([markupSection('p', [marker('abc')]), cardSection('test-card', cardPayload), markupSection('p', [marker('123')])]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head, 1, // 'b'\n    post.sections.tail, 1); // '2'\n\n    post = post.trimTo(range);\n    var expected = buildPost(function (_ref10) {\n      var post = _ref10.post;\n      var marker = _ref10.marker;\n      var markupSection = _ref10.markupSection;\n      var cardSection = _ref10.cardSection;\n\n      return post([markupSection('p', [marker('bc')]), cardSection('test-card', { foo: 'bar' }), markupSection('p', [marker('1')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#trimTo when range starts and ends in a list item', function (assert) {\n    var buildPost = _testHelpers['default'].postAbstract.build;\n\n    var post = buildPost(function (_ref11) {\n      var post = _ref11.post;\n      var listSection = _ref11.listSection;\n      var listItem = _ref11.listItem;\n      var marker = _ref11.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')])])]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.head, 0, post.sections.head.items.head, 'ab'.length);\n\n    post = post.trimTo(range);\n    var expected = buildPost(function (_ref12) {\n      var post = _ref12.post;\n      var listSection = _ref12.listSection;\n      var listItem = _ref12.listItem;\n      var marker = _ref12.marker;\n\n      return post([listSection('ul', [listItem([marker('ab')])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#trimTo when range contains multiple list items', function (assert) {\n    var buildPost = _testHelpers['default'].postAbstract.build;\n\n    var post = buildPost(function (_ref13) {\n      var post = _ref13.post;\n      var listSection = _ref13.listSection;\n      var listItem = _ref13.listItem;\n      var marker = _ref13.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')]), listItem([marker('ghi')])])]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.head, 'ab'.length, post.sections.head.items.tail, 'gh'.length);\n\n    post = post.trimTo(range);\n    var expected = buildPost(function (_ref14) {\n      var post = _ref14.post;\n      var listSection = _ref14.listSection;\n      var listItem = _ref14.listItem;\n      var marker = _ref14.marker;\n\n      return post([listSection('ul', [listItem([marker('c')]), listItem([marker('def')]), listItem([marker('gh')])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#trimTo when range contains multiple list items and more sections', function (assert) {\n    var buildPost = _testHelpers['default'].postAbstract.build;\n\n    var post = buildPost(function (_ref15) {\n      var post = _ref15.post;\n      var listSection = _ref15.listSection;\n      var listItem = _ref15.listItem;\n      var markupSection = _ref15.markupSection;\n      var marker = _ref15.marker;\n\n      return post([listSection('ul', [listItem([marker('abc')]), listItem([marker('def')]), listItem([marker('ghi')])]), markupSection('p', [marker('123')])]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(post.sections.head.items.head, 'ab'.length, post.sections.tail, '12'.length);\n\n    post = post.trimTo(range);\n    var expected = buildPost(function (_ref16) {\n      var post = _ref16.post;\n      var listSection = _ref16.listSection;\n      var listItem = _ref16.listItem;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n\n      return post([listSection('ul', [listItem([marker('c')]), listItem([marker('def')]), listItem([marker('ghi')])]), markupSection('p', [marker('12')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#headPosition and #tailPosition returns head and tail', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var marker = _ref17.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('123')])]);\n    });\n\n    var head = post.headPosition();\n    var tail = post.tailPosition();\n\n    assert.positionIsEqual(head, post.sections.head.headPosition(), 'head pos');\n    assert.positionIsEqual(tail, post.sections.tail.tailPosition(), 'tail pos');\n  });\n\n  test('#headPosition and #tailPosition when post is blank return blank', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref18) {\n      var post = _ref18.post;\n\n      return post();\n    });\n\n    var head = post.headPosition();\n    var tail = post.tailPosition();\n\n    assert.positionIsEqual(head, _mobiledocKitUtilsCursorPosition['default'].blankPosition(), 'head pos');\n    assert.positionIsEqual(tail, _mobiledocKitUtilsCursorPosition['default'].blankPosition(), 'tail pos');\n  });\n\n  test('#hasContent gives correct value', function (assert) {\n    var expectations = _testHelpers['default'].postAbstract.build(function (_ref19) {\n      var post = _ref19.post;\n      var markupSection = _ref19.markupSection;\n      var imageSection = _ref19.imageSection;\n      var marker = _ref19.marker;\n\n      return {\n        hasNoContent: [{\n          message: 'no sections',\n          post: post()\n        }, {\n          message: '1 blank section',\n          post: post([markupSection('p')])\n        }, {\n          message: '1 section with blank marker',\n          post: post([markupSection('p', [marker('')])])\n        }],\n        hasContent: [{\n          message: '1 section with non-blank marker',\n          post: post([markupSection('p', [marker('text')])])\n        }, {\n          message: '2 sections',\n          post: post([markupSection('p'), markupSection('p')])\n        }, {\n          message: 'image section',\n          post: post([imageSection()])\n        }]\n      };\n    });\n\n    expectations.hasNoContent.forEach(function (_ref20) {\n      var message = _ref20.message;\n      var post = _ref20.post;\n\n      assert.ok(!post.hasContent, message + ' !hasContent');\n    });\n    expectations.hasContent.forEach(function (_ref21) {\n      var message = _ref21.message;\n      var post = _ref21.post;\n\n      assert.ok(post.hasContent, message + ' hasContent');\n    });\n  });\n});","define('tests/unit/parsers/dom-test', ['exports', 'mobiledoc-kit/parsers/dom', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers', 'mobiledoc-kit/utils/characters'], function (exports, _mobiledocKitParsersDom, _mobiledocKitModelsPostNodeBuilder, _testHelpers, _mobiledocKitUtilsCharacters) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n  var buildFromText = _testHelpers['default'].postAbstract.buildFromText;\n\n  var ZWNJ = '‌';\n\n  var editorElement = undefined,\n      builder = undefined,\n      parser = undefined,\n      editor = undefined;\n  var editorOpts = undefined;\n  var buildDOM = _testHelpers['default'].dom.fromHTML;\n\n  var mentionAtom = {\n    name: 'mention',\n    type: 'dom',\n    render: function render(_ref) {\n      var value = _ref.value;\n\n      var element = document.createElement('span');\n      element.setAttribute('id', 'mention-atom');\n      element.appendChild(document.createTextNode(value));\n      return element;\n    }\n  };\n\n  _module('Unit: Parser: DOMParser', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      parser = new _mobiledocKitParsersDom['default'](builder);\n      editorOpts = { element: editorElement, atoms: [mentionAtom] };\n    },\n    afterEach: function afterEach() {\n      builder = null;\n      parser = null;\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  var expectations = [['<p>some text</p>', ['some text']], ['<p>some text</p><p>some other text</p>', ['some text', 'some other text']], ['<p>some &nbsp;text &nbsp;&nbsp;for &nbsp; &nbsp;you</p>', ['some  text   for    you']], ['<p>a b</p>', ['a' + _mobiledocKitUtilsCharacters.TAB + 'b']],\n\n  // multiple ps, with and without adjacent text nodes\n  ['<p>first line</p>\\n<p>second line</p>', ['first line', 'second line']], ['<p>first line</p>middle line<p>third line</p>', ['first line', 'middle line', 'third line']], ['<p>first line</p>second line', ['first line', 'second line']], ['<p>first line</p><p></p><p>third line</p>', ['first line', 'third line']], ['<b>bold text</b>', ['*bold text*']],\n\n  // unrecognized tags\n  ['<p>before<span>span</span>after</p>', ['beforespanafter']], ['<p><span><span>inner</span></span></p>', ['inner']],\n\n  //  unrecognized attribute\n  ['<p><span style=\"font-color:red;\">was red</span></p>', ['was red']],\n\n  // list elements\n  ['<ul><li>first element</li><li>second element</li></ul>', ['* first element', '* second element']],\n\n  // nested list elements\n  ['<ul><li>first element</li><li><ul><li>nested element</li></ul></li></ul>', ['* first element', '* nested element']],\n\n  // See https://github.com/bustle/mobiledoc-kit/issues/333\n  ['abc\\ndef', ['abc def']]];\n\n  var structures = [\n  // See https://github.com/bustle/mobiledoc-kit/issues/648\n  ['<section><p>first</p><p>second</p></section>', ['first', 'second'], 'one level'], ['<section><div><p>first</p><p>second</p></div></section>', ['first', 'second'], 'two levels'], ['<section><div><div><p>first</p><p>second</p></div></div></section>', ['first', 'second'], 'three levels'], ['<section><div><p>first</p></div><p>second</p></section>', ['first', 'second'], 'offset left'], ['<section><p>first</p><div><p>second</p></div></section>', ['first', 'second'], 'offset right']];\n\n  expectations.forEach(function (_ref2) {\n    var _ref22 = _slicedToArray(_ref2, 2);\n\n    var html = _ref22[0];\n    var dslText = _ref22[1];\n\n    test('#parse ' + html + ' -> ' + dslText, function (assert) {\n      var post = parser.parse(buildDOM(html));\n\n      var _buildFromText = buildFromText(dslText);\n\n      var expected = _buildFromText.post;\n\n      assert.postIsSimilar(post, expected);\n    });\n  });\n\n  structures.forEach(function (_ref3) {\n    var _ref32 = _slicedToArray(_ref3, 3);\n\n    var html = _ref32[0];\n    var dslText = _ref32[1];\n    var name = _ref32[2];\n\n    test('wrapped#parse ' + html + ' -> ' + dslText + ' (' + name + ')', function (assert) {\n      var post = parser.parse(buildDOM(html));\n\n      var _buildFromText2 = buildFromText(dslText);\n\n      var expected = _buildFromText2.post;\n\n      assert.postIsSimilar(post, expected);\n    });\n  });\n\n  test('editor#parse fixes text in atom headTextNode when atom is at start of section', function (assert) {\n    var done = assert.async();\n\n    var _buildFromText3 = buildFromText(['X@(\"name\": \"mention\", \"value\": \"bob\")']);\n\n    var expected = _buildFromText3.post;\n\n    editor = _testHelpers['default'].editor.buildFromText('@(\"name\": \"mention\", \"value\": \"bob\")', editorOpts);\n\n    var headTextNode = editor.post.sections.head.markers.head.renderNode.headTextNode;\n    assert.ok(!!headTextNode, 'precond - headTextNode');\n    headTextNode.textContent = ZWNJ + 'X';\n\n    _testHelpers['default'].wait(function () {\n      // wait for mutation\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n\n      done();\n    });\n  });\n\n  test('editor#parse fixes text in atom headTextNode when atom has atom before it', function (assert) {\n    var done = assert.async();\n\n    var _buildFromText4 = buildFromText('@(\"name\": \"mention\", \"value\": \"first\")X@(\"name\": \"mention\", \"value\": \"last\")');\n\n    var expected = _buildFromText4.post;\n\n    editor = _testHelpers['default'].editor.buildFromText('@(\"name\": \"mention\", \"value\": \"first\")@(\"name\": \"mention\", \"value\": \"last\")', editorOpts);\n\n    var headTextNode = editor.post.sections.head.markers.tail.renderNode.headTextNode;\n    assert.ok(!!headTextNode, 'precond - headTextNode');\n    headTextNode.textContent = ZWNJ + 'X';\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('editor#parse fixes text in atom headTextNode when atom has marker before it', function (assert) {\n    var done = assert.async();\n\n    var _buildFromText5 = buildFromText('textX@(\"name\":\"mention\",\"value\":\"bob\")');\n\n    var expected = _buildFromText5.post;\n\n    editor = _testHelpers['default'].editor.buildFromText('text@(\"name\":\"mention\",\"value\":\"bob\")', editorOpts);\n\n    var headTextNode = editor.post.sections.head.markers.objectAt(1).renderNode.headTextNode;\n    assert.ok(!!headTextNode, 'precond - headTextNode');\n    headTextNode.textContent = ZWNJ + 'X';\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('editor#parse fixes text in atom tailTextNode when atom is at end of section', function (assert) {\n    var done = assert.async();\n\n    var _buildFromText6 = buildFromText('@(\"name\":\"mention\",\"value\":\"bob\")X');\n\n    var expected = _buildFromText6.post;\n\n    editor = _testHelpers['default'].editor.buildFromText('@(\"name\":\"mention\",\"value\":\"bob\")', editorOpts);\n\n    var tailTextNode = editor.post.sections.head.markers.head.renderNode.tailTextNode;\n    assert.ok(!!tailTextNode, 'precond - tailTextNode');\n    tailTextNode.textContent = ZWNJ + 'X';\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('editor#parse fixes text in atom tailTextNode when atom has atom after it', function (assert) {\n    var done = assert.async();\n\n    var _buildFromText7 = buildFromText('@(\"name\":\"mention\",\"value\":\"first\")X@(\"name\":\"mention\",\"value\":\"last\")');\n\n    var expected = _buildFromText7.post;\n\n    editor = _testHelpers['default'].editor.buildFromText('@(\"name\":\"mention\",\"value\":\"first\")@(\"name\":\"mention\",\"value\":\"last\")', editorOpts);\n\n    var tailTextNode = editor.post.sections.head.markers.head.renderNode.tailTextNode;\n    assert.ok(!!tailTextNode, 'precond - tailTextNode');\n    tailTextNode.textContent = ZWNJ + 'X';\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('editor#parse fixes text in atom tailTextNode when atom has marker after it', function (assert) {\n    var done = assert.async();\n\n    var _buildFromText8 = buildFromText('@(\"name\":\"mention\",\"value\":\"bob\")Xabc');\n\n    var expected = _buildFromText8.post;\n\n    editor = _testHelpers['default'].editor.buildFromText('@(\"name\":\"mention\",\"value\":\"bob\")abc', editorOpts);\n\n    var tailTextNode = editor.post.sections.head.markers.head.renderNode.tailTextNode;\n    assert.ok(!!tailTextNode, 'precond - tailTextNode');\n    tailTextNode.textContent = ZWNJ + 'X';\n\n    _testHelpers['default'].wait(function () {\n      assert.postIsSimilar(editor.post, expected);\n      assert.renderTreeIsEqual(editor._renderTree, expected);\n      done();\n    });\n  });\n\n  test('parse empty content', function (assert) {\n    var element = buildDOM('');\n    var post = parser.parse(element);\n\n    assert.ok(post.isBlank, 'post is blank');\n  });\n\n  test('plain text creates a section', function (assert) {\n    var container = buildDOM('plain text');\n    var element = container.firstChild;\n    var post = parser.parse(element);\n\n    var _buildFromText9 = buildFromText('plain text');\n\n    var expected = _buildFromText9.post;\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('strong tag + em + text node creates section', function (assert) {\n    var element = buildDOM('<b><em>stray</em> markup tags</b>');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, 'parse 1 section');\n    assert.equal(post.sections.objectAt(0).text, 'stray markup tags');\n\n    var markers = post.sections.objectAt(0).markers.toArray();\n    assert.equal(markers.length, 2, '2 markers');\n\n    var _markers = _slicedToArray(markers, 2);\n\n    var m1 = _markers[0];\n    var m2 = _markers[1];\n\n    assert.equal(m1.value, 'stray');\n    assert.equal(m2.value, ' markup tags');\n\n    assert.ok(m1.hasMarkup('b'), 'm1 is b');\n    assert.ok(m1.hasMarkup('em'), 'm1 is em');\n\n    assert.ok(m2.hasMarkup('b'), 'm2 is b');\n    assert.ok(!m2.hasMarkup('em'), 'm1 is not em');\n  });\n\n  test('wrapped strong tag + em + text node creates section', function (assert) {\n    var element = buildDOM('<div><b><em>stray</em> markup tags</b></div>');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, 'parse 1 section');\n    assert.equal(post.sections.objectAt(0).text, 'stray markup tags');\n\n    var markers = post.sections.objectAt(0).markers.toArray();\n    assert.equal(markers.length, 2, '2 markers');\n\n    var _markers2 = _slicedToArray(markers, 2);\n\n    var m1 = _markers2[0];\n    var m2 = _markers2[1];\n\n    assert.equal(m1.value, 'stray');\n    assert.equal(m2.value, ' markup tags');\n\n    assert.ok(m1.hasMarkup('b'), 'm1 is b');\n    assert.ok(m1.hasMarkup('em'), 'm1 is em');\n\n    assert.ok(m2.hasMarkup('b'), 'm2 is b');\n    assert.ok(!m2.hasMarkup('em'), 'm1 is not em');\n  });\n\n  test('link (A tag) is parsed', function (assert) {\n    var url = 'http://bustle.com',\n        rel = 'nofollow';\n    var element = buildDOM('<a href=\"' + url + '\" rel=\"' + rel + '\">link</a>');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n    assert.equal(post.sections.objectAt(0).text, 'link');\n\n    var markers = post.sections.objectAt(0).markers.toArray();\n    assert.equal(markers.length, 1, '1 marker');\n\n    var _markers3 = _slicedToArray(markers, 1);\n\n    var marker = _markers3[0];\n\n    assert.equal(marker.value, 'link');\n    assert.ok(marker.hasMarkup('a'), 'has A markup');\n\n    var markup = marker.markups[0];\n    assert.equal(markup.getAttribute('href'), url, 'has href attr');\n    assert.equal(markup.getAttribute('rel'), rel, 'has rel attr');\n  });\n\n  test('span with font-style italic maps to em', function (assert) {\n    var element = buildDOM('<p><span style=\"font-style:ItaLic;\">emph</span></p>');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n\n    var section = post.sections.objectAt(0);\n    assert.equal(section.markers.length, 1, '1 marker');\n    var marker = section.markers.objectAt(0);\n\n    assert.equal(marker.value, 'emph');\n    assert.ok(marker.hasMarkup('em'), 'marker is em');\n  });\n\n  test('span with font-weight 700 maps to strong', function (assert) {\n    var element = buildDOM('<p><span style=\"font-weight:700;\">bold 700</span></p>');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n\n    var section = post.sections.objectAt(0);\n    assert.equal(section.markers.length, 1, '1 marker');\n    var marker = section.markers.objectAt(0);\n\n    assert.equal(marker.value, 'bold 700');\n    assert.ok(marker.hasMarkup('strong'), 'marker is strong');\n  });\n\n  test('span with font-weight \"bold\" maps to strong', function (assert) {\n    var element = buildDOM('<p><span style=\"font-weight:bold;\">bold bold</span></p>');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n\n    var section = post.sections.objectAt(0);\n    assert.equal(section.markers.length, 1, '1 marker');\n    var marker = section.markers.objectAt(0);\n\n    assert.equal(marker.value, 'bold bold');\n    assert.ok(marker.hasMarkup('strong'), 'marker is strong');\n  });\n\n  var recognizedTags = ['aside', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p'];\n  recognizedTags.forEach(function (tag) {\n    test('recognized markup section tags are parsed (' + tag + ')', function (assert) {\n      var element = buildDOM('<' + tag + '>' + tag + ' text</' + tag + '>');\n      var post = parser.parse(element);\n\n      assert.equal(post.sections.length, 1, '1 section');\n      assert.equal(post.sections.objectAt(0).text, tag + ' text');\n      assert.equal(post.sections.objectAt(0).tagName, tag);\n    });\n  });\n\n  test('unrecognized attributes are ignored', function (assert) {\n    var element = buildDOM('\\n    <a href=\"http://bustle.com\"\\n       style=\"text-decoration: none\">not-underlined link</a>');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n    assert.equal(post.sections.objectAt(0).text, 'not-underlined link');\n    var marker = post.sections.objectAt(0).markers.objectAt(0);\n    assert.equal(marker.value, 'not-underlined link');\n    assert.ok(marker.hasMarkup('a'), 'has <a> markup');\n    var markup = marker.getMarkup('a');\n    assert.equal(markup.getAttribute('href'), 'http://bustle.com');\n    assert.ok(!markup.getAttribute('style'), 'style attribute not included');\n  });\n\n  test('singly-nested ol lis are parsed correctly', function (assert) {\n    var element = buildDOM('\\n    <ol><li>first element</li><li>second element</li></ol>\\n  ');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n    var section = post.sections.objectAt(0);\n    assert.equal(section.tagName, 'ol');\n    assert.equal(section.items.length, 2, '2 items');\n    assert.equal(section.items.objectAt(0).text, 'first element');\n    assert.equal(section.items.objectAt(1).text, 'second element');\n  });\n\n  test('nested html doesn\\'t create unneccessary whitespace', function (assert) {\n    var element = buildDOM('\\n    <div>\\n      <p>\\n        One\\n      <p>\\n      <p>\\n        Two\\n      </p>\\n    </div>\\n  ');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 2, '2 sections');\n    assert.equal(post.sections.objectAt(0).text, 'One');\n    assert.equal(post.sections.objectAt(1).text, 'Two');\n  });\n\n  // Google docs nests uls like this\n  test('lis in nested uls are flattened (when ul is child of ul)', function (assert) {\n    var element = buildDOM('\\n    <ul>\\n      <li>outer</li>\\n      <ul><li>inner</li></ul>\\n    </ul>\\n  ');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n    var section = post.sections.objectAt(0);\n    assert.equal(section.tagName, 'ul');\n    assert.equal(section.items.length, 2, '2 items');\n    assert.equal(section.items.objectAt(0).text, 'outer');\n    assert.equal(section.items.objectAt(1).text, 'inner');\n  });\n\n  test('#appendSection does not skip sections containing a single atom with no text value', function (assert) {\n    var options = {\n      plugins: [function (node, builder, _ref4) {\n        var addMarkerable = _ref4.addMarkerable;\n        var nodeFinished = _ref4.nodeFinished;\n\n        if (node.nodeType !== 1 || node.tagName !== 'BR') {\n          return;\n        }\n\n        var softReturn = builder.createAtom('soft-return');\n        addMarkerable(softReturn);\n\n        nodeFinished();\n      }]\n    };\n    parser = new _mobiledocKitParsersDom['default'](builder, options);\n\n    var element = buildDOM('Testing<br>Atoms');\n    var post = parser.parse(element);\n\n    assert.equal(post.sections.length, 1, '1 section');\n    var section = post.sections.objectAt(0);\n    assert.equal(section.tagName, 'p');\n    assert.equal(section.markers.length, 3, '3 markers');\n    assert.equal(section.markers.objectAt(0).value, 'Testing');\n    assert.equal(section.markers.objectAt(1).name, 'soft-return');\n    assert.equal(section.markers.objectAt(2).value, 'Atoms');\n  });\n});","define('tests/unit/parsers/html-google-docs-test', ['exports', 'mobiledoc-kit/parsers/html', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers', '../../fixtures/google-docs', 'mobiledoc-kit/utils/array-utils', 'mobiledoc-kit/models/types'], function (exports, _mobiledocKitParsersHtml, _mobiledocKitModelsPostNodeBuilder, _testHelpers, _fixturesGoogleDocs, _mobiledocKitUtilsArrayUtils, _mobiledocKitModelsTypes) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  function parseHTML(html) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    return new _mobiledocKitParsersHtml['default'](builder, options).parse(html);\n  }\n\n  _module('Unit: Parser: HTMLParser Google Docs');\n\n  function equalToExpected(assert, rawHTML, expectedHTML) {\n    var raw = parseHTML(rawHTML),\n        expected = parseHTML(expectedHTML);\n\n    assert.equal(raw.sections.length, expected.sections.length, 'matches section length');\n    raw.sections.forEach(function (section, sectionIndex) {\n      var expectedSection = expected.sections.objectAt(sectionIndex);\n\n      if (section.type === _mobiledocKitModelsTypes.CARD_TYPE) {\n        assert.equal(section.name, expectedSection.name, 'card section at index ' + sectionIndex + ' has equal name');\n\n        assert.deepEqual(section.payload, expectedSection.payload, 'card section at index ' + sectionIndex + ' has equal payload');\n\n        return;\n      }\n\n      assert.equal(section.markers.length, expectedSection.markers.length, 'section at index ' + sectionIndex + ' has equal marker length');\n      assert.equal(section.text, expectedSection.text, 'section at index ' + sectionIndex + ' has equal text');\n      assert.equal(section.tagName, expectedSection.tagName, 'section at index ' + sectionIndex + ' has equal tagName');\n\n      section.markers.forEach(function (marker, markerIndex) {\n        var expectedMarker = expectedSection.markers.objectAt(markerIndex);\n\n        assert.equal(marker.value, expectedMarker.value, 'marker #' + markerIndex + ' at section #' + sectionIndex + ' matches value');\n\n        assert.equal(marker.markups.length, expectedMarker.markups.length, 'marker #' + markerIndex + ' at section #' + sectionIndex + ' matches markups length');\n\n        (0, _mobiledocKitUtilsArrayUtils.forEach)(expectedMarker.markups, function (expectedMarkup) {\n          var markup = marker.getMarkup(expectedMarkup.tagName);\n          assert.ok(markup, 'has markup with tagName ' + expectedMarkup.tagName);\n          var attributes = expectedMarkup.attributes;\n          (0, _mobiledocKitUtilsArrayUtils.forEach)(Object.keys(attributes), function (key) {\n            assert.equal(expectedMarkup.getAttribute(key), markup.getAttribute(key), 'equal attribute value for ' + key);\n          });\n        });\n      });\n    });\n  }\n\n  Object.keys(_fixturesGoogleDocs['default']).forEach(function (key) {\n    test(key, function (assert) {\n      var example = _fixturesGoogleDocs['default'][key];\n      equalToExpected(assert, example.raw, example.expected);\n    });\n  });\n\n  test('img in span can use a cardParser to turn img into image-card', function (assert) {\n    var example = _fixturesGoogleDocs['default']['img in span'];\n    var options = {\n      plugins: [function (element, builder, _ref) {\n        var addSection = _ref.addSection;\n\n        if (element.tagName === 'IMG') {\n          var _payload = { url: element.src };\n          var cardSection = builder.createCardSection('image-card', _payload);\n          addSection(cardSection);\n        }\n      }]\n    };\n    var parsed = parseHTML(example.raw, options);\n\n    var sections = parsed.sections.toArray();\n    var found = false,\n        payload = undefined;\n    for (var i = 0; i < sections.length; i++) {\n      if (sections[i].name === 'image-card') {\n        found = true;\n        payload = sections[i].payload;\n      }\n    }\n    assert.ok(found, 'found image-card');\n    assert.ok(payload.url, 'has url in payload');\n  });\n});","define('tests/unit/parsers/html-google-sheets-test', ['exports', 'mobiledoc-kit/parsers/html', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers'], function (exports, _mobiledocKitParsersHtml, _mobiledocKitModelsPostNodeBuilder, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var parser = undefined;\n\n  _module('Unit: Parser: HTMLParser Google Sheets', {\n    beforeEach: function beforeEach() {\n      var options = {};\n      var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      parser = new _mobiledocKitParsersHtml['default'](builder, options);\n    },\n    afterEach: function afterEach() {\n      parser = null;\n    }\n  });\n\n  // No formatting\n  test('#parse returns a markup section when given a cell without formatting', function (assert) {\n    var text = '<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"><style type=\"text/css\"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style=\"font-size:13px;font-family:Arial;\" data-sheets-value=\"[null,2,&quot;Ways of climbing over the wall&quot;]\" data-sheets-userformat=\"[null,null,513,[null,0],null,null,null,null,null,null,null,null,0]\">Ways of climbing over the wall</span>';\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('Ways of climbing over the wall')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  // No formatting (Chrome - Windows)\n  test('#parse returns a markup section when given a cell without formatting (Chrome - Windows)', function (assert) {\n    var text = '<html><body><!--StartFragment--><style type=\"text/css\"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style=\"font-size:13px;font-family:Arial;\" data-sheets-value=\"[null,2,&quot;Ways of climbing over the wall&quot;]\" data-sheets-userformat=\"[null,null,513,[null,0],null,null,null,null,null,null,null,null,0]\">Ways of climbing over the wall</span><!--EndFragment--></body></html>';\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      return post([markupSection('p', [marker('Ways of climbing over the wall')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  // Cell in bold\n  test('#parse returns a markup section with bold when given a cell in bold', function (assert) {\n    var text = '<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"><style type=\"text/css\"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style=\"font-size:13px;font-family:Arial;font-weight:bold;\" data-sheets-value=\"[null,2,&quot;Ways of climbing over the wall&quot;]\" data-sheets-userformat=\"[null,null,16897,[null,0],null,null,null,null,null,null,null,null,0,null,null,null,null,1]\">Ways of climbing over the wall</span>';\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n      var markup = _ref3.markup;\n\n      var b = markup('strong');\n      return post([markupSection('p', [marker('Ways of climbing over the wall', [b])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  // Cell in bold (Chrome - Windows)\n  test('#parse returns a markup section with bold when given a cell in bold (Chrome - Windows)', function (assert) {\n    var text = '<html><body><!--StartFragment--><style type=\"text/css\"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style=\"font-size:13px;font-family:Arial;font-weight:bold;\" data-sheets-value=\"[null,2,&quot;Ways of climbing over the wall&quot;]\" data-sheets-userformat=\"[null,null,16897,[null,0],null,null,null,null,null,null,null,null,0,null,null,null,null,1]\">Ways of climbing over the wall</span><!--EndFragment--></body></html>';\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n      var markup = _ref4.markup;\n\n      var b = markup('strong');\n      return post([markupSection('p', [marker('Ways of climbing over the wall', [b])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  // Two adjacent cells without formatting\n  test('#parse returns a single markup section when given two cells on top of each other without formatting', function (assert) {\n    var text = '<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"><meta name=\"generator\" content=\"Sheets\"><style type=\"text/css\"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><table cellspacing=\"0\" cellpadding=\"0\" dir=\"ltr\" border=\"1\" style=\"table-layout:fixed;font-size:13px;font-family:arial,sans,sans-serif;border-collapse:collapse;border:1px solid #ccc\"><colgroup><col width=\"361\"></colgroup><tbody><tr style=\"height:21px;\"><td style=\"padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;\" data-sheets-value=\"[null,2,&quot;Ostalgia&quot;]\">Ostalgia</td></tr><tr style=\"height:21px;\"><td style=\"padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;\" data-sheets-value=\"[null,2,&quot;Photo&quot;]\">Photo</td></tr></tbody></table>';\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n\n      return post([markupSection('p', [marker('OstalgiaPhoto')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  // Two adjacent cells without formatting (Chrome - Windows)\n  test('#parse returns a single markup section when given two cells on top of each other without formatting (Chrome - Windows)', function (assert) {\n    var text = '<html><body><!--StartFragment--><meta name=\"generator\" content=\"Sheets\"><style type=\"text/css\"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><table cellspacing=\"0\" cellpadding=\"0\" dir=\"ltr\" border=\"1\" style=\"table-layout:fixed;font-size:13px;font-family:arial,sans,sans-serif;border-collapse:collapse;border:1px solid #ccc\"><colgroup><col width=\"361\"></colgroup><tbody><tr style=\"height:21px;\"><td style=\"padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;\" data-sheets-value=\"[null,2,&quot;Ostalgia&quot;]\">Ostalgia</td></tr><tr style=\"height:21px;\"><td style=\"padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;\" data-sheets-value=\"[null,2,&quot;Photo&quot;]\">Photo</td></tr></tbody></table><!--EndFragment--></body></html>';\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n\n      return post([markupSection('p', [marker('OstalgiaPhoto')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n});","define('tests/unit/parsers/html-test', ['exports', 'mobiledoc-kit/parsers/html', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers'], function (exports, _mobiledocKitParsersHtml, _mobiledocKitModelsPostNodeBuilder, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  function parseHTML(html) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    return new _mobiledocKitParsersHtml['default'](builder, options).parse(html);\n  }\n\n  var didParseVideo = undefined;\n  function videoParserPlugin(node) {\n    if (node.tagName === 'VIDEO') {\n      didParseVideo = true;\n    }\n  }\n\n  _module('Unit: Parser: HTMLParser', {\n    beforeEach: function beforeEach() {\n      didParseVideo = false;\n    }\n  });\n\n  test('style tags are ignored', function (assert) {\n    // This is the html you get when copying a message from Slack's desktop app\n    var html = '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> <meta http-equiv=\"Content-Style-Type\" content=\"text/css\"> <title></title> <meta name=\"Generator\" content=\"Cocoa HTML Writer\"> <meta name=\"CocoaVersion\" content=\"1348.17\"> <style type=\"text/css\"> p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Times; color: #2c2d30; -webkit-text-stroke: #2c2d30; background-color: #f9f9f9} span.s1 {font-kerning: none} </style> </head> <body> <p class=\"p1\"><span class=\"s1\">cool</span></p> </body> </html>';\n    var post = parseHTML(html);\n\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('cool')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  // See https://github.com/bustle/mobiledoc-kit/issues/333\n  test('newlines (\"\\\\n\") are replaced with space characters', function (assert) {\n    var html = \"abc\\ndef\";\n    var post = parseHTML(html);\n\n    var _Helpers$postAbstract$buildFromText = _testHelpers['default'].postAbstract.buildFromText(['abc def']);\n\n    var expected = _Helpers$postAbstract$buildFromText.post;\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  // see https://github.com/bustlelabs/mobiledoc-kit/issues/494\n  test('top-level unknown void elements are parsed', function (assert) {\n    var html = '<video />';\n    var post = parseHTML(html, { plugins: [videoParserPlugin] });\n\n    var _Helpers$postAbstract$buildFromText2 = _testHelpers['default'].postAbstract.buildFromText([]);\n\n    var expected = _Helpers$postAbstract$buildFromText2.post;\n\n    assert.ok(didParseVideo);\n    assert.postIsSimilar(post, expected);\n  });\n\n  // see https://github.com/bustlelabs/mobiledoc-kit/issues/494\n  test('top-level unknown elements are parsed', function (assert) {\n    var html = '<video>...inner...</video>';\n    var post = parseHTML(html, { plugins: [videoParserPlugin] });\n\n    var _Helpers$postAbstract$buildFromText3 = _testHelpers['default'].postAbstract.buildFromText(['...inner...']);\n\n    var expected = _Helpers$postAbstract$buildFromText3.post;\n\n    assert.ok(didParseVideo);\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('nested void unknown elements are parsed', function (assert) {\n    var html = '<p>...<video />...</p>';\n    var post = parseHTML(html, { plugins: [videoParserPlugin] });\n\n    var _Helpers$postAbstract$buildFromText4 = _testHelpers['default'].postAbstract.buildFromText(['......']);\n\n    var expected = _Helpers$postAbstract$buildFromText4.post;\n\n    assert.ok(didParseVideo);\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('nested unknown elements are parsed', function (assert) {\n    var html = '<p>...<video>inner</video>...</p>';\n    var post = parseHTML(html, { plugins: [videoParserPlugin] });\n\n    var _Helpers$postAbstract$buildFromText5 = _testHelpers['default'].postAbstract.buildFromText(['...inner...']);\n\n    var expected = _Helpers$postAbstract$buildFromText5.post;\n\n    assert.ok(didParseVideo);\n    assert.postIsSimilar(post, expected);\n  });\n});","define('tests/unit/parsers/mobiledoc-test', ['exports', 'mobiledoc-kit/parsers/mobiledoc', 'mobiledoc-kit/renderers/mobiledoc/0-2', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers'], function (exports, _mobiledocKitParsersMobiledoc, _mobiledocKitRenderersMobiledoc02, _mobiledocKitModelsPostNodeBuilder, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined,\n      post = undefined;\n\n  function parse(mobiledoc) {\n    return _mobiledocKitParsersMobiledoc['default'].parse(builder, mobiledoc);\n  }\n\n  _module('Unit: Parsers: Mobiledoc', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      post = builder.createPost();\n    },\n    afterEach: function afterEach() {\n      builder = null;\n      post = null;\n    }\n  });\n\n  test('#parse empty doc returns an empty post', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], []]\n    };\n\n    var parsed = parse(mobiledoc);\n    assert.equal(parsed.sections.length, 0, '0 sections');\n  });\n\n  test('#parse basic mobiledoc from renderer works', function (assert) {\n    var mobiledoc = _testHelpers['default'].mobiledoc.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('Howdy')])]);\n    });\n\n    var parsed = parse(mobiledoc);\n    assert.equal(parsed.sections.length, 1, '1 section');\n  });\n});","define('tests/unit/parsers/mobiledoc/0-2-test', ['exports', 'mobiledoc-kit/parsers/mobiledoc/0-2', 'mobiledoc-kit/renderers/mobiledoc/0-2', 'mobiledoc-kit/models/post-node-builder', '../../../test-helpers'], function (exports, _mobiledocKitParsersMobiledoc02, _mobiledocKitRenderersMobiledoc02, _mobiledocKitModelsPostNodeBuilder, _testHelpers) {\n  'use strict';\n\n  var DATA_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=\";\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var parser = undefined,\n      builder = undefined,\n      post = undefined;\n\n  _module('Unit: Parsers: Mobiledoc 0.2', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      parser = new _mobiledocKitParsersMobiledoc02['default'](builder);\n      post = builder.createPost();\n    },\n    afterEach: function afterEach() {\n      parser = null;\n      builder = null;\n      post = null;\n    }\n  });\n\n  test('#parse empty doc returns an empty post', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], []]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n    assert.equal(parsed.sections.length, 0, '0 sections');\n  });\n\n  test('#parse empty markup section returns an empty post', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[1, 'p', []]]]\n    };\n\n    var section = builder.createMarkupSection('p');\n    post.sections.append(section);\n    assert.deepEqual(parser.parse(mobiledoc), post);\n  });\n\n  test('#parse doc without marker types', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[1, 'P', [[[], 0, 'hello world']]]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('P', [], false);\n    var marker = builder.createMarker('hello world');\n    section.markers.append(marker);\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with blank marker', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[1, 'P', [[[], 0, '']]]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('P', [], false);\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with marker type', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[['B'], ['A', ['href', 'google.com']]], [[1, 'P', [[[1], 0, 'hello'], // a tag open\n      [[0], 1, 'brave new'], // b tag open/close\n      [[], 1, 'world'] // a tag close\n      ]]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('P', [], false);\n    var aMarkerType = builder.createMarkup('A', { href: 'google.com' });\n    var bMarkerType = builder.createMarkup('B');\n\n    var markers = [builder.createMarker('hello', [aMarkerType]), builder.createMarker('brave new', [aMarkerType, bMarkerType]), builder.createMarker('world', [aMarkerType])];\n    markers.forEach(function (marker) {\n      return section.markers.append(marker);\n    });\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse pull-quote section to aside node', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[1, 'PULL-QUOTE', [[[], 0, 'quoted']]]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('ASIDE', [], false);\n    var markers = [builder.createMarker('quoted', [])];\n    markers.forEach(function (marker) {\n      return section.markers.append(marker);\n    });\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with image section', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[2, DATA_URL]]]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createImageSection(DATA_URL);\n    post.sections.append(section);\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with custom card type', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[10, 'custom-card', {}]]]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createCardSection('custom-card');\n    post.sections.append(section);\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse a mobile doc with list-section and list-item', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[3, 'ul', [[[[], 0, \"first item\"]], [[[], 0, \"second item\"]]]]]]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n\n    var items = [builder.createListItem([builder.createMarker('first item')]), builder.createListItem([builder.createMarker('second item')])];\n    var section = builder.createListSection('ul', items);\n    post.sections.append(section);\n    assert.deepEqual(parsed, post);\n  });\n});","define('tests/unit/parsers/mobiledoc/0-3-test', ['exports', 'mobiledoc-kit/parsers/mobiledoc/0-3', 'mobiledoc-kit/renderers/mobiledoc/0-3', 'mobiledoc-kit/models/post-node-builder', '../../../test-helpers'], function (exports, _mobiledocKitParsersMobiledoc03, _mobiledocKitRenderersMobiledoc03, _mobiledocKitModelsPostNodeBuilder, _testHelpers) {\n  'use strict';\n\n  var DATA_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=\";\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var parser = undefined,\n      builder = undefined,\n      post = undefined;\n\n  _module('Unit: Parsers: Mobiledoc 0.3', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      parser = new _mobiledocKitParsersMobiledoc03['default'](builder);\n      post = builder.createPost();\n    },\n    afterEach: function afterEach() {\n      parser = null;\n      builder = null;\n      post = null;\n    }\n  });\n\n  test('#parse empty doc returns an empty post', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: []\n    };\n\n    var parsed = parser.parse(mobiledoc);\n    assert.equal(parsed.sections.length, 0, '0 sections');\n  });\n\n  test('#parse empty markup section returns an empty post', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[1, 'p', []]]\n    };\n\n    var section = builder.createMarkupSection('p');\n    post.sections.append(section);\n    assert.deepEqual(parser.parse(mobiledoc), post);\n  });\n\n  test('#parse doc without marker types', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[1, 'P', [[0, [], 0, 'hello world']]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('P', [], false);\n    var marker = builder.createMarker('hello world');\n    section.markers.append(marker);\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with blank marker', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[1, 'P', [[0, [], 0, '']]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('P', [], false);\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with marker type', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [['B'], ['A', ['href', 'google.com']]],\n      sections: [[1, 'P', [[0, [1], 0, 'hello'], // a tag open\n      [0, [0], 1, 'brave new'], // b tag open/close\n      [0, [], 1, 'world'] // a tag close\n      ]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('P', [], false);\n    var aMarkerType = builder.createMarkup('A', { href: 'google.com' });\n    var bMarkerType = builder.createMarkup('B');\n\n    var markers = [builder.createMarker('hello', [aMarkerType]), builder.createMarker('brave new', [aMarkerType, bMarkerType]), builder.createMarker('world', [aMarkerType])];\n    markers.forEach(function (marker) {\n      return section.markers.append(marker);\n    });\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse pull-quote section to aside node', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[1, 'PULL-QUOTE', [[0, [], 0, 'quoted']]]]\n    };\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('ASIDE', [], false);\n    var markers = [builder.createMarker('quoted', [])];\n    markers.forEach(function (marker) {\n      return section.markers.append(marker);\n    });\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with image section', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[2, DATA_URL]]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createImageSection(DATA_URL);\n    post.sections.append(section);\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with custom card type', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [['custom-card', {}]],\n      markups: [],\n      sections: [[10, 0]]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createCardSection('custom-card');\n    post.sections.append(section);\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse doc with custom atom type', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [['mention', '@bob', { id: 42 }]],\n      cards: [],\n      markups: [],\n      sections: [[1, 'P', [[1, [], 0, 0]]]]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n\n    var section = builder.createMarkupSection('P', [], false);\n    var atom = builder.createAtom('mention', '@bob', { id: 42 });\n    section.markers.append(atom);\n    post.sections.append(section);\n\n    assert.deepEqual(parsed, post);\n  });\n\n  test('#parse a mobile doc with list-section and list-item', function (assert) {\n    var mobiledoc = {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[3, 'ul', [[[0, [], 0, \"first item\"]], [[0, [], 0, \"second item\"]]]]]\n    };\n\n    var parsed = parser.parse(mobiledoc);\n\n    var items = [builder.createListItem([builder.createMarker('first item')]), builder.createListItem([builder.createMarker('second item')])];\n    var section = builder.createListSection('ul', items);\n    post.sections.append(section);\n    assert.deepEqual(parsed, post);\n  });\n});","define('tests/unit/parsers/section-test', ['exports', 'mobiledoc-kit/models/post-node-builder', 'mobiledoc-kit/parsers/section', '../../test-helpers', 'mobiledoc-kit/utils/dom-utils'], function (exports, _mobiledocKitModelsPostNodeBuilder, _mobiledocKitParsersSection, _testHelpers, _mobiledocKitUtilsDomUtils) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined,\n      parser = undefined;\n  var buildDOM = _testHelpers['default'].dom.fromHTML;\n\n  _module('Unit: Parser: SectionParser', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      parser = new _mobiledocKitParsersSection['default'](builder);\n    },\n    afterEach: function afterEach() {\n      builder = null;\n      parser = null;\n    }\n  });\n\n  test('#parse parses simple dom', function (assert) {\n    var container = buildDOM('<p>hello there<b>i am bold</b><p>');\n    var element = container.firstChild;\n\n    var _parser$parse = parser.parse(element);\n\n    var _parser$parse2 = _slicedToArray(_parser$parse, 1);\n\n    var section = _parser$parse2[0];\n\n    assert.equal(section.tagName, 'p');\n    assert.equal(section.markers.length, 2, 'has 2 markers');\n\n    var _section$markers$toArray = section.markers.toArray();\n\n    var _section$markers$toArray2 = _slicedToArray(_section$markers$toArray, 2);\n\n    var m1 = _section$markers$toArray2[0];\n    var m2 = _section$markers$toArray2[1];\n\n    assert.equal(m1.value, 'hello there');\n    assert.equal(m2.value, 'i am bold');\n    assert.ok(m2.hasMarkup('b'), 'm2 is bold');\n  });\n\n  test('#parse parses nested markups', function (assert) {\n    var container = buildDOM('\\n    <p><b>i am bold<i>i am bold and italic</i>i am bold again</b></p>\\n  ');\n    var element = container.firstChild;\n\n    var _parser$parse3 = parser.parse(element);\n\n    var _parser$parse32 = _slicedToArray(_parser$parse3, 1);\n\n    var section = _parser$parse32[0];\n\n    assert.equal(section.markers.length, 3, 'has 3 markers');\n\n    var _section$markers$toArray3 = section.markers.toArray();\n\n    var _section$markers$toArray32 = _slicedToArray(_section$markers$toArray3, 3);\n\n    var m1 = _section$markers$toArray32[0];\n    var m2 = _section$markers$toArray32[1];\n    var m3 = _section$markers$toArray32[2];\n\n    assert.equal(m1.value, 'i am bold');\n    assert.equal(m2.value, 'i am bold and italic');\n    assert.equal(m3.value, 'i am bold again');\n    assert.ok(m1.hasMarkup('b'), 'm1 is bold');\n    assert.ok(m2.hasMarkup('b') && m2.hasMarkup('i'), 'm2 is bold and i');\n    assert.ok(m3.hasMarkup('b'), 'm3 is bold');\n    assert.ok(!m1.hasMarkup('i') && !m3.hasMarkup('i'), 'm1 and m3 are not i');\n  });\n\n  test('#parse ignores non-markup elements like spans', function (assert) {\n    var container = buildDOM('\\n    <p><span>i was in span</span></p>\\n  ');\n    var element = container.firstChild;\n\n    var _parser$parse4 = parser.parse(element);\n\n    var _parser$parse42 = _slicedToArray(_parser$parse4, 1);\n\n    var section = _parser$parse42[0];\n\n    assert.equal(section.tagName, 'p');\n    assert.equal(section.markers.length, 1, 'has 1 markers');\n\n    var _section$markers$toArray4 = section.markers.toArray();\n\n    var _section$markers$toArray42 = _slicedToArray(_section$markers$toArray4, 1);\n\n    var m1 = _section$markers$toArray42[0];\n\n    assert.equal(m1.value, 'i was in span');\n  });\n\n  test('#parse reads attributes', function (assert) {\n    var container = buildDOM('\\n    <p><a href=\"google.com\">i am a link</a></p>\\n  ');\n    var element = container.firstChild;\n\n    var _parser$parse5 = parser.parse(element);\n\n    var _parser$parse52 = _slicedToArray(_parser$parse5, 1);\n\n    var section = _parser$parse52[0];\n\n    assert.equal(section.markers.length, 1, 'has 1 markers');\n\n    var _section$markers$toArray5 = section.markers.toArray();\n\n    var _section$markers$toArray52 = _slicedToArray(_section$markers$toArray5, 1);\n\n    var m1 = _section$markers$toArray52[0];\n\n    assert.equal(m1.value, 'i am a link');\n    assert.ok(m1.hasMarkup('a'), 'has \"a\" markup');\n    assert.equal(m1.getMarkup('a').attributes.href, 'google.com');\n  });\n\n  test('#parse joins contiguous text nodes separated by non-markup elements', function (assert) {\n    var container = buildDOM('\\n    <p><span>span 1</span><span>span 2</span></p>\\n  ');\n    var element = container.firstChild;\n\n    var _parser$parse6 = parser.parse(element);\n\n    var _parser$parse62 = _slicedToArray(_parser$parse6, 1);\n\n    var section = _parser$parse62[0];\n\n    assert.equal(section.tagName, 'p');\n    assert.equal(section.markers.length, 1, 'has 1 marker');\n\n    var _section$markers$toArray6 = section.markers.toArray();\n\n    var _section$markers$toArray62 = _slicedToArray(_section$markers$toArray6, 1);\n\n    var m1 = _section$markers$toArray62[0];\n\n    assert.equal(m1.value, 'span 1span 2');\n  });\n\n  test('#parse turns a textNode into a section', function (assert) {\n    var container = buildDOM('I am a text node');\n    var element = container.firstChild;\n\n    var _parser$parse7 = parser.parse(element);\n\n    var _parser$parse72 = _slicedToArray(_parser$parse7, 1);\n\n    var section = _parser$parse72[0];\n\n    assert.equal(section.tagName, 'p');\n    assert.equal(section.markers.length, 1, 'has 1 marker');\n\n    var _section$markers$toArray7 = section.markers.toArray();\n\n    var _section$markers$toArray72 = _slicedToArray(_section$markers$toArray7, 1);\n\n    var m1 = _section$markers$toArray72[0];\n\n    assert.equal(m1.value, 'I am a text node');\n  });\n\n  test('#parse allows passing in parserPlugins that can override element parsing', function (assert) {\n    var container = buildDOM('\\n    <p>text 1<img src=\"https://placehold.it/100x100\">text 2</p>\\n  ');\n\n    var element = container.firstChild;\n    var plugins = [function (element, builder, _ref) {\n      var addSection = _ref.addSection;\n\n      if (element.tagName !== 'IMG') {\n        return;\n      }\n      var payload = { url: element.src };\n      var cardSection = builder.createCardSection('test-image', payload);\n      addSection(cardSection);\n    }];\n    parser = new _mobiledocKitParsersSection['default'](builder, { plugins: plugins });\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 3, '3 sections');\n\n    assert.equal(sections[0].text, 'text 1');\n    assert.equal(sections[2].text, 'text 2');\n\n    var cardSection = sections[1];\n    assert.equal(cardSection.name, 'test-image');\n    assert.deepEqual(cardSection.payload, { url: 'https://placehold.it/100x100' });\n  });\n\n  test('#parse allows passing in parserPlugins that can override text parsing', function (assert) {\n    var container = buildDOM('\\n    <p>text 1<img src=\"https://placehold.it/100x100\">text 2</p>\\n  ');\n\n    var element = container.firstChild;\n    var plugins = [function (element, builder, _ref2) {\n      var addMarkerable = _ref2.addMarkerable;\n      var nodeFinished = _ref2.nodeFinished;\n\n      if (element.nodeType === _mobiledocKitUtilsDomUtils.NODE_TYPES.TEXT) {\n        if (element.textContent === 'text 1') {\n          addMarkerable(builder.createMarker('oh my'));\n        }\n        nodeFinished();\n      }\n    }];\n    parser = new _mobiledocKitParsersSection['default'](builder, { plugins: plugins });\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1, '1 section');\n    assert.equal(sections[0].text, 'oh my');\n  });\n\n  test('#parse only runs text nodes through parserPlugins once', function (assert) {\n    var container = buildDOM('text');\n    var textNode = container.firstChild;\n\n    assert.equal(textNode.nodeType, _mobiledocKitUtilsDomUtils.NODE_TYPES.TEXT);\n\n    var pluginRunCount = 0;\n    var plugins = [function (element) {\n      if (element.nodeType === _mobiledocKitUtilsDomUtils.NODE_TYPES.TEXT && element.textContent === 'text') {\n        pluginRunCount++;\n      }\n    }];\n    parser = new _mobiledocKitParsersSection['default'](builder, { plugins: plugins });\n    parser.parse(textNode);\n\n    assert.equal(pluginRunCount, 1);\n  });\n\n  test('#parse ignores blank markup sections', function (assert) {\n    var container = buildDOM('\\n    <div><p>One</p><p></p><p>Three</p></div>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 2, 'Two sections');\n    assert.equal(sections[0].text, 'One');\n    assert.equal(sections[1].text, 'Three');\n  });\n\n  test('#parse handles section-level elements in list item', function (assert) {\n    var container = buildDOM('\\n    <ol><li>One</li><li><h4>Two</h4><p>Two - P</p></li><li>Three</li></ol>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 4, '4 sections');\n\n    assert.equal(sections[0].type, 'list-section', 'first section type');\n    assert.equal(sections[0].tagName, 'ol', 'first section tagName');\n    assert.equal(sections[0].items.length, 1, '1 list item in first list section');\n    assert.equal(sections[0].items.objectAt(0).text, 'One');\n\n    assert.equal(sections[1].type, 'markup-section', 'second section type');\n    assert.equal(sections[1].tagName, 'h4');\n    assert.equal(sections[1].text, 'Two');\n\n    assert.equal(sections[2].type, 'markup-section', 'third section type');\n    assert.equal(sections[2].tagName, 'p');\n    assert.equal(sections[2].text, 'Two - P');\n\n    assert.equal(sections[3].type, 'list-section', 'fourth section type');\n    assert.equal(sections[3].tagName, 'ol', 'fourth section tagName');\n    assert.equal(sections[3].items.length, 1, '1 list item in last list section');\n    assert.equal(sections[3].items.objectAt(0).text, 'Three');\n  });\n\n  test(\"#parse handles single paragraph in list item\", function (assert) {\n    var container = buildDOM('\\n    <ul><li><p>One</p></li>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1, \"single list section\");\n\n    var list = sections[0];\n    assert.equal(list.type, \"list-section\");\n    assert.equal(list.items.length, 1, \"1 list item\");\n    assert.equal(list.items.objectAt(0).text, \"One\");\n  });\n\n  test(\"#parse handles multiple paragraphs in list item\", function (assert) {\n    var container = buildDOM('\\n    <ul><li><p>One</p><p>Two</p></li>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 2, '2 sections');\n\n    var p1 = sections[0];\n    assert.equal(p1.type, 'markup-section', 'first section type');\n    assert.equal(p1.text, 'One');\n    var p2 = sections[1];\n    assert.equal(p2.type, \"markup-section\", \"second section type\");\n    assert.equal(p2.text, \"Two\");\n  });\n\n  test(\"#parse handles multiple headers in list item\", function (assert) {\n    var container = buildDOM('\\n    <ul><li><h1>One</h1><h2>Two</h2></li>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 2, '2 sections');\n\n    var h1 = sections[0];\n    assert.equal(h1.type, 'markup-section', 'first section type');\n    assert.equal(h1.text, 'One');\n    assert.equal(h1.tagName, 'h1');\n    var h2 = sections[1];\n    assert.equal(h2.type, 'markup-section', 'second section type');\n    assert.equal(h2.text, 'Two');\n    assert.equal(h2.tagName, 'h2');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/656\n  test('#parse handles list following node handled by parserPlugin', function (assert) {\n    var container = buildDOM('\\n    <div><img src=\"https://placehold.it/100x100\"><ul><li>LI One</li></ul></div>\\n  ');\n\n    var element = container.firstChild;\n    var plugins = [function (element, builder, _ref3) {\n      var addSection = _ref3.addSection;\n      var nodeFinished = _ref3.nodeFinished;\n\n      if (element.tagName !== 'IMG') {\n        return;\n      }\n      var payload = { url: element.src };\n      var cardSection = builder.createCardSection('test-image', payload);\n      addSection(cardSection);\n      nodeFinished();\n    }];\n\n    parser = new _mobiledocKitParsersSection['default'](builder, { plugins: plugins });\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 2, '2 sections');\n\n    var cardSection = sections[0];\n    assert.equal(cardSection.name, 'test-image');\n    assert.deepEqual(cardSection.payload, { url: 'https://placehold.it/100x100' });\n\n    var listSection = sections[1];\n    assert.equal(listSection.type, 'list-section');\n    assert.equal(listSection.items.length, 1, '1 list item');\n  });\n\n  test('#parse handles insignificant whitespace', function (assert) {\n    var container = buildDOM('\\n    <ul>\\n      <li>\\n        One\\n      </li>\\n    </ul>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1, '1 section');\n\n    var _sections = _slicedToArray(sections, 1);\n\n    var list = _sections[0];\n\n    assert.equal(list.type, 'list-section');\n    assert.equal(list.items.length, 1, '1 list item');\n    assert.equal(list.items.objectAt(0).text, 'One');\n  });\n\n  test('#parse handles insignificant whitespace (wrapped)', function (assert) {\n    var container = buildDOM('\\n    <div>\\n      <ul>\\n        <li>\\n          One\\n        </li>\\n      </ul>\\n    </div>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1, '1 section');\n\n    var _sections2 = _slicedToArray(sections, 1);\n\n    var list = _sections2[0];\n\n    assert.equal(list.type, 'list-section');\n    assert.equal(list.items.length, 1, '1 list item');\n    assert.equal(list.items.objectAt(0).text, 'One');\n  });\n\n  test('#parse avoids empty paragraph around wrapped list', function (assert) {\n    var container = buildDOM('\\n    <div><ul><li>One</li></ul></div>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1, 'single list section');\n  });\n\n  test('#parse handles nested lists of different types', function (assert) {\n    var container = buildDOM('\\n    <ol><li>One</li><li><ul><li>A</li><li>B</li></ul><li>Two</li></ol>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 3, '3 sections');\n\n    assert.equal(sections[0].type, 'list-section', 'first section type');\n    assert.equal(sections[0].tagName, 'ol', 'first section tagName');\n    assert.equal(sections[0].items.length, 1, '1 list item in first list section');\n    assert.equal(sections[0].items.objectAt(0).text, 'One');\n\n    assert.equal(sections[1].type, 'list-section', 'second section type');\n    assert.equal(sections[1].tagName, 'ul', 'fourth section tagName');\n    assert.equal(sections[1].items.length, 2, '2 list items in second list section');\n    assert.equal(sections[1].items.objectAt(0).text, 'A');\n    assert.equal(sections[1].items.objectAt(1).text, 'B');\n\n    assert.equal(sections[2].type, 'list-section', 'third section type');\n    assert.equal(sections[2].tagName, 'ol', 'third section tagName');\n    assert.equal(sections[2].items.length, 1, '1 list item in third list section');\n    assert.equal(sections[2].items.objectAt(0).text, 'Two');\n  });\n\n  test('#parse handles grouping nested lists', function (assert) {\n    var container = buildDOM('\\n    <div><ul><li>Outer-One<ul><li>Inner-Two</li><li>Inner-Three</li></ul></li><li>Outer-Four</li></ul></div>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1, 'single list section');\n\n    var list = sections[0];\n    assert.equal(list.type, 'list-section');\n    assert.equal(list.items.length, 4, '4 list items');\n    assert.equal(list.items.objectAt(0).text, 'Outer-One');\n    assert.equal(list.items.objectAt(1).text, 'Inner-Two');\n    assert.equal(list.items.objectAt(2).text, 'Inner-Three');\n    assert.equal(list.items.objectAt(3).text, 'Outer-Four');\n  });\n\n  test('#parse handles grouping of consecutive lists of same type', function (assert) {\n    var container = buildDOM('\\n    <div><ul><li>One</li></ul><ul><li>Two</li></ul>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1, 'single list section');\n    var list = sections[0];\n    assert.equal(list.items.objectAt(0).text, 'One');\n    assert.equal(list.items.objectAt(1).text, 'Two');\n  });\n\n  test('#parse doesn\\'t group consecutive lists of different types', function (assert) {\n    var container = buildDOM('\\n    <div><ul><li>One</li></ul><ol><li>Two</li></ol>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 2, 'two list sections');\n    var ul = sections[0];\n    assert.equal(ul.items.objectAt(0).text, 'One');\n    var ol = sections[1];\n    assert.equal(ol.items.objectAt(0).text, 'Two');\n  });\n\n  test('#parse handles p following list', function (assert) {\n    var container = buildDOM('\\n    <div><ol><li>li1</li><li>li2</li><p>para</p></div>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 2, 'two sections');\n\n    var ol = sections[0];\n    assert.equal(ol.items.length, 2, 'two list items');\n\n    var p = sections[1];\n    assert.equal(p.text, 'para');\n  });\n\n  test('#parse handles link in a heading followed by paragraph', function (assert) {\n    var container = buildDOM('\\n    <div><h4><a href=\"https://example.com\">Linked header</a></h4><p>test</p></div>\\n  ');\n\n    var element = container.firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 2, '2 sections');\n    assert.equal(sections[0].text, 'Linked header');\n\n    var markers = sections[0].markers.toArray();\n    assert.equal(markers.length, 1, '1 marker');\n\n    var _markers = _slicedToArray(markers, 1);\n\n    var marker = _markers[0];\n\n    assert.equal(marker.value, 'Linked header');\n    assert.ok(marker.hasMarkup('a'), 'has A markup');\n\n    var markup = marker.markups[0];\n    assert.equal(markup.getAttribute('href'), 'https://example.com');\n  });\n\n  test('#parse skips STYLE nodes', function (assert) {\n    var element = buildDOM('\\n    <style>.rule { font-color: red; }</style>\\n  ').firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 0, 'does not parse style');\n  });\n\n  test('#parse skips top-level Comment nodes', function (assert) {\n    var element = buildDOM('\\n    <!--Some comment-->\\n  ').firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 0, 'does not parse comments');\n  });\n\n  test('#parse skips nested Comment nodes', function (assert) {\n    var element = buildDOM('\\n   <p><!--Some comment-->some text<!-- another comment --></p>\\n  ').firstChild;\n    parser = new _mobiledocKitParsersSection['default'](builder);\n    var sections = parser.parse(element);\n\n    assert.equal(sections.length, 1);\n    var section = sections[0];\n    assert.equal(section.text, 'some text', 'parses text surrounded by comments');\n    assert.equal(section.markers.length, 1, 'only 1 marker');\n  });\n});","define('tests/unit/parsers/text-test', ['exports', 'mobiledoc-kit/parsers/text', 'mobiledoc-kit/models/post-node-builder', '../../test-helpers'], function (exports, _mobiledocKitParsersText, _mobiledocKitModelsPostNodeBuilder, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var parser = undefined;\n\n  _module('Unit: Parser: TextParser', {\n    beforeEach: function beforeEach() {\n      var builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      parser = new _mobiledocKitParsersText['default'](builder);\n    },\n    afterEach: function afterEach() {\n      parser = null;\n    }\n  });\n\n  test('#parse returns a markup section when given single line of text', function (assert) {\n    var text = 'some text';\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('some text')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse returns multiple markup sections when given multiple lines', function (assert) {\n    var text = ['first', 'second', 'third'].join(_mobiledocKitParsersText.SECTION_BREAK);\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      return post([markupSection('p', [marker('first')]), markupSection('p', [marker('second')]), markupSection('p', [marker('third')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse returns multiple sections when lines are separated by CR+LF', function (assert) {\n    var text = ['first', 'second', 'third'].join('\\r\\n');\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      return post([markupSection('p', [marker('first')]), markupSection('p', [marker('second')]), markupSection('p', [marker('third')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse returns multiple sections when lines are separated by CR', function (assert) {\n    var text = ['first', 'second', 'third'].join('\\r');\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      return post([markupSection('p', [marker('first')]), markupSection('p', [marker('second')]), markupSection('p', [marker('third')])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse returns list section when text starts with \"*\"', function (assert) {\n    var text = '* a list item';\n\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref5) {\n      var post = _ref5.post;\n      var listSection = _ref5.listSection;\n      var listItem = _ref5.listItem;\n      var marker = _ref5.marker;\n\n      return post([listSection('ul', [listItem([marker('a list item')])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse returns list section with multiple items when text starts with \"*\"', function (assert) {\n    var text = ['* first', '* second'].join(_mobiledocKitParsersText.SECTION_BREAK);\n\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var post = _ref6.post;\n      var listSection = _ref6.listSection;\n      var listItem = _ref6.listItem;\n      var marker = _ref6.marker;\n\n      return post([listSection('ul', [listItem([marker('first')]), listItem([marker('second')])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse returns list sections separated by markup sections', function (assert) {\n    var text = ['* first list', 'middle section', '* second list'].join(_mobiledocKitParsersText.SECTION_BREAK);\n\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref7) {\n      var post = _ref7.post;\n      var listSection = _ref7.listSection;\n      var listItem = _ref7.listItem;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      return post([listSection('ul', [listItem([marker('first list')])]), markupSection('p', [marker('middle section')]), listSection('ul', [listItem([marker('second list')])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse returns ordered list items', function (assert) {\n    var text = '1. first list';\n\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref8) {\n      var post = _ref8.post;\n      var listSection = _ref8.listSection;\n      var listItem = _ref8.listItem;\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n\n      return post([listSection('ol', [listItem([marker('first list')])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n\n  test('#parse can have ordered and unordered lists together', function (assert) {\n    var text = ['1. ordered list', '* unordered list'].join(_mobiledocKitParsersText.SECTION_BREAK);\n\n    var post = parser.parse(text);\n    var expected = _testHelpers['default'].postAbstract.build(function (_ref9) {\n      var post = _ref9.post;\n      var listSection = _ref9.listSection;\n      var listItem = _ref9.listItem;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      return post([listSection('ol', [listItem([marker('ordered list')])]), listSection('ul', [listItem([marker('unordered list')])])]);\n    });\n\n    assert.postIsSimilar(post, expected);\n  });\n});","define('tests/unit/renderers/editor-dom-test', ['exports', 'mobiledoc-kit/models/post-node-builder', 'mobiledoc-kit/renderers/editor-dom', 'mobiledoc-kit/models/render-tree', '../../test-helpers', 'mobiledoc-kit/utils/characters', 'mobiledoc-kit/utils/placeholder-image-src'], function (exports, _mobiledocKitModelsPostNodeBuilder, _mobiledocKitRenderersEditorDom, _mobiledocKitModelsRenderTree, _testHelpers, _mobiledocKitUtilsCharacters, _mobiledocKitUtilsPlaceholderImageSrc) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var builder = undefined;\n\n  var renderer = undefined;\n  function render(renderTree) {\n    var cards = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n    var atoms = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n    var editor = {};\n    renderer = new _mobiledocKitRenderersEditorDom['default'](editor, cards, atoms);\n    return renderer.render(renderTree);\n  }\n\n  var editor = undefined,\n      editorElement = undefined;\n  _module('Unit: Renderer: Editor-Dom', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (renderer) {\n        renderer.destroy();\n        renderer = null;\n      }\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test(\"renders a dirty post\", function (assert) {\n    /*\n     * renderTree is:\n     *\n     * renderNode\n     *\n     */\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](builder.createPost());\n    render(renderTree);\n\n    assert.ok(renderTree.rootElement, 'renderTree renders element for post');\n    assert.ok(!renderTree.rootNode.isDirty, 'dirty node becomes clean');\n    assert.equal(renderTree.rootElement.tagName, 'DIV', 'renderTree renders element for post');\n  });\n\n  test(\"renders a dirty post with un-rendered sections\", function (assert) {\n    var post = builder.createPost();\n    var sectionA = builder.createMarkupSection('P');\n    post.sections.append(sectionA);\n    var sectionB = builder.createMarkupSection('P');\n    post.sections.append(sectionB);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><br></p><p><br></p>', 'correct HTML is rendered');\n\n    assert.ok(renderTree.rootNode.childNodes.head, 'sectionA creates a first child');\n    assert.equal(renderTree.rootNode.childNodes.head.postNode, sectionA, 'sectionA is first renderNode child');\n    assert.ok(!renderTree.rootNode.childNodes.head.isDirty, 'sectionA node is clean');\n    assert.equal(renderTree.rootNode.childNodes.tail.postNode, sectionB, 'sectionB is second renderNode child');\n    assert.ok(!renderTree.rootNode.childNodes.tail.isDirty, 'sectionB node is clean');\n  });\n\n  [{\n    name: 'markup',\n    section: function section(builder) {\n      return builder.createMarkupSection('P');\n    }\n  }, {\n    name: 'image',\n    section: function section(builder) {\n      return builder.createImageSection(_mobiledocKitUtilsPlaceholderImageSrc['default']);\n    }\n  }, {\n    name: 'card',\n    section: function section(builder) {\n      return builder.createCardSection('new-card');\n    }\n  }, {\n    name: 'list-section',\n    section: function section(builder) {\n      return builder.createListSection('ul', [builder.createListItem([builder.createMarker('item')])]);\n    }\n  }].forEach(function (testInfo) {\n    test('removes nodes with ' + testInfo.name + ' section', function (assert) {\n      var post = builder.createPost();\n      var section = testInfo.section(builder);\n      post.sections.append(section);\n\n      var postElement = document.createElement('div');\n      var sectionElement = document.createElement('p');\n      postElement.appendChild(sectionElement);\n\n      var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n      var postRenderNode = renderTree.rootNode;\n      postRenderNode.element = postElement;\n\n      var sectionRenderNode = renderTree.buildRenderNode(section);\n      sectionRenderNode.element = sectionElement;\n      sectionRenderNode.scheduleForRemoval();\n      postRenderNode.childNodes.append(sectionRenderNode);\n\n      render(renderTree);\n\n      assert.equal(renderTree.rootElement, postElement, 'post element remains');\n\n      assert.equal(renderTree.rootElement.firstChild, null, 'section element removed');\n\n      assert.equal(renderTree.rootNode.childNodes.length, 0, 'section renderNode is removed');\n    });\n  });\n\n  test('renders a post with marker', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('P');\n    post.sections.append(section);\n    section.markers.append(builder.createMarker('Hi', [builder.createMarkup('STRONG')]));\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><strong>Hi</strong></p>');\n  });\n\n  test('renders a post with marker with a tab', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('a' + _mobiledocKitUtilsCharacters.TAB + 'b')])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n    assert.equal(renderTree.rootElement.innerHTML, '<p>a b</p>', 'HTML for a tab character is correct');\n  });\n\n  test('renders a post with markup empty section', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('P');\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><br></p>');\n  });\n\n  test('renders a post with multiple markers', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('P');\n    post.sections.append(section);\n\n    var b = builder.createMarkup('B');\n    var i = builder.createMarkup('I');\n\n    section.markers.append(builder.createMarker('hello '));\n    section.markers.append(builder.createMarker('bold, ', [b]));\n    section.markers.append(builder.createMarker('italic,', [b, i]));\n    section.markers.append(builder.createMarker(' world.'));\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n    assert.equal(renderTree.rootElement.innerHTML, '<p>hello <b>bold, <i>italic,</i></b> world.</p>');\n  });\n\n  test('renders a post with marker with link markup', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('P');\n    post.sections.append(section);\n\n    var href = 'http://google.com';\n    var rel = 'nofollow';\n    var linkMarkup = builder.createMarkup('A', { href: href, rel: rel });\n\n    section.markers.append(builder.createMarker('hello', [linkMarkup]));\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n    var html = renderTree.rootElement.innerHTML;\n\n    assert.ok(html.match(/<p><a .*>hello<\\/a><\\/p>/), 'a tag present');\n    assert.ok(html.match(new RegExp('href=\"' + href + '\"')), 'href present');\n    assert.ok(html.match(new RegExp('rel=\"' + rel + '\"')), 'rel present');\n  });\n\n  test('renders a post with image', function (assert) {\n    var url = _mobiledocKitUtilsPlaceholderImageSrc['default'];\n    var post = builder.createPost();\n    var section = builder.createImageSection(url);\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n    assert.equal(renderTree.rootElement.innerHTML, '<img src=\"' + url + '\">');\n  });\n\n  test('renders a post with atom', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var markupSection = _ref2.markupSection;\n      var post = _ref2.post;\n      var atom = _ref2.atom;\n\n      return post([markupSection('p', [atom('mention', '@bob', {})])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree, [], [{\n      name: 'mention',\n      type: 'dom',\n      render: function render(_ref3) /*, options, env, payload*/{\n        var value = _ref3.value;\n\n        return document.createTextNode(value);\n      }\n    }]);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">@bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></p>');\n  });\n\n  test('rerenders an atom with markup correctly when adjacent nodes change', function (assert) {\n    var bold = undefined,\n        italic = undefined,\n        marker1 = undefined,\n        marker2 = undefined,\n        atom1 = undefined,\n        markupSection1 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var markupSection = _ref4.markupSection;\n      var post = _ref4.post;\n      var atom = _ref4.atom;\n      var marker = _ref4.marker;\n      var markup = _ref4.markup;\n\n      bold = markup('b');\n      italic = markup('em');\n      marker1 = marker('abc');\n      atom1 = atom('mention', 'bob', {}, [bold]);\n      marker2 = marker('def');\n      markupSection1 = markupSection('p', [marker1, atom1, marker2]);\n      return post([markupSection1]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    var cards = [],\n        atoms = [{\n      name: 'mention',\n      type: 'dom',\n      render: function render(_ref5) /*, options, env, payload*/{\n        var value = _ref5.value;\n\n        return document.createTextNode(value);\n      }\n    }];\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p>abc<b><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></b>def</p>', 'initial render correct');\n\n    marker1.value = 'ABC';\n    marker1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree, cards, atoms);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p>ABC<b><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></b>def</p>', 'rerender is correct');\n\n    atom1.removeMarkup(bold);\n    atom1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p>ABC<span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span>def</p>', 'rerender is correct');\n\n    marker2.renderNode.scheduleForRemoval();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p>ABC<span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></p>', 'rerender is correct');\n\n    marker1.addMarkup(bold);\n    marker1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b>ABC</b><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></p>', 'rerender is correct');\n\n    marker1.renderNode.scheduleForRemoval();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></p>', 'rerender is correct');\n\n    atom1.renderNode.scheduleForRemoval();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><br></p>', 'rerender is correct');\n\n    var newAtom = builder.createAtom('mention', 'bob2', {}, [bold, italic]);\n    markupSection1.markers.append(newAtom);\n    markupSection1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b><em><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob2</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></em></b></p>', 'rerender is correct');\n\n    var newMarker = builder.createMarker('pre', [bold, italic]);\n    markupSection1.markers.insertBefore(newMarker, newAtom);\n    markupSection1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b><em>pre<span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob2</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></em></b></p>', 'rerender is correct');\n\n    newMarker = builder.createMarker('post', [bold, italic]);\n    markupSection1.markers.append(newMarker);\n    markupSection1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b><em>pre<span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob2</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span>post</em></b></p>', 'rerender is correct');\n\n    newAtom.removeMarkup(bold);\n    newAtom.renderNode.markDirty();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b><em>pre</em></b><em><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">bob2</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></em><b><em>post</em></b></p>', 'rerender is correct');\n\n    newAtom.renderNode.scheduleForRemoval();\n\n    // rerender\n    render(renderTree, cards, atoms);\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b><em>prepost</em></b></p>', 'rerender is correct');\n  });\n\n  test('renders a post with atom with markup', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var markupSection = _ref6.markupSection;\n      var post = _ref6.post;\n      var atom = _ref6.atom;\n      var marker = _ref6.marker;\n      var markup = _ref6.markup;\n\n      var b = markup('B');\n      var i = markup('I');\n\n      return post([markupSection('p', [atom('mention', '@bob', {}, [b, i])])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree, [], [{\n      name: 'mention',\n      type: 'dom',\n      render: function render(_ref7) /*, options, env, payload*/{\n        var fragment = _ref7.fragment;\n        var value = _ref7.value;\n\n        return document.createTextNode(value);\n      }\n    }]);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b><i><span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">@bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></i></b></p>');\n  });\n\n  test('renders a post with mixed markups and atoms', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref8) {\n      var markupSection = _ref8.markupSection;\n      var post = _ref8.post;\n      var atom = _ref8.atom;\n      var marker = _ref8.marker;\n      var markup = _ref8.markup;\n\n      var b = markup('B');\n      var i = markup('I');\n\n      return post([markupSection('p', [marker('bold', [b]), marker('italic ', [b, i]), atom('mention', '@bob', {}, [b, i]), marker(' bold', [b]), builder.createMarker('text.')])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree, [], [{\n      name: 'mention',\n      type: 'dom',\n      render: function render(_ref9) /*, options, env, payload*/{\n        var fragment = _ref9.fragment;\n        var value = _ref9.value;\n\n        return document.createTextNode(value);\n      }\n    }]);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b>bold<i>italic <span class=\"-mobiledoc-kit__atom\">' + _mobiledocKitRenderersEditorDom.ZWNJ + '<span contenteditable=\"false\">@bob</span>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</span></i> bold</b>text.</p>');\n  });\n\n  test('renders a card section', function (assert) {\n    var post = builder.createPost();\n    var cardSection = builder.createCardSection('my-card');\n    var card = {\n      name: 'my-card',\n      type: 'dom',\n      render: function render() {\n        return document.createTextNode('I am a card');\n      }\n    };\n    post.sections.append(cardSection);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree, [card]);\n\n    // Use a wrapper an innerHTML to satisfy different browser attribute\n    // ordering quirks\n    var expectedWrapper = $('<div>' + _mobiledocKitRenderersEditorDom.ZWNJ + '<div contenteditable=\"false\" class=\"__mobiledoc-card\">I am a card</div>' + _mobiledocKitRenderersEditorDom.ZWNJ + '</div>');\n    assert.equal(renderTree.rootElement.firstChild.innerHTML, expectedWrapper.html(), 'card is rendered');\n  });\n\n  test('rerender a marker after adding a markup to it', function (assert) {\n    var bold = undefined,\n        marker2 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref10) {\n      var post = _ref10.post;\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n      var markup = _ref10.markup;\n\n      bold = markup('B');\n      marker2 = marker('text2');\n      return post([markupSection('p', [marker('text1', [bold]), marker2])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b>text1</b>text2</p>');\n\n    marker2.addMarkup(bold);\n    marker2.renderNode.markDirty();\n\n    // rerender\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b>text1text2</b></p>');\n  });\n\n  test('rerender a marker after removing a markup from it', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('p');\n    var bMarkup = builder.createMarkup('B');\n    var marker1 = builder.createMarker('text1');\n    var marker2 = builder.createMarker('text2', [bMarkup]);\n\n    section.markers.append(marker1);\n    section.markers.append(marker2);\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p>text1<b>text2</b></p>');\n\n    marker2.removeMarkup(bMarkup);\n    marker2.renderNode.markDirty();\n\n    // rerender\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p>text1text2</p>');\n  });\n\n  test('rerender a marker after removing a markup from it (when changed marker is first marker)', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('p');\n    var bMarkup = builder.createMarkup('B');\n    var marker1 = builder.createMarker('text1', [bMarkup]);\n    var marker2 = builder.createMarker('text2');\n\n    section.markers.append(marker1);\n    section.markers.append(marker2);\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b>text1</b>text2</p>');\n\n    marker1.removeMarkup(bMarkup);\n    marker1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p>text1text2</p>');\n  });\n\n  test('rerender a marker after removing a markup from it (when both markers have same markup)', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('p');\n    var bMarkup = builder.createMarkup('B');\n    var marker1 = builder.createMarker('text1', [bMarkup]);\n    var marker2 = builder.createMarker('text2', [bMarkup]);\n\n    section.markers.append(marker1);\n    section.markers.append(marker2);\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b>text1text2</b></p>');\n\n    marker1.removeMarkup(bMarkup);\n    marker1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p>text1<b>text2</b></p>');\n  });\n\n  test('rerender a marker after removing a markup from it (when both markers have same markup)', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('p');\n    var bMarkup = builder.createMarkup('B');\n    var marker1 = builder.createMarker('text1', [bMarkup]);\n    var marker2 = builder.createMarker('text2', [bMarkup]);\n\n    section.markers.append(marker1);\n    section.markers.append(marker2);\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b>text1text2</b></p>');\n\n    marker1.removeMarkup(bMarkup);\n    marker1.renderNode.markDirty();\n\n    // rerender\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p>text1<b>text2</b></p>');\n  });\n\n  test('render when contiguous markers have out-of-order markups', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createMarkupSection('p');\n\n    var b = builder.createMarkup('B'),\n        i = builder.createMarkup('I');\n\n    var markers = [builder.createMarker('BI', [b, i]), builder.createMarker('IB', [i, b]), builder.createMarker('plain', [])];\n    var m1 = markers[0];\n\n    markers.forEach(function (m) {\n      return section.markers.append(m);\n    });\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><b><i>BI</i></b><i><b>IB</b></i>plain</p>');\n\n    // remove 'b' from 1st marker, rerender\n    m1.removeMarkup(b);\n    m1.renderNode.markDirty();\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><i>BI<b>IB</b></i>plain</p>');\n  });\n\n  test('contiguous markers have overlapping markups', function (assert) {\n    var b = builder.createMarkup('b'),\n        i = builder.createMarkup('i');\n    var post = builder.createPost();\n    var markers = [builder.createMarker('W', [i]), builder.createMarker('XY', [i, b]), builder.createMarker('Z', [b])];\n    var section = builder.createMarkupSection('P', markers);\n    post.sections.append(section);\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, '<p><i>W<b>XY</b></i><b>Z</b></p>');\n  });\n\n  test('renders and rerenders list items', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref11) {\n      var post = _ref11.post;\n      var listSection = _ref11.listSection;\n      var listItem = _ref11.listItem;\n      var marker = _ref11.marker;\n      return post([listSection('ul', [listItem([marker('first item')]), listItem([marker('second item')])])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('ul', {}, [t('li', {}, [t.text('first item')]), t('li', {}, [t.text('second item')])]);\n    });\n    var expectedHTML = expectedDOM.outerHTML;\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'correct html on initial render');\n\n    // test rerender after dirtying list section\n    var listSection = post.sections.head;\n    listSection.renderNode.markDirty();\n    render(renderTree);\n    assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'correct html on rerender after dirtying list-section');\n\n    // test rerender after dirtying list item\n    var listItem = post.sections.head.items.head;\n    listItem.renderNode.markDirty();\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'correct html on rerender after diryting list-item');\n  });\n\n  test('removes list items', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref12) {\n      var post = _ref12.post;\n      var listSection = _ref12.listSection;\n      var listItem = _ref12.listItem;\n      var marker = _ref12.marker;\n      return post([listSection('ul', [listItem([marker('first item')]), listItem([marker('second item')]), listItem([marker('third item')])])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    // return HTML for a list with the given items\n    var htmlWithItems = function htmlWithItems(itemTexts) {\n      var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n        return t('ul', {}, itemTexts.map(function (text) {\n          return t('li', {}, [t.text(text)]);\n        }));\n      });\n      return expectedDOM.outerHTML;\n    };\n\n    var listItem2 = post.sections.head. // listSection\n    items.objectAt(1); // li\n    listItem2.renderNode.scheduleForRemoval();\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, htmlWithItems(['first item', 'third item']), 'removes middle list item');\n\n    var listItemLast = post.sections.head. // listSection\n    items.tail;\n    listItemLast.renderNode.scheduleForRemoval();\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, htmlWithItems(['first item']), 'removes last list item');\n  });\n\n  test('removes list sections', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref13) {\n      var post = _ref13.post;\n      var listSection = _ref13.listSection;\n      var markupSection = _ref13.markupSection;\n      var listItem = _ref13.listItem;\n      var marker = _ref13.marker;\n      return post([markupSection('p', [marker('something')]), listSection('ul', [listItem([marker('first item')])])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('p', {}, [t.text('something')]);\n    });\n    var expectedHTML = expectedDOM.outerHTML;\n\n    var listSection = post.sections.objectAt(1);\n    listSection.renderNode.scheduleForRemoval();\n    render(renderTree);\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'removes list section');\n  });\n\n  test('includes card sections in renderTree element map', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref14) {\n      var post = _ref14.post;\n      var cardSection = _ref14.cardSection;\n      return post([cardSection('simple-card')]);\n    });\n    var cards = [{\n      name: 'simple-card',\n      type: 'dom',\n      render: function render() {\n        return $('<div id=\"simple-card\"></div>')[0];\n      }\n    }];\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree, cards);\n\n    $('#qunit-fixture').append(renderTree.rootElement);\n\n    var element = $('#simple-card')[0].parentNode.parentNode;\n    assert.ok(!!element, 'precond - simple card is rendered');\n    assert.ok(!!renderTree.getElementRenderNode(element), 'has render node for card element');\n  });\n\n  test('removes nested children of removed render nodes', function (assert) {\n    var section = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref15) {\n      var post = _ref15.post;\n      var markupSection = _ref15.markupSection;\n      var marker = _ref15.marker;\n\n      section = markupSection('p', [marker('abc')]);\n      return post([section]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var marker = section.markers.head;\n    assert.ok(!!section.renderNode, 'precond - section has render node');\n    assert.ok(!!marker.renderNode, 'precond - marker has render node');\n\n    section.renderNode.scheduleForRemoval();\n    render(renderTree);\n\n    assert.ok(!marker.renderNode.parent, 'marker render node is orphaned');\n    assert.ok(!marker.renderNode.element, 'marker render node has no element');\n    assert.equal(section.renderNode.childNodes.length, 0, 'section render node has all children removed');\n  });\n\n  test('renders markup section \"aside\" as <aside></aside>', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref16) {\n      var post = _ref16.post;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n\n      return post([markupSection('aside', [marker('abc')])]);\n    });\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('aside', {}, [t.text('abc')]);\n    });\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);\n  });\n\n  test('renders characters and spaces with nbsps', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var marker = _ref17.marker;\n\n      return post([markupSection('p', [marker('a b  c    d ')])]);\n    });\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('p', {}, [t.text('a b ' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + 'c ' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + ' ' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + 'd' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE)]);\n    });\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);\n  });\n\n  test('renders all spaces with nbsps', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref18) {\n      var post = _ref18.post;\n      var markupSection = _ref18.markupSection;\n      var marker = _ref18.marker;\n\n      return post([markupSection('p', [marker('   ')])]);\n    });\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('p', {}, [t.text('' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE)]);\n    });\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);\n  });\n\n  test('renders leading space with nbsp', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref19) {\n      var post = _ref19.post;\n      var markupSection = _ref19.markupSection;\n      var marker = _ref19.marker;\n\n      return post([markupSection('p', [marker(' a')])]);\n    });\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('p', {}, [t.text(_mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + 'a')]);\n    });\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);\n  });\n\n  test('renders trailing space with nbsp', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref20) {\n      var post = _ref20.post;\n      var markupSection = _ref20.markupSection;\n      var marker = _ref20.marker;\n\n      return post([markupSection('p', [marker('a ')])]);\n    });\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('p', {}, [t.text('a' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE)]);\n    });\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);\n  });\n\n  test('renders leading and trailing space with nbsp', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref21) {\n      var post = _ref21.post;\n      var markupSection = _ref21.markupSection;\n      var marker = _ref21.marker;\n\n      return post([markupSection('p', [marker(' a ')])]);\n    });\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var expectedDOM = _testHelpers['default'].dom.build(function (t) {\n      return t('p', {}, [t.text(_mobiledocKitRenderersEditorDom.NO_BREAK_SPACE + 'a' + _mobiledocKitRenderersEditorDom.NO_BREAK_SPACE)]);\n    });\n\n    assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);\n  });\n\n  test('#destroy is safe to call if renderer has not rendered', function (assert) {\n    var mockEditor = {},\n        cards = [];\n    var renderer = new _mobiledocKitRenderersEditorDom['default'](mockEditor, cards);\n\n    assert.ok(!renderer.hasRendered, 'precond - has not rendered');\n\n    renderer.destroy();\n\n    assert.ok(true, 'ok to destroy');\n  });\n\n  // see https://github.com/bustle/mobiledoc-kit/issues/306\n  test('rerender after adding markup to a marker when the marker siblings have that markup', function (assert) {\n    var strong = undefined,\n        expected = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref22) {\n      var post = _ref22.post;\n      var markupSection = _ref22.markupSection;\n      var marker = _ref22.marker;\n      var markup = _ref22.markup;\n\n      strong = markup('strong');\n      expected = post([markupSection('p', [marker('aXc', [strong])])]);\n      return post([markupSection('p', [marker('a', [strong]), marker('X'), marker('c', [strong])])]);\n    });\n\n    var renderTree = new _mobiledocKitModelsRenderTree['default'](post);\n    render(renderTree);\n\n    var markers = post.sections.head.markers.toArray();\n    assert.equal(markers.length, 3);\n\n    // step 1: add markup to the marker\n    markers[1].addMarkup(strong);\n\n    // step 2, join the markers\n    markers[1].value = 'aX';\n    markers[1].renderNode.markDirty();\n    markers[0].renderNode.scheduleForRemoval();\n    markers[0].section.markers.remove(markers[0]);\n\n    markers[2].value = 'aXc';\n    markers[2].renderNode.markDirty();\n    markers[1].renderNode.scheduleForRemoval();\n    markers[1].section.markers.remove(markers[1]);\n\n    render(renderTree);\n\n    assert.renderTreeIsEqual(renderTree, expected);\n\n    markers = post.sections.head.markers.toArray();\n    assert.equal(markers.length, 1);\n    assert.ok(markers[0].hasMarkup(strong), 'marker has strong');\n    assert.equal(markers[0].value, 'aXc');\n  });\n\n  /*\n  test(\"It renders a renderTree with rendered dirty section\", (assert) => {\n    /*\n     * renderTree is:\n     *\n     *      post<dirty>\n     *       /        \\\n     *      /          \\\n     * section      section<dirty>\n     *\n    let post = builder.createPost\n    let postRenderNode = {\n      element: null,\n      parent: null,\n      isDirty: true,\n      postNode: builder.createPost()\n    }\n    let renderTree = {\n      node: renderNode\n    }\n  \n    render(renderTree);\n  \n    assert.ok(renderTree.rootElement, 'renderTree renders element for post');\n    assert.ok(!renderTree.rootNode.isDirty, 'dirty node becomes clean');\n    assert.equal(renderTree.rootElement.tagName, 'DIV', 'renderTree renders element for post');\n  });\n  */\n});","define('tests/unit/renderers/mobiledoc-test', ['exports', 'mobiledoc-kit/renderers/mobiledoc', '../../test-helpers'], function (exports, _mobiledocKitRenderersMobiledoc, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  function render(post) {\n    return _mobiledocKitRenderersMobiledoc['default'].render(post);\n  }\n\n  _module('Unit: Mobiledoc Renderer');\n\n  test('renders a blank post', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      return post();\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: []\n    });\n  });\n});","define('tests/unit/renderers/mobiledoc/0-2-test', ['exports', 'mobiledoc-kit/renderers/mobiledoc/0-2', 'mobiledoc-kit/models/post-node-builder', 'mobiledoc-kit/utils/dom-utils', '../../../test-helpers'], function (exports, _mobiledocKitRenderersMobiledoc02, _mobiledocKitModelsPostNodeBuilder, _mobiledocKitUtilsDomUtils, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  function render(post) {\n    return _mobiledocKitRenderersMobiledoc02['default'].render(post);\n  }\n  var builder = undefined;\n\n  _module('Unit: Mobiledoc Renderer 0.2', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    }\n  });\n\n  test('renders a blank post', function (assert) {\n    var post = builder.createPost();\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], []]\n    });\n  });\n\n  test('renders a post with marker', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n      var markup = _ref.markup;\n\n      return post([markupSection('p', [marker('Hi', [markup('strong')])])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[['strong']], [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[[0], 1, 'Hi']]]]]\n    });\n  });\n\n  test('renders a post section with markers sharing a markup', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n      var markup = _ref2.markup;\n\n      var strong = markup('strong');\n      return post([markupSection('p', [marker('Hi', [strong]), marker(' Guy', [strong])])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[['strong']], [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[[0], 0, 'Hi'], [[], 1, ' Guy']]]]]\n    });\n  });\n\n  test('renders a post with markers with markers with complex attributes', function (assert) {\n    var link1 = undefined,\n        link2 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n      var markup = _ref3.markup;\n\n      link1 = markup('a', { href: 'bustle.com' });\n      link2 = markup('a', { href: 'other.com' });\n      return post([markupSection('p', [marker('Hi', [link1]), marker(' Guy', [link2]), marker(' other guy', [link1])])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[['a', ['href', 'bustle.com']], ['a', ['href', 'other.com']]], [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[[0], 1, 'Hi'], [[1], 1, ' Guy'], [[0], 1, ' other guy']]]]]\n    });\n  });\n\n  test('renders a post with image', function (assert) {\n    var url = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=\";\n    var post = builder.createPost();\n    var section = builder.createImageSection(url);\n    post.sections.append(section);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[2, url]]]\n    });\n  });\n\n  test('renders a post with image and null src', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createImageSection();\n    post.sections.append(section);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[2, null]]]\n    });\n  });\n\n  test('renders a post with card', function (assert) {\n    var cardName = 'super-card';\n    var payload = { bar: 'baz' };\n    var post = builder.createPost();\n    var section = builder.createCardSection(cardName, payload);\n    post.sections.append(section);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[10, cardName, payload]]]\n    });\n  });\n\n  test('renders a post with a list', function (assert) {\n    var items = [builder.createListItem([builder.createMarker('first item')]), builder.createListItem([builder.createMarker('second item')])];\n    var section = builder.createListSection('ul', items);\n    var post = builder.createPost([section]);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[3, 'ul', [[[[], 0, 'first item']], [[[], 0, 'second item']]]]]]\n    });\n  });\n\n  test('renders an aside as markup section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n\n      return post([markupSection('aside', [marker('abc')])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc02.MOBILEDOC_VERSION,\n      sections: [[], [[1, 'aside', [[[], 0, 'abc']]]]]\n    });\n  });\n});","define('tests/unit/renderers/mobiledoc/0-3-test', ['exports', 'mobiledoc-kit/renderers/mobiledoc/0-3', 'mobiledoc-kit/models/post-node-builder', 'mobiledoc-kit/utils/dom-utils', '../../../test-helpers'], function (exports, _mobiledocKitRenderersMobiledoc03, _mobiledocKitModelsPostNodeBuilder, _mobiledocKitUtilsDomUtils, _testHelpers) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  function render(post) {\n    return _mobiledocKitRenderersMobiledoc03['default'].render(post);\n  }\n  var builder = undefined;\n\n  _module('Unit: Mobiledoc Renderer 0.3', {\n    beforeEach: function beforeEach() {\n      builder = new _mobiledocKitModelsPostNodeBuilder['default']();\n    }\n  });\n\n  test('renders a blank post', function (assert) {\n    var post = builder.createPost();\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: []\n    });\n  });\n\n  test('renders a post with marker', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n      var markup = _ref.markup;\n\n      return post([markupSection('p', [marker('Hi', [markup('strong')])])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [['strong']],\n      sections: [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[0, [0], 1, 'Hi']]]]\n    });\n  });\n\n  test('renders a post section with markers sharing a markup', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n      var markup = _ref2.markup;\n\n      var strong = markup('strong');\n      return post([markupSection('p', [marker('Hi', [strong]), marker(' Guy', [strong])])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [['strong']],\n      sections: [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[0, [0], 0, 'Hi'], [0, [], 1, ' Guy']]]]\n    });\n  });\n\n  test('renders a post with markers with markers with complex attributes', function (assert) {\n    var link1 = undefined,\n        link2 = undefined;\n    var post = _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n      var markup = _ref3.markup;\n\n      link1 = markup('a', { href: 'bustle.com' });\n      link2 = markup('a', { href: 'other.com' });\n      return post([markupSection('p', [marker('Hi', [link1]), marker(' Guy', [link2]), marker(' other guy', [link1])])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [['a', ['href', 'bustle.com']], ['a', ['href', 'other.com']]],\n      sections: [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[0, [0], 1, 'Hi'], [0, [1], 1, ' Guy'], [0, [0], 1, ' other guy']]]]\n    });\n  });\n\n  test('renders a post with image', function (assert) {\n    var url = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=\";\n    var post = builder.createPost();\n    var section = builder.createImageSection(url);\n    post.sections.append(section);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[2, url]]\n    });\n  });\n\n  test('renders a post with image and null src', function (assert) {\n    var post = builder.createPost();\n    var section = builder.createImageSection();\n    post.sections.append(section);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[2, null]]\n    });\n  });\n\n  test('renders a post with atom', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var post = _ref4.post;\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n      var atom = _ref4.atom;\n\n      return post([markupSection('p', [marker('Hi'), atom('mention', '@bob', { id: 42 })])]);\n    });\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [['mention', '@bob', { id: 42 }]],\n      cards: [],\n      markups: [],\n      sections: [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[0, [], 0, 'Hi'], [1, [], 0, 0]]]]\n    });\n  });\n\n  test('renders a post with atom and markup', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref5) {\n      var post = _ref5.post;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n      var markup = _ref5.markup;\n      var atom = _ref5.atom;\n\n      var strong = markup('strong');\n      return post([markupSection('p', [atom('mention', '@bob', { id: 42 }, [strong])])]);\n    });\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [['mention', '@bob', { id: 42 }]],\n      cards: [],\n      markups: [['strong']],\n      sections: [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[1, [0], 1, 0]]]]\n    });\n  });\n\n  test('renders a post with atom inside markup', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var post = _ref6.post;\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n      var markup = _ref6.markup;\n      var atom = _ref6.atom;\n\n      var strong = markup('strong');\n      return post([markupSection('p', [marker('Hi ', [strong]), atom('mention', '@bob', { id: 42 }, [strong]), marker(' Bye', [strong])])]);\n    });\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [['mention', '@bob', { id: 42 }]],\n      cards: [],\n      markups: [['strong']],\n      sections: [[1, (0, _mobiledocKitUtilsDomUtils.normalizeTagName)('P'), [[0, [0], 0, 'Hi '], [1, [], 0, 0], [0, [], 1, ' Bye']]]]\n    });\n  });\n\n  test('renders a post with card', function (assert) {\n    var cardName = 'super-card';\n    var payload = { bar: 'baz' };\n    var post = builder.createPost();\n    var section = builder.createCardSection(cardName, payload);\n    post.sections.append(section);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [[cardName, payload]],\n      markups: [],\n      sections: [[10, 0]]\n    });\n  });\n\n  test('renders a post with multiple cards with identical payloads', function (assert) {\n    var cardName = 'super-card';\n    var payload1 = { bar: 'baz' };\n    var payload2 = { bar: 'baz' };\n    var post = builder.createPost();\n\n    var section1 = builder.createCardSection(cardName, payload1);\n    post.sections.append(section1);\n\n    var section2 = builder.createCardSection(cardName, payload2);\n    post.sections.append(section2);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [[cardName, payload1], [cardName, payload2]],\n      markups: [],\n      sections: [[10, 0], [10, 1]]\n    });\n  });\n\n  test('renders a post with cards with differing payloads', function (assert) {\n    var cardName = 'super-card';\n    var payload1 = { bar: 'baz1' };\n    var payload2 = { bar: 'baz2' };\n    var post = builder.createPost();\n\n    var section1 = builder.createCardSection(cardName, payload1);\n    post.sections.append(section1);\n\n    var section2 = builder.createCardSection(cardName, payload2);\n    post.sections.append(section2);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [[cardName, payload1], [cardName, payload2]],\n      markups: [],\n      sections: [[10, 0], [10, 1]]\n    });\n  });\n\n  test('renders a post with a list', function (assert) {\n    var items = [builder.createListItem([builder.createMarker('first item')]), builder.createListItem([builder.createMarker('second item')])];\n    var section = builder.createListSection('ul', items);\n    var post = builder.createPost([section]);\n\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[3, 'ul', [[[0, [], 0, 'first item']], [[0, [], 0, 'second item']]]]]\n    });\n  });\n\n  test('renders an aside as markup section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref7) {\n      var post = _ref7.post;\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n\n      return post([markupSection('aside', [marker('abc')])]);\n    });\n    var mobiledoc = render(post);\n    assert.deepEqual(mobiledoc, {\n      version: _mobiledocKitRenderersMobiledoc03.MOBILEDOC_VERSION,\n      atoms: [],\n      cards: [],\n      markups: [],\n      sections: [[1, 'aside', [[0, [], 0, 'abc']]]]\n    });\n  });\n});","define('tests/unit/utils/array-utils-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/array-utils'], function (exports, _testHelpers, _mobiledocKitUtilsArrayUtils) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: Array Utils');\n\n  test('#objectToSortedKVArray works', function (assert) {\n    assert.deepEqual((0, _mobiledocKitUtilsArrayUtils.objectToSortedKVArray)({ a: 1, b: 2 }), ['a', 1, 'b', 2]);\n    assert.deepEqual((0, _mobiledocKitUtilsArrayUtils.objectToSortedKVArray)({ b: 1, a: 2 }), ['a', 2, 'b', 1]);\n    assert.deepEqual((0, _mobiledocKitUtilsArrayUtils.objectToSortedKVArray)({}), []);\n  });\n\n  test('#kvArrayToObject works', function (assert) {\n    assert.deepEqual((0, _mobiledocKitUtilsArrayUtils.kvArrayToObject)(['a', 1, 'b', 2]), { a: 1, b: 2 });\n    assert.deepEqual((0, _mobiledocKitUtilsArrayUtils.kvArrayToObject)([]), {});\n  });\n});","define('tests/unit/utils/assert-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/assert', 'mobiledoc-kit/utils/mobiledoc-error'], function (exports, _testHelpers, _mobiledocKitUtilsAssert, _mobiledocKitUtilsMobiledocError) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: assert');\n\n  test('#throws a MobiledocError when conditional is false', function (assert) {\n    try {\n      (0, _mobiledocKitUtilsAssert['default'])('The message', false);\n    } catch (e) {\n      assert.ok(true, 'caught error');\n      assert.equal(e.message, 'The message');\n      assert.ok(e instanceof _mobiledocKitUtilsMobiledocError['default'], 'e instanceof MobiledocError');\n    }\n  });\n});","define('tests/unit/utils/copy-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/copy'], function (exports, _testHelpers, _mobiledocKitUtilsCopy) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: copy');\n\n  test('#shallowCopyObject breaks references', function (assert) {\n    var obj = { a: 1, b: 'b' };\n    var obj2 = (0, _mobiledocKitUtilsCopy.shallowCopyObject)(obj);\n    obj.a = 2;\n    obj.b = 'new b';\n\n    assert.ok(obj !== obj2, 'obj !== obj2');\n    assert.equal(obj2.a, 1, 'obj2 \"a\" preserved');\n    assert.equal(obj2.b, 'b', 'obj2 \"b\" preserved');\n  });\n});","define('tests/unit/utils/cursor-position-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/cursor/position', 'mobiledoc-kit/renderers/editor-dom', 'mobiledoc-kit/utils/key'], function (exports, _testHelpers, _mobiledocKitUtilsCursorPosition, _mobiledocKitRenderersEditorDom, _mobiledocKitUtilsKey) {\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  var FORWARD = _mobiledocKitUtilsKey.DIRECTION.FORWARD;\n  var BACKWARD = _mobiledocKitUtilsKey.DIRECTION.BACKWARD;\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var editor = undefined,\n      editorElement = undefined;\n\n  _module('Unit: Utils: Position', {\n    beforeEach: function beforeEach() {\n      editorElement = $('#editor')[0];\n    },\n    afterEach: function afterEach() {\n      if (editor) {\n        editor.destroy();\n        editor = null;\n      }\n    }\n  });\n\n  test('#move moves forward and backward in markup section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var post = _ref.post;\n      var markupSection = _ref.markupSection;\n      var marker = _ref.marker;\n\n      return post([markupSection('p', [marker('abcd')])]);\n    });\n    var position = post.sections.head.toPosition('ab'.length);\n    var rightPosition = post.sections.head.toPosition('abc'.length);\n    var leftPosition = post.sections.head.toPosition('a'.length);\n\n    assert.positionIsEqual(position.move(FORWARD), rightPosition, 'right position');\n    assert.positionIsEqual(position.move(BACKWARD), leftPosition, 'left position');\n  });\n\n  test('#move is emoji-aware', function (assert) {\n    var emoji = '🙈';\n    var post = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var post = _ref2.post;\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n\n      return post([markupSection('p', [marker('a' + emoji + 'z')])]);\n    });\n    var marker = post.sections.head.markers.head;\n    assert.equal(marker.length, 'a'.length + 2 + 'z'.length); // precond\n    var position = post.sections.head.headPosition();\n\n    position = position.move(FORWARD);\n    assert.equal(position.offset, 1);\n    position = position.move(FORWARD);\n    assert.equal(position.offset, 3); // l-to-r across emoji\n    position = position.move(FORWARD);\n    assert.equal(position.offset, 4);\n\n    position = position.move(BACKWARD);\n    assert.equal(position.offset, 3);\n\n    position = position.move(BACKWARD); // r-to-l across emoji\n    assert.equal(position.offset, 1);\n\n    position = position.move(BACKWARD);\n    assert.equal(position.offset, 0);\n  });\n\n  test('#move moves forward and backward between markup sections', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var post = _ref3.post;\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n\n      return post([markupSection('p', [marker('a')]), markupSection('p', [marker('b')]), markupSection('p', [marker('c')])]);\n    });\n    var midHead = post.sections.objectAt(1).headPosition();\n    var midTail = post.sections.objectAt(1).tailPosition();\n\n    var aTail = post.sections.head.tailPosition();\n    var cHead = post.sections.tail.headPosition();\n\n    assert.positionIsEqual(midHead.move(BACKWARD), aTail, 'left to prev section');\n    assert.positionIsEqual(midTail.move(FORWARD), cHead, 'right to next section');\n  });\n\n  test('#move from one nested section to another', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var post = _ref4.post;\n      var listSection = _ref4.listSection;\n      var listItem = _ref4.listItem;\n      var marker = _ref4.marker;\n\n      return post([listSection('ul', [listItem([marker('a')]), listItem([marker('b')]), listItem([marker('c')])])]);\n    });\n    var midHead = post.sections.head.items.objectAt(1).headPosition();\n    var midTail = post.sections.head.items.objectAt(1).tailPosition();\n\n    var aTail = post.sections.head.items.head.tailPosition();\n    var cHead = post.sections.tail.items.tail.headPosition();\n\n    assert.positionIsEqual(midHead.move(BACKWARD), aTail, 'left to prev section');\n    assert.positionIsEqual(midTail.move(FORWARD), cHead, 'right to next section');\n  });\n\n  test('#move from last nested section to next un-nested section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref5) {\n      var post = _ref5.post;\n      var listSection = _ref5.listSection;\n      var listItem = _ref5.listItem;\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n\n      return post([markupSection('p', [marker('a')]), listSection('ul', [listItem([marker('b')])]), markupSection('p', [marker('c')])]);\n    });\n    var midHead = post.sections.objectAt(1).items.head.headPosition();\n    var midTail = post.sections.objectAt(1).items.head.tailPosition();\n\n    var aTail = post.sections.head.tailPosition();\n    var cHead = post.sections.tail.headPosition();\n\n    assert.positionIsEqual(midHead.move(BACKWARD), aTail, 'left to prev section');\n    assert.positionIsEqual(midTail.move(FORWARD), cHead, 'right to next section');\n  });\n\n  test('#move across and beyond card section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var post = _ref6.post;\n      var cardSection = _ref6.cardSection;\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n\n      return post([markupSection('p', [marker('a')]), cardSection('my-card'), markupSection('p', [marker('c')])]);\n    });\n    var midHead = post.sections.objectAt(1).headPosition();\n    var midTail = post.sections.objectAt(1).tailPosition();\n\n    var aTail = post.sections.head.tailPosition();\n    var cHead = post.sections.tail.headPosition();\n\n    assert.positionIsEqual(midHead.move(BACKWARD), aTail, 'left to prev section');\n    assert.positionIsEqual(midTail.move(FORWARD), cHead, 'right to next section');\n    assert.positionIsEqual(midHead.move(FORWARD), midTail, 'move l-to-r across card');\n    assert.positionIsEqual(midTail.move(BACKWARD), midHead, 'move r-to-l across card');\n  });\n\n  test('#move across and beyond card section into list section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref7) {\n      var post = _ref7.post;\n      var cardSection = _ref7.cardSection;\n      var listSection = _ref7.listSection;\n      var listItem = _ref7.listItem;\n      var marker = _ref7.marker;\n\n      return post([listSection('ul', [listItem([marker('a1')]), listItem([marker('a2')])]), cardSection('my-card'), listSection('ul', [listItem([marker('c1')]), listItem([marker('c2')])])]);\n    });\n    var midHead = post.sections.objectAt(1).headPosition();\n    var midTail = post.sections.objectAt(1).tailPosition();\n\n    var aTail = post.sections.head.items.tail.tailPosition();\n    var cHead = post.sections.tail.items.head.headPosition();\n\n    assert.positionIsEqual(midHead.move(BACKWARD), aTail, 'left to prev section');\n    assert.positionIsEqual(midTail.move(FORWARD), cHead, 'right to next section');\n  });\n\n  test('#move left at headPosition or right at tailPosition returns self', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref8) {\n      var post = _ref8.post;\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('def')])]);\n    });\n\n    var head = post.headPosition(),\n        tail = post.tailPosition();\n    assert.positionIsEqual(head.move(BACKWARD), head, 'head move left is head');\n    assert.positionIsEqual(tail.move(FORWARD), tail, 'tail move right is tail');\n  });\n\n  test('#move can move multiple units', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref9) {\n      var post = _ref9.post;\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      return post([markupSection('p', [marker('abc')]), markupSection('p', [marker('def')])]);\n    });\n\n    var head = post.headPosition(),\n        tail = post.tailPosition();\n\n    assert.positionIsEqual(head.move(FORWARD * ('abc'.length + 1 + 'def'.length)), tail, 'head can move to tail');\n    assert.positionIsEqual(tail.move(BACKWARD * ('abc'.length + 1 + 'def'.length)), head, 'tail can move to head');\n\n    assert.positionIsEqual(head.move(0), head, 'move(0) is no-op');\n  });\n\n  test('#moveWord in text (backward)', function (assert) {\n    var expectations = [['abc def|', 'abc |def'], ['abc d|ef', 'abc |def'], ['abc |def', '|abc def'], ['abc| def', '|abc def'], ['|abc def', '|abc def'], ['abc-|', '|abc-'], ['abc|', '|abc'], ['ab|c', '|abc'], ['|abc', '|abc'], ['abc  |', '|abc'], ['abcdéf|', '|abcdéf']];\n\n    expectations.forEach(function (_ref10) {\n      var _ref102 = _slicedToArray(_ref10, 2);\n\n      var before = _ref102[0];\n      var after = _ref102[1];\n\n      var _Helpers$postAbstract$buildFromText = _testHelpers['default'].postAbstract.buildFromText(before);\n\n      var post = _Helpers$postAbstract$buildFromText.post;\n      var pos = _Helpers$postAbstract$buildFromText.range.head;\n\n      var _Helpers$postAbstract$buildFromText2 = _testHelpers['default'].postAbstract.buildFromText(after);\n\n      var afterPos = _Helpers$postAbstract$buildFromText2.range.head;\n\n      var expectedPos = post.sections.head.toPosition(afterPos.offset);\n      assert.positionIsEqual(pos.moveWord(BACKWARD), expectedPos, 'move word \"' + before + '\"->\"' + after + '\"');\n    });\n  });\n\n  test('#moveWord stops on word-separators', function (assert) {\n    var separators = ['-', '+', '=', '|'];\n    separators.forEach(function (sep) {\n      var text = 'abc' + sep + 'def';\n      var post = _testHelpers['default'].postAbstract.build(function (_ref11) {\n        var post = _ref11.post;\n        var markupSection = _ref11.markupSection;\n        var marker = _ref11.marker;\n\n        return post([markupSection('p', [marker(text)])]);\n      });\n      var pos = post.tailPosition();\n      var expectedPos = post.sections.head.toPosition('abc '.length);\n\n      assert.positionIsEqual(pos.moveWord(BACKWARD), expectedPos, 'move word <- \"' + text + '|\"');\n    });\n  });\n\n  test('#moveWord does not stop on non-word-separators', function (assert) {\n    var nonSeparators = ['_', ':'];\n    nonSeparators.forEach(function (sep) {\n      var text = 'abc' + sep + 'def';\n\n      // Have to use `build` function here because \"_\" is a special char for `buildFromText`\n      var post = _testHelpers['default'].postAbstract.build(function (_ref12) {\n        var post = _ref12.post;\n        var markupSection = _ref12.markupSection;\n        var marker = _ref12.marker;\n\n        return post([markupSection('p', [marker(text)])]);\n      });\n      var pos = post.tailPosition();\n      var nextPos = post.headPosition();\n\n      assert.positionIsEqual(pos.moveWord(BACKWARD), nextPos, 'move word <- \"' + text + '|\"');\n    });\n  });\n\n  test('#moveWord across markerable sections', function (assert) {\n    var _Helpers$postAbstract$buildFromText3 = _testHelpers['default'].postAbstract.buildFromText(['abc def', '123 456']);\n\n    var post = _Helpers$postAbstract$buildFromText3.post;\n\n    var _post$sections$toArray = post.sections.toArray();\n\n    var _post$sections$toArray2 = _slicedToArray(_post$sections$toArray, 2);\n\n    var first = _post$sections$toArray2[0];\n    var second = _post$sections$toArray2[1];\n\n    var pos = function pos(section, text) {\n      return section.toPosition(text.length);\n    };\n    var firstTail = first.tailPosition();\n    var secondHead = second.headPosition();\n\n    assert.positionIsEqual(secondHead.moveWord(BACKWARD), pos(first, 'abc '), 'secondHead <- \"abc \"');\n    assert.positionIsEqual(firstTail.moveWord(FORWARD), pos(second, '123'), 'firstTail <- \"123\"');\n  });\n\n  test('#moveWord across markerable/non-markerable section boundaries', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref13) {\n      var post = _ref13.post;\n      var markupSection = _ref13.markupSection;\n      var cardSection = _ref13.cardSection;\n      var marker = _ref13.marker;\n\n      return post([markupSection('p', [marker('abc')]), cardSection('some-card'), markupSection('p', [marker('def')])]);\n    });\n\n    var _post$sections$toArray3 = post.sections.toArray();\n\n    var _post$sections$toArray32 = _slicedToArray(_post$sections$toArray3, 3);\n\n    var before = _post$sections$toArray32[0];\n    var card = _post$sections$toArray32[1];\n    var after = _post$sections$toArray32[2];\n\n    var cardHead = card.headPosition();\n    var cardTail = card.tailPosition();\n    var beforeTail = before.tailPosition();\n    var afterHead = after.headPosition();\n\n    assert.positionIsEqual(cardHead.moveWord(BACKWARD), beforeTail, 'cardHead <- beforeTail');\n    assert.positionIsEqual(cardHead.moveWord(FORWARD), cardTail, 'cardHead -> cardTail');\n    assert.positionIsEqual(cardTail.moveWord(BACKWARD), cardHead, 'cardTail <- cardHead');\n    assert.positionIsEqual(afterHead.moveWord(BACKWARD), cardHead, 'afterHead <- cardHead');\n    assert.positionIsEqual(beforeTail.moveWord(FORWARD), cardTail, 'beforeTail -> cardTail');\n  });\n\n  test('#moveWord with atoms (backward)', function (assert) {\n    var expectations = [['abc @|', 'abc |@'], ['abc |@', '|abc @'], ['@|', '|@'], ['@  |', '@|  '], ['@@|', '@|@'], ['@|@', '|@@'], ['|@@', '|@@']];\n\n    expectations.forEach(function (_ref14) {\n      var _ref142 = _slicedToArray(_ref14, 2);\n\n      var before = _ref142[0];\n      var after = _ref142[1];\n\n      var _Helpers$postAbstract$buildFromText4 = _testHelpers['default'].postAbstract.buildFromText(before);\n\n      var post = _Helpers$postAbstract$buildFromText4.post;\n      var pos = _Helpers$postAbstract$buildFromText4.range.head;\n\n      var _Helpers$postAbstract$buildFromText5 = _testHelpers['default'].postAbstract.buildFromText(after);\n\n      var nextPos = _Helpers$postAbstract$buildFromText5.range.head;\n\n      var section = post.sections.head;\n      nextPos = section.toPosition(nextPos.offset);\n\n      assert.positionIsEqual(pos.moveWord(BACKWARD), nextPos, 'move word with atoms \"' + before + '\" -> \"' + after + '\"');\n    });\n  });\n\n  test('#moveWord in text (forward)', function (assert) {\n    var expectations = [['|abc def', 'abc| def'], ['a|bc def', 'abc| def'], ['abc| def', 'abc def|'], ['abc |def', 'abc def|'], ['abc def|', 'abc def|'], ['abc|', 'abc|'], ['ab|c', 'abc|'], ['|abc', 'abc|'], ['|  abc', '  abc|']];\n\n    expectations.forEach(function (_ref15) {\n      var _ref152 = _slicedToArray(_ref15, 2);\n\n      var before = _ref152[0];\n      var after = _ref152[1];\n\n      var _Helpers$postAbstract$buildFromText6 = _testHelpers['default'].postAbstract.buildFromText(before);\n\n      var post = _Helpers$postAbstract$buildFromText6.post;\n      var pos = _Helpers$postAbstract$buildFromText6.range.head;\n\n      var _Helpers$postAbstract$buildFromText7 = _testHelpers['default'].postAbstract.buildFromText(after);\n\n      var nextPos = _Helpers$postAbstract$buildFromText7.range.head;\n\n      var section = post.sections.head;\n      nextPos = section.toPosition(nextPos.offset); // fix section\n\n      assert.positionIsEqual(pos.moveWord(FORWARD), nextPos, 'move word \"' + before + '\"->\"' + after + '\"');\n    });\n  });\n\n  test('#moveWord with atoms (forward)', function (assert) {\n    var expectations = [['|@', '@|'], ['@|', '@|'], ['|  @', '  @|'], ['|  @ x', '  @ |x'], ['abc| @', 'abc @|'], ['|@@', '@|@'], ['@|@', '@@|'], ['@@|', '@@|']];\n\n    expectations.forEach(function (_ref16) {\n      var _ref162 = _slicedToArray(_ref16, 2);\n\n      var before = _ref162[0];\n      var after = _ref162[1];\n\n      var _Helpers$postAbstract$buildFromText8 = _testHelpers['default'].postAbstract.buildFromText(before);\n\n      var post = _Helpers$postAbstract$buildFromText8.post;\n      var pos = _Helpers$postAbstract$buildFromText8.range.head;\n\n      var _Helpers$postAbstract$buildFromText9 = _testHelpers['default'].postAbstract.buildFromText(after);\n\n      var nextPos = _Helpers$postAbstract$buildFromText9.range.head;\n\n      var section = post.sections.head;\n      nextPos = section.toPosition(nextPos.offset);\n\n      assert.positionIsEqual(pos.moveWord(FORWARD), nextPos, 'move word with atoms \"' + before + '\" -> \"' + after + '\"');\n    });\n  });\n\n  test('#fromNode when node is marker text node', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref17) {\n      var post = _ref17.post;\n      var markupSection = _ref17.markupSection;\n      var marker = _ref17.marker;\n\n      return post([markupSection('p', [marker('abc'), marker('123')])]);\n    });\n\n    var textNode = editorElement.firstChild // p\n    .lastChild; // textNode\n\n    assert.equal(textNode.textContent, '123', 'precond - correct text node');\n\n    var renderTree = editor._renderTree;\n    var position = _mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, textNode, 2);\n\n    var section = editor.post.sections.head;\n    assert.positionIsEqual(position, section.toPosition('abc'.length + 2));\n  });\n\n  test('#fromNode when node is section node with offset', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref18) {\n      var post = _ref18.post;\n      var markupSection = _ref18.markupSection;\n      var marker = _ref18.marker;\n\n      return post([markupSection('p', [marker('abc'), marker('123')])]);\n    });\n\n    var pNode = editorElement.firstChild;\n    assert.equal(pNode.tagName.toLowerCase(), 'p', 'precond - correct node');\n\n    var renderTree = editor._renderTree;\n    var position = _mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, pNode, 0);\n\n    assert.positionIsEqual(position, editor.post.sections.head.headPosition());\n  });\n\n  test('#fromNode when node is root element and offset is 0', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref19) {\n      var post = _ref19.post;\n      var markupSection = _ref19.markupSection;\n      var marker = _ref19.marker;\n\n      return post([markupSection('p', [marker('abc'), marker('123')])]);\n    });\n\n    var renderTree = editor._renderTree;\n    var position = _mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, editorElement, 0);\n\n    assert.positionIsEqual(position, editor.post.headPosition());\n  });\n\n  test('#fromNode when node is root element and offset is > 0', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref20) {\n      var post = _ref20.post;\n      var markupSection = _ref20.markupSection;\n      var marker = _ref20.marker;\n\n      return post([markupSection('p', [marker('abc'), marker('123')])]);\n    });\n\n    var renderTree = editor._renderTree;\n    var position = _mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, editorElement, 1);\n\n    assert.positionIsEqual(position, editor.post.tailPosition());\n  });\n\n  /**\n   * On Firefox, triple-clicking results in a different selection that on Chrome\n   * and others. Imagine we have the following content:\n   *\n   * <p>abc</p>\n   *\n   * Chrome:\n   * anchorNode: <TextNode>\n   * anchorOffset: 0\n   * focusNode: <TextNode>\n   * focusOffset: 3\n   *\n   * Firefox:\n   * anchorNode: <p>\n   * anchorOffset: 0\n   * focusNode: <p>\n   * focusOffset: 1\n   *\n   * So when getting the position for `focusNode`/`focusOffset`, we have to get\n   * the tail of section.\n   */\n  test('#fromNode when offset refers to one past the number of child nodes of the node', function (assert) {\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref21) {\n      var post = _ref21.post;\n      var markupSection = _ref21.markupSection;\n      var marker = _ref21.marker;\n\n      return post([markupSection('p', [marker('abc')])]);\n    });\n\n    var renderTree = editor._renderTree;\n    var elementNode = editorElement.firstChild;\n    var position = _mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, elementNode, 1);\n\n    assert.positionIsEqual(position, editor.post.tailPosition());\n  });\n\n  test('#fromNode when node is card section element or next to it', function (assert) {\n    var editorOptions = { cards: [{\n        name: 'some-card',\n        type: 'dom',\n        render: function render() {\n          return $('<div id=\"the-card\">this is the card</div>')[0];\n        }\n      }] };\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref22) {\n      var post = _ref22.post;\n      var cardSection = _ref22.cardSection;\n\n      return post([cardSection('some-card')]);\n    }, editorOptions);\n\n    var nodes = {\n      wrapper: editorElement.firstChild,\n      leftCursor: editorElement.firstChild.firstChild,\n      rightCursor: editorElement.firstChild.lastChild,\n      cardDiv: editorElement.firstChild.childNodes[1]\n    };\n\n    assert.ok(nodes.wrapper && nodes.leftCursor && nodes.rightCursor && nodes.cardDiv, 'precond - nodes');\n\n    assert.equal(nodes.wrapper.tagName.toLowerCase(), 'div', 'precond - wrapper');\n    assert.equal(nodes.leftCursor.textContent, _mobiledocKitRenderersEditorDom.ZWNJ, 'precond - left cursor');\n    assert.equal(nodes.rightCursor.textContent, _mobiledocKitRenderersEditorDom.ZWNJ, 'precond - right cursor');\n    assert.ok(nodes.cardDiv.className.indexOf(_mobiledocKitRenderersEditorDom.CARD_ELEMENT_CLASS_NAME) !== -1, 'precond -card div');\n\n    var renderTree = editor._renderTree;\n    var cardSection = editor.post.sections.head;\n\n    var leftPos = cardSection.headPosition();\n    var rightPos = cardSection.tailPosition();\n\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.wrapper, 0), leftPos, 'wrapper offset 0');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.wrapper, 1), leftPos, 'wrapper offset 1');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.wrapper, 2), rightPos, 'wrapper offset 2');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.leftCursor, 0), leftPos, 'left cursor offset 0');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.leftCursor, 1), leftPos, 'left cursor offset 1');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.rightCursor, 0), rightPos, 'right cursor offset 0');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.rightCursor, 1), rightPos, 'right cursor offset 1');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.cardDiv, 0), leftPos, 'card div offset 0');\n    assert.positionIsEqual(_mobiledocKitUtilsCursorPosition['default'].fromNode(renderTree, nodes.cardDiv, 1), leftPos, 'card div offset 1');\n  });\n\n  /**\n   * When triple-clicking text in a disabled editor, some browsers will\n   * expand the selection to include the start of a node outside the editor.\n   * See: https://github.com/bustle/mobiledoc-kit/issues/486\n   *\n   * Chrome and Safari appear to extend the selection to the next node in the document\n   * that has a textNode in it. Firefox does not suffer from this issue.\n   */\n  test('#fromNode when selection is outside (after) the editor element', function (assert) {\n    var done = assert.async();\n    var div$ = $('<div><p>AFTER</p></div>').insertAfter($(editorElement));\n    var p = div$[0].firstChild;\n\n    editor = _testHelpers['default'].mobiledoc.renderInto(editorElement, function (_ref23) {\n      var post = _ref23.post;\n      var markupSection = _ref23.markupSection;\n      var marker = _ref23.marker;\n      return post([markupSection('p', [marker('abcdef')])]);\n    });\n\n    // If the editor isn't disabled, some browsers will \"fix\" the selection range we are\n    // about to add by constraining it within the contentEditable container div\n    editor.disableEditing();\n\n    var anchorNode = $(editorElement).find('p:contains(abcdef)')[0].firstChild;\n    var focusNode = p;\n    _testHelpers['default'].dom.selectRange(anchorNode, 0, focusNode, 0);\n\n    _testHelpers['default'].wait(function () {\n      assert.ok(window.getSelection().anchorNode === anchorNode, 'precond - anchor node');\n      assert.ok(window.getSelection().focusNode === focusNode, 'precond - focus node');\n      var range = editor.range;\n\n      assert.positionIsEqual(range.head, editor.post.headPosition(), 'head');\n      assert.positionIsEqual(range.tail, editor.post.tailPosition(), 'tail');\n\n      div$.remove();\n      done();\n    });\n  });\n\n  test('Position cannot be on list section', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref24) {\n      var post = _ref24.post;\n      var listSection = _ref24.listSection;\n      var listItem = _ref24.listItem;\n\n      return post([listSection('ul', [listItem()])]);\n    });\n\n    var listSection = post.sections.head;\n    var listItem = listSection.items.head;\n\n    var position = undefined;\n    assert.throws(function () {\n      position = listSection.toPosition(0);\n    }, /addressable by the cursor/);\n\n    position = listItem.toPosition(0);\n    assert.ok(position, 'position with list item is ok');\n  });\n});","define('tests/unit/utils/cursor-range-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/cursor/range', 'mobiledoc-kit/utils/key', 'mobiledoc-kit/utils/array-utils'], function (exports, _testHelpers, _mobiledocKitUtilsCursorRange, _mobiledocKitUtilsKey, _mobiledocKitUtilsArrayUtils) {\n  'use strict';\n\n  var FORWARD = _mobiledocKitUtilsKey.DIRECTION.FORWARD;\n  var BACKWARD = _mobiledocKitUtilsKey.DIRECTION.BACKWARD;\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: Range');\n\n  test('#trimTo(section) when range covers only one section', function (assert) {\n    var section = _testHelpers['default'].postAbstract.build(function (_ref) {\n      var markupSection = _ref.markupSection;\n      return markupSection();\n    });\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, 5);\n\n    var newRange = range.trimTo(section);\n    assert.ok(newRange.head.section === section, 'head section is correct');\n    assert.ok(newRange.tail.section === section, 'tail section is correct');\n    assert.equal(newRange.head.offset, 0, 'head offset');\n    assert.equal(newRange.tail.offset, 0, 'tail offset');\n  });\n\n  test('#trimTo head section', function (assert) {\n    var text = 'abcdef';\n    var section1 = _testHelpers['default'].postAbstract.build(function (_ref2) {\n      var markupSection = _ref2.markupSection;\n      var marker = _ref2.marker;\n      return markupSection('p', [marker(text)]);\n    });\n    var section2 = _testHelpers['default'].postAbstract.build(function (_ref3) {\n      var markupSection = _ref3.markupSection;\n      var marker = _ref3.marker;\n      return markupSection('p', [marker(text)]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section1, 0, section2, 5);\n    var newRange = range.trimTo(section1);\n\n    assert.ok(newRange.head.section === section1, 'head section');\n    assert.ok(newRange.tail.section === section1, 'tail section');\n    assert.equal(newRange.head.offset, 0, 'head offset');\n    assert.equal(newRange.tail.offset, text.length, 'tail offset');\n  });\n\n  test('#trimTo tail section', function (assert) {\n    var text = 'abcdef';\n    var section1 = _testHelpers['default'].postAbstract.build(function (_ref4) {\n      var markupSection = _ref4.markupSection;\n      var marker = _ref4.marker;\n      return markupSection('p', [marker(text)]);\n    });\n    var section2 = _testHelpers['default'].postAbstract.build(function (_ref5) {\n      var markupSection = _ref5.markupSection;\n      var marker = _ref5.marker;\n      return markupSection('p', [marker(text)]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section1, 0, section2, 5);\n    var newRange = range.trimTo(section2);\n\n    assert.ok(newRange.head.section === section2, 'head section');\n    assert.ok(newRange.tail.section === section2, 'tail section');\n    assert.equal(newRange.head.offset, 0, 'head offset');\n    assert.equal(newRange.tail.offset, 5, 'tail offset');\n  });\n\n  test('#trimTo middle section', function (assert) {\n    var text = 'abcdef';\n    var section1 = _testHelpers['default'].postAbstract.build(function (_ref6) {\n      var markupSection = _ref6.markupSection;\n      var marker = _ref6.marker;\n      return markupSection('p', [marker(text)]);\n    });\n    var section2 = _testHelpers['default'].postAbstract.build(function (_ref7) {\n      var markupSection = _ref7.markupSection;\n      var marker = _ref7.marker;\n      return markupSection('p', [marker(text)]);\n    });\n    var section3 = _testHelpers['default'].postAbstract.build(function (_ref8) {\n      var markupSection = _ref8.markupSection;\n      var marker = _ref8.marker;\n      return markupSection('p', [marker(text)]);\n    });\n\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section1, 0, section3, 5);\n    var newRange = range.trimTo(section2);\n\n    assert.ok(newRange.head.section === section2, 'head section');\n    assert.ok(newRange.tail.section === section2, 'tail section');\n    assert.equal(newRange.head.offset, 0, 'head offset');\n    assert.equal(newRange.tail.offset, section2.text.length, 'tail offset');\n  });\n\n  test('#move moves collapsed range 1 character in direction', function (assert) {\n    var section = _testHelpers['default'].postAbstract.build(function (_ref9) {\n      var markupSection = _ref9.markupSection;\n      var marker = _ref9.marker;\n\n      return markupSection('p', [marker('abc')]);\n    });\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 0);\n    var nextRange = _mobiledocKitUtilsCursorRange['default'].create(section, 1);\n\n    assert.ok(range.isCollapsed, 'precond - range.isCollapsed');\n    assert.rangeIsEqual(range.move(_mobiledocKitUtilsKey.DIRECTION.FORWARD), nextRange, 'move forward');\n\n    assert.rangeIsEqual(nextRange.move(_mobiledocKitUtilsKey.DIRECTION.BACKWARD), range, 'move backward');\n  });\n\n  test('#move collapses non-collapsd range in direction', function (assert) {\n    var section = _testHelpers['default'].postAbstract.build(function (_ref10) {\n      var markupSection = _ref10.markupSection;\n      var marker = _ref10.marker;\n\n      return markupSection('p', [marker('abcd')]);\n    });\n    var range = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 3);\n    var collapseForward = _mobiledocKitUtilsCursorRange['default'].create(section, 3);\n    var collapseBackward = _mobiledocKitUtilsCursorRange['default'].create(section, 1);\n\n    assert.ok(!range.isCollapsed, 'precond - !range.isCollapsed');\n    assert.rangeIsEqual(range.move(FORWARD), collapseForward, 'collapse forward');\n    assert.rangeIsEqual(range.move(BACKWARD), collapseBackward, 'collapse forward');\n  });\n\n  test('#extend expands range in direction', function (assert) {\n    var section = _testHelpers['default'].postAbstract.build(function (_ref11) {\n      var markupSection = _ref11.markupSection;\n      var marker = _ref11.marker;\n\n      return markupSection('p', [marker('abcd')]);\n    });\n    var collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(section, 1);\n    var collapsedRangeForward = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 2, FORWARD);\n    var collapsedRangeBackward = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, 1, BACKWARD);\n\n    var nonCollapsedRange = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 2);\n    var nonCollapsedRangeForward = _mobiledocKitUtilsCursorRange['default'].create(section, 1, section, 3, FORWARD);\n    var nonCollapsedRangeBackward = _mobiledocKitUtilsCursorRange['default'].create(section, 0, section, 2, BACKWARD);\n\n    assert.ok(collapsedRange.isCollapsed, 'precond - collapsedRange.isCollapsed');\n    assert.rangeIsEqual(collapsedRange.extend(FORWARD), collapsedRangeForward, 'collapsedRange extend forward');\n    assert.rangeIsEqual(collapsedRange.extend(BACKWARD), collapsedRangeBackward, 'collapsedRange extend backward');\n\n    assert.ok(!nonCollapsedRange.isCollapsed, 'precond -nonCollapsedRange.isCollapsed');\n    assert.rangeIsEqual(nonCollapsedRange.extend(FORWARD), nonCollapsedRangeForward, 'nonCollapsedRange extend forward');\n    assert.rangeIsEqual(nonCollapsedRange.extend(BACKWARD), nonCollapsedRangeBackward, 'nonCollapsedRange extend backward');\n  });\n\n  test('#extend expands range in multiple units in direction', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref12) {\n      var post = _ref12.post;\n      var markupSection = _ref12.markupSection;\n      var marker = _ref12.marker;\n\n      return post([markupSection('p', [marker('abcd')]), markupSection('p', [marker('1234')])]);\n    });\n\n    var headSection = post.sections.head;\n    var tailSection = post.sections.tail;\n\n    // FORWARD\n    var collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(headSection, 0);\n    var nonCollapsedRange = _mobiledocKitUtilsCursorRange['default'].create(headSection, 0, headSection, 1);\n    assert.rangeIsEqual(collapsedRange.extend(FORWARD * 2), _mobiledocKitUtilsCursorRange['default'].create(headSection, 0, headSection, 2, FORWARD), 'extend forward 2');\n\n    assert.rangeIsEqual(collapsedRange.extend(FORWARD * ('abcd12'.length + 1)), _mobiledocKitUtilsCursorRange['default'].create(headSection, 0, tailSection, 2, FORWARD), 'extend forward across sections');\n\n    assert.rangeIsEqual(nonCollapsedRange.extend(FORWARD * 2), _mobiledocKitUtilsCursorRange['default'].create(headSection, 0, headSection, 3, FORWARD), 'extend non-collapsed forward 2');\n\n    assert.rangeIsEqual(nonCollapsedRange.extend(FORWARD * ('bcd12'.length + 1)), _mobiledocKitUtilsCursorRange['default'].create(headSection, 0, tailSection, 2, FORWARD), 'extend non-collapsed across sections');\n\n    // BACKWARD\n    collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(tailSection, '1234'.length);\n    nonCollapsedRange = _mobiledocKitUtilsCursorRange['default'].create(tailSection, '12'.length, tailSection, '1234'.length);\n    assert.rangeIsEqual(collapsedRange.extend(BACKWARD * '12'.length), _mobiledocKitUtilsCursorRange['default'].create(tailSection, '12'.length, tailSection, '1234'.length, BACKWARD), 'extend backward 2');\n\n    assert.rangeIsEqual(collapsedRange.extend(BACKWARD * ('1234cd'.length + 1)), _mobiledocKitUtilsCursorRange['default'].create(headSection, 'ab'.length, tailSection, '1234'.length, BACKWARD), 'extend backward across sections');\n\n    assert.rangeIsEqual(nonCollapsedRange.extend(BACKWARD * 2), _mobiledocKitUtilsCursorRange['default'].create(tailSection, 0, tailSection, '1234'.length, BACKWARD), 'extend non-collapsed backward 2');\n\n    assert.rangeIsEqual(nonCollapsedRange.extend(BACKWARD * ('bcd12'.length + 1)), _mobiledocKitUtilsCursorRange['default'].create(headSection, 'a'.length, tailSection, '1234'.length, BACKWARD), 'extend non-collapsed backward across sections');\n  });\n\n  test('#extend(0) returns same range', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref13) {\n      var post = _ref13.post;\n      var markupSection = _ref13.markupSection;\n      var marker = _ref13.marker;\n\n      return post([markupSection('p', [marker('abcd')]), markupSection('p', [marker('1234')])]);\n    });\n\n    var headSection = post.sections.head;\n\n    var collapsedRange = _mobiledocKitUtilsCursorRange['default'].create(headSection, 0);\n    var nonCollapsedRange = _mobiledocKitUtilsCursorRange['default'].create(headSection, 0, headSection, 1);\n\n    assert.rangeIsEqual(collapsedRange.extend(0), collapsedRange, 'extending collapsed range 0 is no-op');\n    assert.rangeIsEqual(nonCollapsedRange.extend(0), nonCollapsedRange, 'extending non-collapsed range 0 is no-op');\n  });\n\n  test('#expandByMarker processed markers in a callback and continues as long as the callback returns true', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref14) {\n      var post = _ref14.post;\n      var markupSection = _ref14.markupSection;\n      var marker = _ref14.marker;\n      var markup = _ref14.markup;\n\n      var bold = markup('b');\n      var italic = markup('i');\n      return post([markupSection('p', [marker('aiya', []), marker('biya', [bold, italic]), marker('ciya', [bold]), marker('diya', [bold])])]);\n    });\n\n    var section = post.sections.head;\n    var head = section.toPosition(9); // i in the third hiya\n    var tail = section.toPosition(15); // y in the last hiya\n    var range = head.toRange(tail);\n    var expandedRange = range.expandByMarker(function (marker) {\n      return !!(0, _mobiledocKitUtilsArrayUtils.detect)(marker.markups, function (markup) {\n        return markup.tagName === 'b';\n      });\n    });\n\n    assert.positionIsEqual(expandedRange.head, section.toPosition(4), 'range head is start of second marker');\n    assert.positionIsEqual(expandedRange.tail, section.toPosition(16), 'range tail did not change');\n  });\n\n  // https://github.com/bustle/mobiledoc-kit/issues/676\n  test('#expandByMarker can expand to beginning of section with matching markups', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref15) {\n      var post = _ref15.post;\n      var markupSection = _ref15.markupSection;\n      var marker = _ref15.marker;\n      var markup = _ref15.markup;\n\n      var bold = markup('b');\n      var italic = markup('i');\n      return post([markupSection('p', [marker('aiya', [bold]), marker('biya', [bold, italic]), marker('ciya', [bold]), marker('diya', [bold])])]);\n    });\n\n    var section = post.sections.head;\n    var head = section.toPosition(14); // i in 4th hiya\n    var tail = section.toPosition(14); // i in 4th hiya\n    var range = head.toRange(tail);\n    var expandedRange = range.expandByMarker(function (marker) {\n      return !!(0, _mobiledocKitUtilsArrayUtils.detect)(marker.markups, function (markup) {\n        return markup.tagName === 'b';\n      });\n    });\n\n    assert.positionIsEqual(expandedRange.head, section.toPosition(0), 'range head is start of first marker');\n    assert.positionIsEqual(expandedRange.tail, section.toPosition(16), 'range tail is at end of last marker');\n  });\n\n  test('#expandByMarker can expand to end of section with matching markups', function (assert) {\n    var post = _testHelpers['default'].postAbstract.build(function (_ref16) {\n      var post = _ref16.post;\n      var markupSection = _ref16.markupSection;\n      var marker = _ref16.marker;\n      var markup = _ref16.markup;\n\n      var bold = markup('b');\n      var italic = markup('i');\n      return post([markupSection('p', [marker('aiya', [bold]), marker('biya', [bold, italic]), marker('ciya', [bold]), marker('diya', [bold])])]);\n    });\n\n    var section = post.sections.head;\n    var head = section.toPosition(2); // i in 4th hiya\n    var tail = section.toPosition(2); // i in 4th hiya\n    var range = head.toRange(tail);\n    var expandedRange = range.expandByMarker(function (marker) {\n      return !!(0, _mobiledocKitUtilsArrayUtils.detect)(marker.markups, function (markup) {\n        return markup.tagName === 'b';\n      });\n    });\n\n    assert.positionIsEqual(expandedRange.head, section.toPosition(0), 'range head is start of first marker');\n    assert.positionIsEqual(expandedRange.tail, section.toPosition(16), 'range tail is at end of last marker');\n  });\n});","define('tests/unit/utils/fixed-queue-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/fixed-queue'], function (exports, _testHelpers, _mobiledocKitUtilsFixedQueue) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: FixedQueue');\n\n  test('basic implementation', function (assert) {\n    var queue = new _mobiledocKitUtilsFixedQueue['default'](3);\n    for (var i = 0; i < 3; i++) {\n      queue.push(i);\n    }\n\n    assert.equal(queue.length, 3);\n\n    var popped = [];\n    while (queue.length) {\n      popped.push(queue.pop());\n    }\n\n    assert.deepEqual(popped, [2, 1, 0]);\n  });\n\n  test('empty queue', function (assert) {\n    var queue = new _mobiledocKitUtilsFixedQueue['default'](0);\n    assert.equal(queue.length, 0);\n    assert.equal(queue.pop(), undefined);\n    queue.push(1);\n\n    assert.equal(queue.length, 0);\n    assert.deepEqual(queue.toArray(), []);\n  });\n\n  test('push onto full queue ejects first item', function (assert) {\n    var queue = new _mobiledocKitUtilsFixedQueue['default'](1);\n    queue.push(0);\n    queue.push(1);\n\n    assert.deepEqual(queue.toArray(), [1]);\n  });\n});","define('tests/unit/utils/key-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/key', 'mobiledoc-kit/utils/keys', 'mobiledoc-kit/utils/keycodes'], function (exports, _testHelpers, _mobiledocKitUtilsKey, _mobiledocKitUtilsKeys, _mobiledocKitUtilsKeycodes) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: Key');\n\n  test('#hasModifier with no modifier', function (assert) {\n    var event = _testHelpers['default'].dom.createMockEvent('keydown', null, { keyCode: 42 });\n    var key = _mobiledocKitUtilsKey['default'].fromEvent(event);\n\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.META), \"META not pressed\");\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.CTRL), \"CTRL not pressed\");\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.SHIFT), \"SHIFT not pressed\");\n  });\n\n  test('#hasModifier with META', function (assert) {\n    var event = _testHelpers['default'].dom.createMockEvent('keyup', null, { metaKey: true });\n    var key = _mobiledocKitUtilsKey['default'].fromEvent(event);\n\n    assert.ok(key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.META), \"META pressed\");\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.CTRL), \"CTRL not pressed\");\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.SHIFT), \"SHIFT not pressed\");\n  });\n\n  test('#hasModifier with CTRL', function (assert) {\n    var event = _testHelpers['default'].dom.createMockEvent('keypress', null, { ctrlKey: true });\n    var key = _mobiledocKitUtilsKey['default'].fromEvent(event);\n\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.META), \"META not pressed\");\n    assert.ok(key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.CTRL), \"CTRL pressed\");\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.SHIFT), \"SHIFT not pressed\");\n  });\n\n  test('#hasModifier with SHIFT', function (assert) {\n    var event = _testHelpers['default'].dom.createMockEvent('keydown', null, { shiftKey: true });\n    var key = _mobiledocKitUtilsKey['default'].fromEvent(event);\n\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.META), \"META not pressed\");\n    assert.ok(!key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.CTRL), \"CTRL not pressed\");\n    assert.ok(key.hasModifier(_mobiledocKitUtilsKey.MODIFIERS.SHIFT), \"SHIFT pressed\");\n  });\n\n  // Firefox will fire keypress events for some keys that should not be printable\n  test('firefox: non-printable are treated as not printable', function (assert) {\n    var KEYS = [_mobiledocKitUtilsKeys['default'].DOWN, _mobiledocKitUtilsKeys['default'].HOME, _mobiledocKitUtilsKeys['default'].END, _mobiledocKitUtilsKeys['default'].PAGEUP, _mobiledocKitUtilsKeys['default'].PAGEDOWN, _mobiledocKitUtilsKeys['default'].INS, _mobiledocKitUtilsKeys['default'].CLEAR, _mobiledocKitUtilsKeys['default'].PAUSE, _mobiledocKitUtilsKeys['default'].ESC];\n\n    KEYS.forEach(function (key) {\n      var element = $('#qunit-fixture')[0];\n      var event = _testHelpers['default'].dom.createMockEvent('keypress', element, {\n        key: key\n      });\n      var keyInstance = _mobiledocKitUtilsKey['default'].fromEvent(event);\n\n      assert.ok(!keyInstance.isPrintable(), 'key ' + key + ' is not printable');\n    });\n  });\n\n  test('uses keyCode as a fallback if key is not supported', function (assert) {\n    var element = $('#qunit-fixture')[0];\n\n    var event = _testHelpers['default'].dom.createMockEvent('keypress', element, {\n      key: _mobiledocKitUtilsKeys['default'].ESC,\n      keyCode: _mobiledocKitUtilsKeycodes['default'].SPACE\n    });\n    var keyInstance = _mobiledocKitUtilsKey['default'].fromEvent(event);\n    assert.ok(keyInstance.isEscape(), 'key is preferred over keyCode if supported');\n\n    event = _testHelpers['default'].dom.createMockEvent('keypress', element, {\n      keyCode: _mobiledocKitUtilsKeycodes['default'].SPACE\n    });\n    keyInstance = _mobiledocKitUtilsKey['default'].fromEvent(event);\n    assert.ok(keyInstance.isSpace(), 'keyCode is used if key is not supported');\n  });\n});","define('tests/unit/utils/linked-list-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/linked-list', 'mobiledoc-kit/utils/linked-item'], function (exports, _testHelpers, _mobiledocKitUtilsLinkedList, _mobiledocKitUtilsLinkedItem) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  var INSERTION_METHODS = ['append', 'prepend', 'insertBefore', 'insertAfter'];\n\n  _module('Unit: Utils: LinkedList');\n\n  test('initial state', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    assert.equal(list.head, null, 'head is null');\n    assert.equal(list.tail, null, 'tail is null');\n    assert.equal(list.length, 0, 'length is one');\n    assert.equal(list.isEmpty, true, 'isEmpty is true');\n  });\n\n  INSERTION_METHODS.forEach(function (method) {\n    test('#' + method + ' initial item', function (assert) {\n      var list = new _mobiledocKitUtilsLinkedList['default']();\n      var item = new _mobiledocKitUtilsLinkedItem['default']();\n      list[method](item);\n      assert.equal(list.length, 1, 'length is one');\n      assert.equal(list.isEmpty, false, 'isEmpty is false');\n      assert.equal(list.head, item, 'head is item');\n      assert.equal(list.tail, item, 'tail is item');\n      assert.equal(item.next, null, 'item next is null');\n      assert.equal(item.prev, null, 'item prev is null');\n    });\n\n    test('#' + method + ' calls adoptItem', function (assert) {\n      var adoptedItem = undefined;\n      var list = new _mobiledocKitUtilsLinkedList['default']({\n        adoptItem: function adoptItem(item) {\n          adoptedItem = item;\n        }\n      });\n      var item = new _mobiledocKitUtilsLinkedItem['default']();\n      list[method](item);\n      assert.equal(adoptedItem, item, 'item is adopted');\n    });\n\n    test('#' + method + ' throws when inserting item that is already in this list', function (assert) {\n      var list = new _mobiledocKitUtilsLinkedList['default']();\n      var item = new _mobiledocKitUtilsLinkedItem['default']();\n      list[method](item);\n\n      assert.throws(function () {\n        return list[method](item);\n      }, /Cannot insert.*already in a list/);\n    });\n\n    test('#' + method + ' throws if item is in another list', function (assert) {\n      var list = new _mobiledocKitUtilsLinkedList['default']();\n      var otherList = new _mobiledocKitUtilsLinkedList['default']();\n      var item = new _mobiledocKitUtilsLinkedItem['default']();\n      var otherItem = new _mobiledocKitUtilsLinkedItem['default']();\n\n      list[method](item);\n      otherList[method](otherItem);\n\n      assert.throws(function () {\n        return list[method](otherItem);\n      }, /Cannot insert.*already in a list/);\n    });\n  });\n\n  test('#append second item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    assert.equal(list.length, 2, 'length is two');\n    assert.equal(list.head, itemOne, 'head is itemOne');\n    assert.equal(list.tail, itemTwo, 'tail is itemTwo');\n    assert.equal(itemOne.prev, null, 'itemOne prev is null');\n    assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');\n    assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');\n    assert.equal(itemTwo.next, null, 'itemTwo next is null');\n  });\n\n  test('#prepend additional item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    list.prepend(itemTwo);\n    list.prepend(itemOne);\n    assert.equal(list.length, 2, 'length is two');\n    assert.equal(list.head, itemOne, 'head is itemOne');\n    assert.equal(list.tail, itemTwo, 'tail is itemTwo');\n    assert.equal(itemOne.prev, null, 'itemOne prev is null');\n    assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');\n    assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');\n    assert.equal(itemTwo.next, null, 'itemTwo next is null');\n  });\n\n  test('#insertBefore a middle item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.prepend(itemOne);\n    list.append(itemThree);\n    list.insertBefore(itemTwo, itemThree);\n    assert.equal(list.length, 3, 'length is three');\n    assert.equal(list.head, itemOne, 'head is itemOne');\n    assert.equal(list.tail, itemThree, 'tail is itemThree');\n    assert.equal(itemOne.prev, null, 'itemOne prev is null');\n    assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');\n    assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');\n    assert.equal(itemTwo.next, itemThree, 'itemTwo next is itemThree');\n    assert.equal(itemThree.prev, itemTwo, 'itemThree prev is itemTwo');\n    assert.equal(itemThree.next, null, 'itemThree next is null');\n  });\n\n  test('#insertBefore null reference item appends the item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var item1 = new _mobiledocKitUtilsLinkedItem['default']();\n    var item2 = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(item1);\n    list.insertBefore(item2, null);\n\n    assert.equal(list.length, 2);\n    assert.equal(list.tail, item2, 'item2 is appended');\n    assert.equal(list.head, item1, 'item1 is at head');\n    assert.equal(item2.prev, item1, 'item2.prev');\n    assert.equal(item1.next, item2, 'item1.next');\n    assert.equal(item2.next, null);\n    assert.equal(item1.prev, null);\n  });\n\n  test('#insertAfter a middle item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.prepend(itemOne);\n    list.append(itemThree);\n    list.insertAfter(itemTwo, itemOne);\n\n    assert.equal(list.length, 3);\n    assert.equal(list.head, itemOne, 'head is itemOne');\n    assert.equal(list.tail, itemThree, 'tail is itemThree');\n    assert.equal(itemOne.prev, null, 'itemOne prev is null');\n    assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');\n    assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');\n    assert.equal(itemTwo.next, itemThree, 'itemTwo next is itemThree');\n    assert.equal(itemThree.prev, itemTwo, 'itemThree prev is itemTwo');\n    assert.equal(itemThree.next, null, 'itemThree next is null');\n  });\n\n  test('#insertAfter null reference item prepends the item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var item1 = new _mobiledocKitUtilsLinkedItem['default']();\n    var item2 = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(item2);\n    list.insertAfter(item1, null);\n\n    assert.equal(list.length, 2);\n    assert.equal(list.head, item1, 'item2 is appended');\n    assert.equal(list.tail, item2, 'item1 is at tail');\n    assert.equal(item1.next, item2, 'item1.next = item2');\n    assert.equal(item1.prev, null, 'item1.prev = null');\n    assert.equal(item2.prev, item1, 'item2.prev = item1');\n    assert.equal(item2.next, null, 'item2.next = null');\n  });\n\n  test('#remove an only item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var item = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(item);\n    list.remove(item);\n    assert.equal(list.length, 0, 'length is zero');\n    assert.equal(list.isEmpty, true, 'isEmpty is true');\n    assert.equal(list.head, null, 'head is null');\n    assert.equal(list.tail, null, 'tail is null');\n    assert.equal(item.prev, null, 'item prev is null');\n    assert.equal(item.next, null, 'item next is null');\n  });\n\n  test('#remove calls freeItem', function (assert) {\n    var freed = [];\n    var list = new _mobiledocKitUtilsLinkedList['default']({\n      freeItem: function freeItem(item) {\n        freed.push(item);\n      }\n    });\n    var item = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(item);\n    list.remove(item);\n    assert.deepEqual(freed, [item]);\n  });\n\n  test('#remove a first item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.remove(itemOne);\n\n    assert.equal(list.length, 1);\n    assert.equal(list.head, itemTwo, 'head is itemTwo');\n    assert.equal(list.tail, itemTwo, 'tail is itemTwo');\n    assert.equal(itemOne.prev, null, 'itemOne prev is null');\n    assert.equal(itemOne.next, null, 'itemOne next is null');\n    assert.equal(itemTwo.prev, null, 'itemTwo prev is null');\n    assert.equal(itemTwo.next, null, 'itemTwo next is null');\n  });\n\n  test('#remove a last item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.remove(itemTwo);\n    assert.equal(list.length, 1);\n    assert.equal(list.head, itemOne, 'head is itemOne');\n    assert.equal(list.tail, itemOne, 'tail is itemOne');\n    assert.equal(itemOne.prev, null, 'itemOne prev is null');\n    assert.equal(itemOne.next, null, 'itemOne next is null');\n    assert.equal(itemTwo.prev, null, 'itemTwo prev is null');\n    assert.equal(itemTwo.next, null, 'itemTwo next is null');\n  });\n\n  test('#remove a middle item', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n    list.remove(itemTwo);\n\n    assert.equal(list.length, 2);\n    assert.equal(list.head, itemOne, 'head is itemOne');\n    assert.equal(list.tail, itemThree, 'tail is itemThree');\n    assert.equal(itemOne.prev, null, 'itemOne prev is null');\n    assert.equal(itemOne.next, itemThree, 'itemOne next is itemThree');\n    assert.equal(itemTwo.prev, null, 'itemTwo prev is null');\n    assert.equal(itemTwo.next, null, 'itemTwo next is null');\n    assert.equal(itemThree.prev, itemOne, 'itemThree prev is itemOne');\n    assert.equal(itemThree.next, null, 'itemThree next is null');\n  });\n\n  test('#remove item that is not in the list is no-op', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var otherItem = new _mobiledocKitUtilsLinkedItem['default']();\n\n    list.remove(otherItem);\n    assert.equal(list.length, 0);\n  });\n\n  test('#remove throws if item is in another list', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var otherList = new _mobiledocKitUtilsLinkedList['default']();\n    var otherItem = new _mobiledocKitUtilsLinkedItem['default']();\n\n    otherList.append(otherItem);\n\n    assert.throws(function () {\n      return list.remove(otherItem);\n    }, /Cannot remove.*other list/);\n  });\n\n  test('#forEach iterates many', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n    var items = [];\n    var indexes = [];\n    list.forEach(function (item, index) {\n      items.push(item);\n      indexes.push(index);\n    });\n    assert.deepEqual(items, [itemOne, itemTwo, itemThree], 'items correct');\n    assert.deepEqual(indexes, [0, 1, 2], 'indexes correct');\n  });\n\n  test('#forEach iterates one', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    var items = [];\n    var indexes = [];\n    list.forEach(function (item, index) {\n      items.push(item);\n      indexes.push(index);\n    });\n    assert.deepEqual(items, [itemOne], 'items correct');\n    assert.deepEqual(indexes, [0], 'indexes correct');\n  });\n\n  test('#forEach exits early if item is removed by callback', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    [0, 1, 2].forEach(function (val) {\n      var i = new _mobiledocKitUtilsLinkedItem['default']();\n      i.value = val;\n      list.append(i);\n    });\n\n    var iterated = [];\n    list.forEach(function (item, index) {\n      iterated.push(item.value);\n      if (index === 1) {\n        list.remove(item); // iteration stops, skipping value 2\n      }\n    });\n\n    assert.deepEqual(iterated, [0, 1], 'iteration stops when item.next is null');\n  });\n\n  test('#readRange walks from start to end', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n    var items = [];\n    var indexes = [];\n    list.forEach(function (item, index) {\n      items.push(item);\n      indexes.push(index);\n    });\n    assert.deepEqual(list.readRange(itemOne, itemOne), [itemOne], 'items correct');\n    assert.deepEqual(list.readRange(itemTwo, itemThree), [itemTwo, itemThree], 'items correct');\n    assert.deepEqual(list.readRange(itemOne, itemTwo), [itemOne, itemTwo], 'items correct');\n    assert.deepEqual(list.readRange(itemOne, null), [itemOne, itemTwo, itemThree], 'items correct');\n  });\n\n  test('#toArray builds array', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    assert.deepEqual(list.toArray(), [itemOne], 'items correct');\n  });\n\n  test('#toArray builds many array', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n    assert.deepEqual(list.toArray(), [itemOne, itemTwo, itemThree], 'items correct');\n  });\n\n  test('#detect finds', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n    assert.equal(list.detect(function (item) {\n      return item === itemOne;\n    }), itemOne, 'itemOne detected');\n    assert.equal(list.detect(function (item) {\n      return item === itemTwo;\n    }), itemTwo, 'itemTwo detected');\n    assert.equal(list.detect(function (item) {\n      return item === itemThree;\n    }), itemThree, 'itemThree detected');\n    assert.equal(list.detect(function () {\n      return false;\n    }), undefined, 'no item detected');\n  });\n\n  test('#detect finds w/ start', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n    assert.equal(list.detect(function (item) {\n      return item === itemOne;\n    }, itemOne), itemOne, 'itemOne detected');\n    assert.equal(list.detect(function (item) {\n      return item === itemTwo;\n    }, itemThree), null, 'no item detected');\n  });\n\n  test('#detect finds w/ reverse', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n    assert.equal(list.detect(function (item) {\n      return item === itemOne;\n    }, itemOne, true), itemOne, 'itemTwo detected');\n    assert.equal(list.detect(function (item) {\n      return item === itemThree;\n    }, itemThree, true), itemThree, 'itemThree');\n  });\n\n  test('#objectAt looks up by index', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    assert.equal(list.objectAt(0), itemOne, 'itemOne looked up');\n\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemTwo);\n    list.append(itemThree);\n    assert.equal(list.objectAt(0), itemOne, 'itemOne looked up');\n    assert.equal(list.objectAt(1), itemTwo, 'itemTwo looked up');\n    assert.equal(list.objectAt(2), itemThree, 'itemThree looked up');\n  });\n\n  test('#splice removes a target and inserts an array of items', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemThree);\n\n    list.splice(itemOne, 1, [itemTwo]);\n\n    assert.equal(list.head, itemTwo, 'itemOne is head');\n    assert.equal(list.objectAt(1), itemThree, 'itemThree is present');\n  });\n\n  test('#splice remove nothing and inserts an array of nothing', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n\n    list.splice(itemTwo, 0, []);\n\n    assert.equal(list.head, itemOne, 'itemOne is head');\n    assert.equal(list.objectAt(1), itemTwo, 'itemTwo is present');\n  });\n\n  test('#splice can reorganize items', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var itemOne = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemTwo = new _mobiledocKitUtilsLinkedItem['default']();\n    var itemThree = new _mobiledocKitUtilsLinkedItem['default']();\n    list.append(itemOne);\n    list.append(itemTwo);\n    list.append(itemThree);\n\n    list.splice(itemOne, 3, [itemThree, itemOne, itemTwo]);\n\n    assert.equal(list.head, itemThree, 'itemThree is head');\n    assert.equal(list.objectAt(1), itemOne, 'itemOne is present');\n    assert.equal(list.objectAt(2), itemTwo, 'itemTwo is present');\n  });\n\n  test('#removeBy mutates list when item is in middle', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var items = [new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default']()];\n    items[1].shouldRemove = true;\n    items.forEach(function (i) {\n      return list.append(i);\n    });\n\n    assert.equal(list.length, 4);\n    list.removeBy(function (i) {\n      return i.shouldRemove;\n    });\n    assert.equal(list.length, 3);\n    assert.equal(list.head, items[0]);\n    assert.equal(list.objectAt(1), items[2]);\n    assert.equal(list.objectAt(2), items[3]);\n    assert.equal(list.tail, items[3]);\n  });\n\n  test('#removeBy mutates list when item is first', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var items = [new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default']()];\n    items[0].shouldRemove = true;\n    items.forEach(function (i) {\n      return list.append(i);\n    });\n\n    assert.equal(list.length, 4);\n    list.removeBy(function (i) {\n      return i.shouldRemove;\n    });\n    assert.equal(list.length, 3);\n    assert.equal(list.head, items[1]);\n    assert.equal(list.objectAt(1), items[2]);\n    assert.equal(list.tail, items[3]);\n  });\n\n  test('#removeBy mutates list when item is last', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    var items = [new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default']()];\n    items[3].shouldRemove = true;\n    items.forEach(function (i) {\n      return list.append(i);\n    });\n\n    assert.equal(list.length, 4);\n    list.removeBy(function (i) {\n      return i.shouldRemove;\n    });\n    assert.equal(list.length, 3);\n    assert.equal(list.head, items[0]);\n    assert.equal(list.objectAt(1), items[1]);\n    assert.equal(list.tail, items[2]);\n  });\n\n  test('#removeBy calls `freeItem` for each item removed', function (assert) {\n    var freed = [];\n\n    var list = new _mobiledocKitUtilsLinkedList['default']({\n      freeItem: function freeItem(item) {\n        freed.push(item);\n      }\n    });\n\n    var items = [new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default'](), new _mobiledocKitUtilsLinkedItem['default']()];\n    items[0].name = '0';\n    items[1].name = '1';\n    items[2].name = '2';\n\n    items[0].shouldRemove = true;\n    items[1].shouldRemove = true;\n\n    items.forEach(function (i) {\n      return list.append(i);\n    });\n\n    list.removeBy(function (i) {\n      return i.shouldRemove;\n    });\n\n    assert.deepEqual(freed, [items[0], items[1]]);\n  });\n\n  test('#every', function (assert) {\n    var list = new _mobiledocKitUtilsLinkedList['default']();\n    [2, 3, 4].forEach(function (n) {\n      return list.append({ val: n });\n    });\n\n    assert.ok(list.every(function (i) {\n      return i.val > 0;\n    }), '> 0');\n    assert.ok(!list.every(function (i) {\n      return i.val % 2 === 0;\n    }), 'even');\n  });\n});","define('tests/unit/utils/parse-utils-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/parse-utils'], function (exports, _testHelpers, _mobiledocKitUtilsParseUtils) {\n  'use strict';\n\n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: Parse Utils');\n\n  test('#getContentFromPasteEvent reads from clipboardData', function (assert) {\n    var _expected;\n\n    var element = null;\n    var expected = (_expected = {}, _defineProperty(_expected, _mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN, 'text'), _defineProperty(_expected, _mobiledocKitUtilsParseUtils.MIME_TEXT_HTML, '<p>html</p>'), _expected);\n    var event = _testHelpers['default'].dom.createMockEvent('paste', element, {\n      clipboardData: {\n        getData: function getData(type) {\n          return expected[type];\n        }\n      }\n    });\n    var mockWindow = {\n      clipboardData: {\n        getData: function getData() {\n          assert.ok(false, 'should not get clipboard data from window');\n        }\n      }\n    };\n\n    var _getContentFromPasteEvent = (0, _mobiledocKitUtilsParseUtils.getContentFromPasteEvent)(event, mockWindow);\n\n    var html = _getContentFromPasteEvent.html;\n    var text = _getContentFromPasteEvent.text;\n\n    assert.equal(html, expected[_mobiledocKitUtilsParseUtils.MIME_TEXT_HTML], 'correct html');\n    assert.equal(text, expected[_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN], 'correct text');\n  });\n\n  test('#getContentFromPasteEvent reads data from window.clipboardData when event.clipboardData is not present (IE compat)', function (assert) {\n    assert.expect(3);\n    var element = null;\n    var event = _testHelpers['default'].dom.createMockEvent('paste', element, { clipboardData: null });\n    var requestedType = undefined;\n    var expectedHTML = 'hello';\n    var expectedText = '';\n    var mockWindow = {\n      clipboardData: {\n        getData: function getData(type) {\n          requestedType = type;\n          return expectedHTML;\n        }\n      }\n    };\n\n    var _getContentFromPasteEvent2 = (0, _mobiledocKitUtilsParseUtils.getContentFromPasteEvent)(event, mockWindow);\n\n    var html = _getContentFromPasteEvent2.html;\n    var text = _getContentFromPasteEvent2.text;\n\n    assert.equal(requestedType, _mobiledocKitUtilsParseUtils.NONSTANDARD_IE_TEXT_TYPE, 'requests IE nonstandard mime type');\n    assert.equal(html, expectedHTML, 'correct html');\n    assert.equal(text, expectedText, 'correct text');\n  });\n\n  test('#setClipboardData uses event.clipboardData.setData when available', function (assert) {\n    var element = null;\n    var _setData = {};\n    var data = {\n      html: '<p>html</p>',\n      text: 'text'\n    };\n    var event = _testHelpers['default'].dom.createMockEvent('copy', element, {\n      clipboardData: {\n        setData: function setData(type, value) {\n          _setData[type] = value;\n        }\n      }\n    });\n    var mockWindow = {\n      clipboardData: {\n        setData: function setData() {\n          assert.ok(false, 'should not set clipboard data on window');\n        }\n      }\n    };\n\n    (0, _mobiledocKitUtilsParseUtils.setClipboardData)(event, data, mockWindow);\n\n    assert.equal(_setData[_mobiledocKitUtilsParseUtils.MIME_TEXT_HTML], data.html);\n    assert.equal(_setData[_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN], data.text);\n  });\n\n  test('#setClipboardData uses window.clipboardData.setData when event.clipboardData not present (IE compat)', function (assert) {\n    var element = null;\n    var _setData2 = {};\n    var data = {\n      html: '<p>html</p>',\n      text: 'text'\n    };\n    var event = _testHelpers['default'].dom.createMockEvent('paste', element, {\n      clipboardData: null\n    });\n    var mockWindow = {\n      clipboardData: {\n        setData: function setData(type, value) {\n          _setData2[type] = value;\n        }\n      }\n    };\n\n    (0, _mobiledocKitUtilsParseUtils.setClipboardData)(event, data, mockWindow);\n\n    assert.equal(_setData2[_mobiledocKitUtilsParseUtils.NONSTANDARD_IE_TEXT_TYPE], data.html, 'sets NONSTANDARD_IE_TEXT_TYPE type');\n    assert.ok(!_setData2[_mobiledocKitUtilsParseUtils.MIME_TEXT_HTML], 'does not set MIME_TEXT_HTML');\n    assert.ok(!_setData2[_mobiledocKitUtilsParseUtils.MIME_TEXT_PLAIN], 'does not set MIME_TEXT_PLAIN');\n  });\n});","define('tests/unit/utils/selection-utils-test', ['exports', '../../test-helpers', 'mobiledoc-kit/utils/selection-utils', 'mobiledoc-kit/utils/key'], function (exports, _testHelpers, _mobiledocKitUtilsSelectionUtils, _mobiledocKitUtilsKey) {\n  'use strict';\n\n  var _module = _testHelpers['default'].module;\n  var test = _testHelpers['default'].test;\n\n  _module('Unit: Utils: Selection Utils');\n\n  test('#comparePosition returns the forward direction of selection', function (assert) {\n    var div = document.createElement('div');\n    div.innerHTML = 'Howdy';\n    var selection = {\n      anchorNode: div,\n      anchorOffset: 0,\n      focusNode: div,\n      focusOffset: 1\n    };\n    var result = (0, _mobiledocKitUtilsSelectionUtils.comparePosition)(selection);\n    assert.equal(_mobiledocKitUtilsKey.DIRECTION.FORWARD, result.direction);\n  });\n\n  test('#comparePosition returns the backward direction of selection', function (assert) {\n    var div = document.createElement('div');\n    div.innerHTML = 'Howdy';\n    var selection = {\n      anchorNode: div,\n      anchorOffset: 1,\n      focusNode: div,\n      focusOffset: 0\n    };\n    var result = (0, _mobiledocKitUtilsSelectionUtils.comparePosition)(selection);\n    assert.equal(_mobiledocKitUtilsKey.DIRECTION.BACKWARD, result.direction);\n  });\n\n  test('#comparePosition returns the direction of selection across nodes', function (assert) {\n    var div = document.createElement('div');\n    div.innerHTML = '<span>Howdy</span> <span>Friend</span>';\n    var selection = {\n      anchorNode: div.childNodes[0],\n      anchorOffset: 1,\n      focusNode: div.childNodes[2],\n      focusOffset: 0\n    };\n    var result = (0, _mobiledocKitUtilsSelectionUtils.comparePosition)(selection);\n    assert.equal(_mobiledocKitUtilsKey.DIRECTION.FORWARD, result.direction);\n  });\n\n  test('#comparePosition returns the backward direction of selection across nodes', function (assert) {\n    var div = document.createElement('div');\n    div.innerHTML = '<span>Howdy</span> <span>Friend</span>';\n    var selection = {\n      anchorNode: div.childNodes[2],\n      anchorOffset: 1,\n      focusNode: div.childNodes[1],\n      focusOffset: 0\n    };\n    var result = (0, _mobiledocKitUtilsSelectionUtils.comparePosition)(selection);\n    assert.equal(_mobiledocKitUtilsKey.DIRECTION.BACKWARD, result.direction);\n  });\n\n  test('#comparePosition returns the direction of selection with nested nodes', function (assert) {\n    var div = document.createElement('div');\n    div.innerHTML = '<span>Howdy</span> <span>Friend</span>';\n    var selection = {\n      anchorNode: div,\n      anchorOffset: 1,\n      focusNode: div.childNodes[1],\n      focusOffset: 1\n    };\n    var result = (0, _mobiledocKitUtilsSelectionUtils.comparePosition)(selection);\n    assert.equal(_mobiledocKitUtilsKey.DIRECTION.FORWARD, result.direction);\n  });\n\n  test('#comparePosition returns the backward direction of selection with nested nodes', function (assert) {\n    var div = document.createElement('div');\n    div.innerHTML = '<span>Howdy</span> <span>Friend</span>';\n    var selection = {\n      anchorNode: div.childNodes[2],\n      anchorOffset: 1,\n      focusNode: div,\n      focusOffset: 2\n    };\n    var result = (0, _mobiledocKitUtilsSelectionUtils.comparePosition)(selection);\n    assert.equal(_mobiledocKitUtilsKey.DIRECTION.BACKWARD, result.direction);\n  });\n});"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtjBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACv2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"built-amd-tests.js"}